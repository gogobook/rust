<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `pointer` primitive in crate `std`."><meta name="keywords" content="rust, rustlang, rust-lang, pointer"><title>pointer - Rust</title><link rel="stylesheet" type="text/css" href="../normalize1.39.0.css"><link rel="stylesheet" type="text/css" href="../rustdoc1.39.0.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark1.39.0.css"><link rel="stylesheet" type="text/css" href="../light1.39.0.css" id="themeStyle"><script src="../storage1.39.0.js"></script><noscript><link rel="stylesheet" href="../noscript1.39.0.css"></noscript><link rel="shortcut icon" href="../favicon1.39.0.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow1.39.0.svg");}</style></head><body class="rustdoc primitive"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../std/index.html'><div class='logo-container'><img src='../rust-logo1.39.0.png' alt='logo'></div></a><p class='location'>Primitive Type pointer</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#methods">Methods</a><div class="sidebar-links"><a href="#method.add">add</a><a href="#method.add-1">add</a><a href="#method.align_offset">align_offset</a><a href="#method.align_offset-1">align_offset</a><a href="#method.as_mut">as_mut</a><a href="#method.as_ref">as_ref</a><a href="#method.as_ref-1">as_ref</a><a href="#method.cast">cast</a><a href="#method.cast-1">cast</a><a href="#method.copy_from">copy_from</a><a href="#method.copy_from_nonoverlapping">copy_from_nonoverlapping</a><a href="#method.copy_to">copy_to</a><a href="#method.copy_to-1">copy_to</a><a href="#method.copy_to_nonoverlapping">copy_to_nonoverlapping</a><a href="#method.copy_to_nonoverlapping-1">copy_to_nonoverlapping</a><a href="#method.drop_in_place">drop_in_place</a><a href="#method.is_null">is_null</a><a href="#method.is_null-1">is_null</a><a href="#method.offset">offset</a><a href="#method.offset-1">offset</a><a href="#method.offset_from">offset_from</a><a href="#method.offset_from-1">offset_from</a><a href="#method.read">read</a><a href="#method.read-1">read</a><a href="#method.read_unaligned">read_unaligned</a><a href="#method.read_unaligned-1">read_unaligned</a><a href="#method.read_volatile">read_volatile</a><a href="#method.read_volatile-1">read_volatile</a><a href="#method.replace">replace</a><a href="#method.sub">sub</a><a href="#method.sub-1">sub</a><a href="#method.swap">swap</a><a href="#method.wrapping_add">wrapping_add</a><a href="#method.wrapping_add-1">wrapping_add</a><a href="#method.wrapping_offset">wrapping_offset</a><a href="#method.wrapping_offset-1">wrapping_offset</a><a href="#method.wrapping_offset_from">wrapping_offset_from</a><a href="#method.wrapping_offset_from-1">wrapping_offset_from</a><a href="#method.wrapping_sub">wrapping_sub</a><a href="#method.wrapping_sub-1">wrapping_sub</a><a href="#method.write">write</a><a href="#method.write_bytes">write_bytes</a><a href="#method.write_unaligned">write_unaligned</a><a href="#method.write_volatile">write_volatile</a></div><a class="sidebar-title" href="#implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Clone">Clone</a><a href="#impl-CoerceUnsized%3C*const%20U%3E">CoerceUnsized&lt;*const U&gt;</a><a href="#impl-CoerceUnsized%3C*mut%20U%3E">CoerceUnsized&lt;*mut U&gt;</a><a href="#impl-Copy">Copy</a><a href="#impl-Debug">Debug</a><a href="#impl-DispatchFromDyn%3C*const%20U%3E">DispatchFromDyn&lt;*const U&gt;</a><a href="#impl-DispatchFromDyn%3C*mut%20U%3E">DispatchFromDyn&lt;*mut U&gt;</a><a href="#impl-Eq">Eq</a><a href="#impl-Hash">Hash</a><a href="#impl-Ord">Ord</a><a href="#impl-PartialEq%3C*const%20T%3E">PartialEq&lt;*const T&gt;</a><a href="#impl-PartialEq%3C*mut%20T%3E">PartialEq&lt;*mut T&gt;</a><a href="#impl-PartialOrd%3C*const%20T%3E">PartialOrd&lt;*const T&gt;</a><a href="#impl-PartialOrd%3C*mut%20T%3E">PartialOrd&lt;*mut T&gt;</a><a href="#impl-Pointer">Pointer</a><a href="#impl-Send">!Send</a><a href="#impl-Sync">!Sync</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">UnwindSafe</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-RefUnwindSafe">RefUnwindSafe</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-ToOwned">ToOwned</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div></div><p class='location'><a href='index.html'>std</a></p><script>window.sidebarCurrent = {name: 'pointer', ty: 'primitive', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush1.39.0.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme1.39.0.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel1.39.0.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span></span><span class='in-band'>Primitive Type <a class="primitive" href=''>pointer</a></span></h1><div class='docblock'><p>Raw, unsafe pointers, <code>*const T</code>, and <code>*mut T</code>.</p>
<p><em><a href="ptr/index.html">See also the <code>std::ptr</code> module</a>.</em></p>
<p>Working with raw pointers in Rust is uncommon, typically limited to a few patterns.
Raw pointers can be unaligned or <a href="../std/ptr/fn.null.html"><code>null</code></a>. However, when a raw pointer is
dereferenced (using the <code>*</code> operator), it must be non-null and aligned.</p>
<p>Storing through a raw pointer using <code>*ptr = data</code> calls <code>drop</code> on the old value, so
<a href="../std/ptr/fn.write.html"><code>write</code></a> must be used if the type has drop glue and memory is not already
initialized - otherwise <code>drop</code> would be called on the uninitialized memory.</p>
<p>Use the <a href="../std/ptr/fn.null.html"><code>null</code></a> and <a href="../std/ptr/fn.null_mut.html"><code>null_mut</code></a> functions to create null pointers, and the
<a href="../std/primitive.pointer.html#method.is_null"><code>is_null</code></a> method of the <code>*const T</code> and <code>*mut T</code> types to check for null.
The <code>*const T</code> and <code>*mut T</code> types also define the <a href="../std/primitive.pointer.html#method.offset"><code>offset</code></a> method, for
pointer math.</p>
<h1 id="common-ways-to-create-raw-pointers" class="section-header"><a href="#common-ways-to-create-raw-pointers">Common ways to create raw pointers</a></h1><h2 id="1-coerce-a-reference-t-or-mutable-reference-mut-t" class="section-header"><a href="#1-coerce-a-reference-t-or-mutable-reference-mut-t">1. Coerce a reference (<code>&amp;T</code>) or mutable reference (<code>&amp;mut T</code>).</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">my_num</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="number">10</span>;
<span class="kw">let</span> <span class="ident">my_num_ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">my_num</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">my_speed</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="number">88</span>;
<span class="kw">let</span> <span class="ident">my_speed_ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">my_speed</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20my_num%3A%20i32%20%3D%2010%3B%0Alet%20my_num_ptr%3A%20*const%20i32%20%3D%20%26my_num%3B%0Alet%20mut%20my_speed%3A%20i32%20%3D%2088%3B%0Alet%20my_speed_ptr%3A%20*mut%20i32%20%3D%20%26mut%20my_speed%3B%0A%7D&amp;edition=2018">Run</a></pre></div>
<p>To get a pointer to a boxed value, dereference the box:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">my_num</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">new</span>(<span class="number">10</span>);
<span class="kw">let</span> <span class="ident">my_num_ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">my_num</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">my_speed</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">new</span>(<span class="number">88</span>);
<span class="kw">let</span> <span class="ident">my_speed_ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="kw-2">*</span><span class="ident">my_speed</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20my_num%3A%20Box%3Ci32%3E%20%3D%20Box%3A%3Anew(10)%3B%0Alet%20my_num_ptr%3A%20*const%20i32%20%3D%20%26*my_num%3B%0Alet%20mut%20my_speed%3A%20Box%3Ci32%3E%20%3D%20Box%3A%3Anew(88)%3B%0Alet%20my_speed_ptr%3A%20*mut%20i32%20%3D%20%26mut%20*my_speed%3B%0A%7D&amp;edition=2018">Run</a></pre></div>
<p>This does not take ownership of the original allocation
and requires no resource management later,
but you must not use the pointer after its lifetime.</p>
<h2 id="2-consume-a-box-boxt" class="section-header"><a href="#2-consume-a-box-boxt">2. Consume a box (<code>Box&lt;T&gt;</code>).</a></h2>
<p>The <a href="../std/boxed/struct.Box.html#method.into_raw"><code>into_raw</code></a> function consumes a box and returns
the raw pointer. It doesn't destroy <code>T</code> or deallocate any memory.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">my_speed</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">new</span>(<span class="number">88</span>);
<span class="kw">let</span> <span class="ident">my_speed</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">into_raw</span>(<span class="ident">my_speed</span>);

<span class="comment">// By taking ownership of the original `Box&lt;T&gt;` though</span>
<span class="comment">// we are obligated to put it together later to be destroyed.</span>
<span class="kw">unsafe</span> {
    <span class="ident">drop</span>(<span class="ident">Box</span>::<span class="ident">from_raw</span>(<span class="ident">my_speed</span>));
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20my_speed%3A%20Box%3Ci32%3E%20%3D%20Box%3A%3Anew(88)%3B%0Alet%20my_speed%3A%20*mut%20i32%20%3D%20Box%3A%3Ainto_raw(my_speed)%3B%0A%0A%2F%2F%20By%20taking%20ownership%20of%20the%20original%20%60Box%3CT%3E%60%20though%0A%2F%2F%20we%20are%20obligated%20to%20put%20it%20together%20later%20to%20be%20destroyed.%0Aunsafe%20%7B%0A%20%20%20%20drop(Box%3A%3Afrom_raw(my_speed))%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></pre></div>
<p>Note that here the call to <a href="../std/mem/fn.drop.html"><code>drop</code></a> is for clarity - it indicates
that we are done with the given value and it should be destroyed.</p>
<h2 id="3-get-it-from-c" class="section-header"><a href="#3-get-it-from-c">3. Get it from C.</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">libc</span>;

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">mem</span>;

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="ident">my_num</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span> <span class="op">=</span> <span class="ident">libc</span>::<span class="ident">malloc</span>(<span class="ident">mem</span>::<span class="ident">size_of</span>::<span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>()) <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span>;
        <span class="kw">if</span> <span class="ident">my_num</span>.<span class="ident">is_null</span>() {
            <span class="macro">panic</span><span class="macro">!</span>(<span class="string">&quot;failed to allocate memory&quot;</span>);
        }
        <span class="ident">libc</span>::<span class="ident">free</span>(<span class="ident">my_num</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">libc</span>::<span class="ident">c_void</span>);
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(rustc_private)%5D%0Aextern%20crate%20libc%3B%0A%0Ause%20std%3A%3Amem%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20let%20my_num%3A%20*mut%20i32%20%3D%20libc%3A%3Amalloc(mem%3A%3Asize_of%3A%3A%3Ci32%3E())%20as%20*mut%20i32%3B%0A%20%20%20%20%20%20%20%20if%20my_num.is_null()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20panic!(%22failed%20to%20allocate%20memory%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20libc%3A%3Afree(my_num%20as%20*mut%20libc%3A%3Ac_void)%3B%0A%20%20%20%20%7D%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></pre></div>
<p>Usually you wouldn't literally use <code>malloc</code> and <code>free</code> from Rust,
but C APIs hand out a lot of pointers generally, so are a common source
of raw pointers in Rust.</p>
</div><h2 id='methods' class='small-section-header'>Methods<a href='#methods' class='anchor'></a></h2><h3 id='impl' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl' class='anchor'></a><a class='srclink' href='../src/core/ptr/mod.rs.html#1020-1700' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.is_null' class="method"><code id='is_null.v'>pub fn <a href='#method.is_null' class='fnname'>is_null</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></code><a class='srclink' href='../src/core/ptr/mod.rs.html#1039-1043' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns <code>true</code> if the pointer is null.</p>
<p>Note that unsized types have many possible null pointers, as only the
raw data pointer is considered, not their length, vtable, etc.
Therefore, two pointers that are null may still not compare equal to
each other.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;Follow the rabbit&quot;</span>;
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_ptr</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">ptr</span>.<span class="ident">is_null</span>());<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%3A%20%26str%20%3D%20%22Follow%20the%20rabbit%22%3B%0Alet%20ptr%3A%20*const%20u8%20%3D%20s.as_ptr()%3B%0Aassert!(!ptr.is_null())%3B%0A%7D&amp;edition=2018">Run</a></pre></div>
</div><h4 id='method.cast' class="method"><code id='cast.v'>pub const fn <a href='#method.cast' class='fnname'>cast</a>&lt;U&gt;(self) -&gt; <a class="primitive" href="primitive.pointer.html">*const U</a></code><span class='since' title='Stable since Rust version 1.38.0'>1.38.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#1048-1050' title='goto source code'>[src]</a></h4><div class='docblock'><p>Casts to a pointer of another type.</p>
</div><h4 id='method.as_ref' class="method"><code id='as_ref.v'>pub unsafe fn <a href='#method.as_ref' class='fnname'>as_ref</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="../std/option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;'a </a>T&gt;</code><span class='since' title='Stable since Rust version 1.9.0'>1.9.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#1104-1110' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns <code>None</code> if the pointer is null, or else returns a reference to
the value wrapped in <code>Some</code>.</p>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p>While this method and its mutable counterpart are useful for
null-safety, it is important to note that this is still an unsafe
operation because the returned value could be pointing to invalid
memory.</p>
<p>When calling this method, you have to ensure that if the pointer is
non-NULL, then it is properly aligned, dereferencable (for the whole
size of <code>T</code>) and points to an initialized instance of <code>T</code>. This applies
even if the result of this method is unused!
(The part about being initialized is not yet fully decided, but until
it is, the only safe approach is to ensure that they are indeed initialized.)</p>
<p>Additionally, the lifetime <code>'a</code> returned is arbitrarily chosen and does
not necessarily reflect the actual lifetime of the data. It is up to the
caller to ensure that for the duration of this lifetime, the memory this
pointer points to does not get written to outside of <code>UnsafeCell&lt;U&gt;</code>.</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="number">10u8</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>;

<span class="kw">unsafe</span> {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">val_back</span>) <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">as_ref</span>() {
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;We got back the value: {}!&quot;</span>, <span class="ident">val_back</span>);
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20ptr%3A%20*const%20u8%20%3D%20%2610u8%20as%20*const%20u8%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20if%20let%20Some(val_back)%20%3D%20ptr.as_ref()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22We%20got%20back%20the%20value%3A%20%7B%7D!%22%2C%20val_back)%3B%0A%20%20%20%20%7D%0A%7D%0A%7D&amp;edition=2018">Run</a></pre></div>
<h1 id="null-unchecked-version" class="section-header"><a href="#null-unchecked-version">Null-unchecked version</a></h1>
<p>If you are sure the pointer can never be null and are looking for some kind of
<code>as_ref_unchecked</code> that returns the <code>&amp;T</code> instead of <code>Option&lt;&amp;T&gt;</code>, know that you can
dereference the pointer directly.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="number">10u8</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>;

<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">val_back</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">ptr</span>;
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;We got back the value: {}!&quot;</span>, <span class="ident">val_back</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20ptr%3A%20*const%20u8%20%3D%20%2610u8%20as%20*const%20u8%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20let%20val_back%20%3D%20%26*ptr%3B%0A%20%20%20%20println!(%22We%20got%20back%20the%20value%3A%20%7B%7D!%22%2C%20val_back)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></pre></div>
</div><h4 id='method.offset' class="method"><code id='offset.v'>pub unsafe fn <a href='#method.offset' class='fnname'>offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></code><a class='srclink' href='../src/core/ptr/mod.rs.html#1165-1167' title='goto source code'>[src]</a></h4><div class='docblock'><p>Calculates the offset from a pointer.</p>
<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-1" class="section-header"><a href="#safety-1">Safety</a></h1>
<p>If any of the following conditions are violated, the result is Undefined
Behavior:</p>
<ul>
<li>
<p>Both the starting and resulting pointer must be either in bounds or one
byte past the end of the same allocated object. Note that in Rust,
every (stack-allocated) variable is considered a separate allocated object.</p>
</li>
<li>
<p>The computed offset, <strong>in bytes</strong>, cannot overflow an <code>isize</code>.</p>
</li>
<li>
<p>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address
space. That is, the infinite-precision sum, <strong>in bytes</strong> must fit in a usize.</p>
</li>
</ul>
<p>The compiler and standard library generally tries to ensure allocations
never reach a size where an offset is a concern. For instance, <code>Vec</code>
and <code>Box</code> ensure they never allocate more than <code>isize::MAX</code> bytes, so
<code>vec.as_ptr().add(vec.len())</code> is always safe.</p>
<p>Most platforms fundamentally can't even construct such an allocation.
For instance, no known 64-bit platform can ever serve a request
for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.
However, some 32-bit and 16-bit platforms may successfully serve a request for
more than <code>isize::MAX</code> bytes with things like Physical Address
Extension. As such, memory acquired directly from allocators or memory
mapped files <em>may</em> be too large to handle with this function.</p>
<p>Consider using <a href="#method.wrapping_offset"><code>wrapping_offset</code></a> instead if these constraints are
difficult to satisfy. The only advantage of this method is that it
enables more aggressive compiler optimizations.</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;123&quot;</span>;
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_ptr</span>();

<span class="kw">unsafe</span> {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">offset</span>(<span class="number">1</span>) <span class="kw">as</span> <span class="ident">char</span>);
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">offset</span>(<span class="number">2</span>) <span class="kw">as</span> <span class="ident">char</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%3A%20%26str%20%3D%20%22123%22%3B%0Alet%20ptr%3A%20*const%20u8%20%3D%20s.as_ptr()%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.offset(1)%20as%20char)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.offset(2)%20as%20char)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></pre></div>
</div><h4 id='method.wrapping_offset' class="method"><code id='wrapping_offset.v'>pub fn <a href='#method.wrapping_offset' class='fnname'>wrapping_offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></code><span class='since' title='Stable since Rust version 1.16.0'>1.16.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#1220-1224' title='goto source code'>[src]</a></h4><div class='docblock'><p>Calculates the offset from a pointer using wrapping arithmetic.</p>
<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-2" class="section-header"><a href="#safety-2">Safety</a></h1>
<p>The resulting pointer does not need to be in bounds, but it is
potentially hazardous to dereference (which requires <code>unsafe</code>).</p>
<p>In particular, the resulting pointer remains attached to the same allocated
object that <code>self</code> points to. It may <em>not</em> be used to access a
different allocated object. Note that in Rust,
every (stack-allocated) variable is considered a separate allocated object.</p>
<p>In other words, <code>x.wrapping_offset(y.wrapping_offset_from(x))</code> is
<em>not</em> the same as <code>y</code>, and dereferencing it is undefined behavior
unless <code>x</code> and <code>y</code> point into the same allocated object.</p>
<p>Compared to <a href="#method.offset"><code>offset</code></a>, this method basically delays the requirement of staying
within the same allocated object: <a href="#method.offset"><code>offset</code></a> is immediate Undefined Behavior when
crossing object boundaries; <code>wrapping_offset</code> produces a pointer but still leads
to Undefined Behavior if that pointer is dereferenced. <a href="#method.offset"><code>offset</code></a> can be optimized
better and is thus preferrable in performance-sensitive code.</p>
<p>If you need to cross object boundaries, cast the pointer to an integer and
do the arithmetic there.</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Iterate using a raw pointer in increments of two elements</span>
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">as_ptr</span>();
<span class="kw">let</span> <span class="ident">step</span> <span class="op">=</span> <span class="number">2</span>;
<span class="kw">let</span> <span class="ident">end_rounded_up</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_offset</span>(<span class="number">6</span>);

<span class="comment">// This loop prints &quot;1, 3, 5, &quot;</span>
<span class="kw">while</span> <span class="ident">ptr</span> <span class="op">!</span><span class="op">=</span> <span class="ident">end_rounded_up</span> {
    <span class="kw">unsafe</span> {
        <span class="macro">print</span><span class="macro">!</span>(<span class="string">&quot;{}, &quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>);
    }
    <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_offset</span>(<span class="ident">step</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%2F%2F%20Iterate%20using%20a%20raw%20pointer%20in%20increments%20of%20two%20elements%0Afn%20main()%20%7B%0Alet%20data%20%3D%20%5B1u8%2C%202%2C%203%2C%204%2C%205%5D%3B%0Alet%20mut%20ptr%3A%20*const%20u8%20%3D%20data.as_ptr()%3B%0Alet%20step%20%3D%202%3B%0Alet%20end_rounded_up%20%3D%20ptr.wrapping_offset(6)%3B%0A%0A%2F%2F%20This%20loop%20prints%20%221%2C%203%2C%205%2C%20%22%0Awhile%20ptr%20!%3D%20end_rounded_up%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20print!(%22%7B%7D%2C%20%22%2C%20*ptr)%3B%0A%20%20%20%20%7D%0A%20%20%20%20ptr%20%3D%20ptr.wrapping_offset(step)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></pre></div>
</div><h4 id='method.offset_from' class="method"><code id='offset_from.v'>pub unsafe fn <a href='#method.offset_from' class='fnname'>offset_from</a>(self, origin: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.isize.html">isize</a></code><a class='srclink' href='../src/core/ptr/mod.rs.html#1290-1299' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>ptr_offset_from</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/41079">#41079</a>)</div></div><div class='docblock'><p>Calculates the distance between two pointers. The returned value is in
units of T: the distance in bytes is divided by <code>mem::size_of::&lt;T&gt;()</code>.</p>
<p>This function is the inverse of <a href="#method.offset"><code>offset</code></a>.</p>
<h1 id="safety-3" class="section-header"><a href="#safety-3">Safety</a></h1>
<p>If any of the following conditions are violated, the result is Undefined
Behavior:</p>
<ul>
<li>
<p>Both the starting and other pointer must be either in bounds or one
byte past the end of the same allocated object. Note that in Rust,
every (stack-allocated) variable is considered a separate allocated object.</p>
</li>
<li>
<p>The distance between the pointers, <strong>in bytes</strong>, cannot overflow an <code>isize</code>.</p>
</li>
<li>
<p>The distance between the pointers, in bytes, must be an exact multiple
of the size of <code>T</code>.</p>
</li>
<li>
<p>The distance being in bounds cannot rely on &quot;wrapping around&quot; the address space.</p>
</li>
</ul>
<p>The compiler and standard library generally try to ensure allocations
never reach a size where an offset is a concern. For instance, <code>Vec</code>
and <code>Box</code> ensure they never allocate more than <code>isize::MAX</code> bytes, so
<code>ptr_into_vec.offset_from(vec.as_ptr())</code> is always safe.</p>
<p>Most platforms fundamentally can't even construct such an allocation.
For instance, no known 64-bit platform can ever serve a request
for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.
However, some 32-bit and 16-bit platforms may successfully serve a request for
more than <code>isize::MAX</code> bytes with things like Physical Address
Extension. As such, memory acquired directly from allocators or memory
mapped files <em>may</em> be too large to handle with this function.</p>
<p>Consider using <a href="#method.wrapping_offset_from"><code>wrapping_offset_from</code></a> instead if these constraints are
difficult to satisfy. The only advantage of this method is that it
enables more aggressive compiler optimizations.</p>
<h1 id="panics" class="section-header"><a href="#panics">Panics</a></h1>
<p>This function panics if <code>T</code> is a Zero-Sized Type (&quot;ZST&quot;).</p>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">ptr_offset_from</span>)]</span>

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> [<span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let</span> <span class="ident">ptr1</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">a</span>[<span class="number">1</span>];
<span class="kw">let</span> <span class="ident">ptr2</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">a</span>[<span class="number">3</span>];
<span class="kw">unsafe</span> {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ptr2</span>.<span class="ident">offset_from</span>(<span class="ident">ptr1</span>), <span class="number">2</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ptr1</span>.<span class="ident">offset_from</span>(<span class="ident">ptr2</span>), <span class="op">-</span><span class="number">2</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ptr1</span>.<span class="ident">offset</span>(<span class="number">2</span>), <span class="ident">ptr2</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ptr2</span>.<span class="ident">offset</span>(<span class="op">-</span><span class="number">2</span>), <span class="ident">ptr1</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_offset_from)%5D%0A%0Afn%20main()%20%7B%0Alet%20a%20%3D%20%5B0%3B%205%5D%3B%0Alet%20ptr1%3A%20*const%20i32%20%3D%20%26a%5B1%5D%3B%0Alet%20ptr2%3A%20*const%20i32%20%3D%20%26a%5B3%5D%3B%0Aunsafe%20%7B%0A%20%20%20%20assert_eq!(ptr2.offset_from(ptr1)%2C%202)%3B%0A%20%20%20%20assert_eq!(ptr1.offset_from(ptr2)%2C%20-2)%3B%0A%20%20%20%20assert_eq!(ptr1.offset(2)%2C%20ptr2)%3B%0A%20%20%20%20assert_eq!(ptr2.offset(-2)%2C%20ptr1)%3B%0A%7D%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></pre></div>
</div><h4 id='method.wrapping_offset_from' class="method"><code id='wrapping_offset_from.v'>pub fn <a href='#method.wrapping_offset_from' class='fnname'>wrapping_offset_from</a>(self, origin: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.isize.html">isize</a></code><a class='srclink' href='../src/core/ptr/mod.rs.html#1337-1343' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>ptr_wrapping_offset_from</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/41079">#41079</a>)</div></div><div class='docblock'><p>Calculates the distance between two pointers. The returned value is in
units of T: the distance in bytes is divided by <code>mem::size_of::&lt;T&gt;()</code>.</p>
<p>If the address different between the two pointers is not a multiple of
<code>mem::size_of::&lt;T&gt;()</code> then the result of the division is rounded towards
zero.</p>
<p>Though this method is safe for any two pointers, note that its result
will be mostly useless if the two pointers aren't into the same allocated
object, for example if they point to two different local variables.</p>
<h1 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h1>
<p>This function panics if <code>T</code> is a zero-sized type.</p>
<h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">ptr_wrapping_offset_from</span>)]</span>

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> [<span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let</span> <span class="ident">ptr1</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">a</span>[<span class="number">1</span>];
<span class="kw">let</span> <span class="ident">ptr2</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">a</span>[<span class="number">3</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ptr2</span>.<span class="ident">wrapping_offset_from</span>(<span class="ident">ptr1</span>), <span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ptr1</span>.<span class="ident">wrapping_offset_from</span>(<span class="ident">ptr2</span>), <span class="op">-</span><span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ptr1</span>.<span class="ident">wrapping_offset</span>(<span class="number">2</span>), <span class="ident">ptr2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ptr2</span>.<span class="ident">wrapping_offset</span>(<span class="op">-</span><span class="number">2</span>), <span class="ident">ptr1</span>);

<span class="kw">let</span> <span class="ident">ptr1</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">i32</span> <span class="op">=</span> <span class="number">3</span> <span class="kw">as</span> <span class="kw">_</span>;
<span class="kw">let</span> <span class="ident">ptr2</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">i32</span> <span class="op">=</span> <span class="number">13</span> <span class="kw">as</span> <span class="kw">_</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ptr2</span>.<span class="ident">wrapping_offset_from</span>(<span class="ident">ptr1</span>), <span class="number">2</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_wrapping_offset_from)%5D%0A%0Afn%20main()%20%7B%0Alet%20a%20%3D%20%5B0%3B%205%5D%3B%0Alet%20ptr1%3A%20*const%20i32%20%3D%20%26a%5B1%5D%3B%0Alet%20ptr2%3A%20*const%20i32%20%3D%20%26a%5B3%5D%3B%0Aassert_eq!(ptr2.wrapping_offset_from(ptr1)%2C%202)%3B%0Aassert_eq!(ptr1.wrapping_offset_from(ptr2)%2C%20-2)%3B%0Aassert_eq!(ptr1.wrapping_offset(2)%2C%20ptr2)%3B%0Aassert_eq!(ptr2.wrapping_offset(-2)%2C%20ptr1)%3B%0A%0Alet%20ptr1%3A%20*const%20i32%20%3D%203%20as%20_%3B%0Alet%20ptr2%3A%20*const%20i32%20%3D%2013%20as%20_%3B%0Aassert_eq!(ptr2.wrapping_offset_from(ptr1)%2C%202)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></pre></div>
</div><h4 id='method.add' class="method"><code id='add.v'>pub unsafe fn <a href='#method.add' class='fnname'>add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#1398-1402' title='goto source code'>[src]</a></h4><div class='docblock'><p>Calculates the offset from a pointer (convenience for <code>.offset(count as isize)</code>).</p>
<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-4" class="section-header"><a href="#safety-4">Safety</a></h1>
<p>If any of the following conditions are violated, the result is Undefined
Behavior:</p>
<ul>
<li>
<p>Both the starting and resulting pointer must be either in bounds or one
byte past the end of the same allocated object. Note that in Rust,
every (stack-allocated) variable is considered a separate allocated object.</p>
</li>
<li>
<p>The computed offset, <strong>in bytes</strong>, cannot overflow an <code>isize</code>.</p>
</li>
<li>
<p>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address
space. That is, the infinite-precision sum must fit in a <code>usize</code>.</p>
</li>
</ul>
<p>The compiler and standard library generally tries to ensure allocations
never reach a size where an offset is a concern. For instance, <code>Vec</code>
and <code>Box</code> ensure they never allocate more than <code>isize::MAX</code> bytes, so
<code>vec.as_ptr().add(vec.len())</code> is always safe.</p>
<p>Most platforms fundamentally can't even construct such an allocation.
For instance, no known 64-bit platform can ever serve a request
for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.
However, some 32-bit and 16-bit platforms may successfully serve a request for
more than <code>isize::MAX</code> bytes with things like Physical Address
Extension. As such, memory acquired directly from allocators or memory
mapped files <em>may</em> be too large to handle with this function.</p>
<p>Consider using <a href="#method.wrapping_add"><code>wrapping_add</code></a> instead if these constraints are
difficult to satisfy. The only advantage of this method is that it
enables more aggressive compiler optimizations.</p>
<h1 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;123&quot;</span>;
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_ptr</span>();

<span class="kw">unsafe</span> {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">add</span>(<span class="number">1</span>) <span class="kw">as</span> <span class="ident">char</span>);
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">add</span>(<span class="number">2</span>) <span class="kw">as</span> <span class="ident">char</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%3A%20%26str%20%3D%20%22123%22%3B%0Alet%20ptr%3A%20*const%20u8%20%3D%20s.as_ptr()%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.add(1)%20as%20char)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.add(2)%20as%20char)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></pre></div>
</div><h4 id='method.sub' class="method"><code id='sub.v'>pub unsafe fn <a href='#method.sub' class='fnname'>sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#1458-1462' title='goto source code'>[src]</a></h4><div class='docblock'><p>Calculates the offset from a pointer (convenience for
<code>.offset((count as isize).wrapping_neg())</code>).</p>
<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-5" class="section-header"><a href="#safety-5">Safety</a></h1>
<p>If any of the following conditions are violated, the result is Undefined
Behavior:</p>
<ul>
<li>
<p>Both the starting and resulting pointer must be either in bounds or one
byte past the end of the same allocated object. Note that in Rust,
every (stack-allocated) variable is considered a separate allocated object.</p>
</li>
<li>
<p>The computed offset cannot exceed <code>isize::MAX</code> <strong>bytes</strong>.</p>
</li>
<li>
<p>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address
space. That is, the infinite-precision sum must fit in a usize.</p>
</li>
</ul>
<p>The compiler and standard library generally tries to ensure allocations
never reach a size where an offset is a concern. For instance, <code>Vec</code>
and <code>Box</code> ensure they never allocate more than <code>isize::MAX</code> bytes, so
<code>vec.as_ptr().add(vec.len()).sub(vec.len())</code> is always safe.</p>
<p>Most platforms fundamentally can't even construct such an allocation.
For instance, no known 64-bit platform can ever serve a request
for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.
However, some 32-bit and 16-bit platforms may successfully serve a request for
more than <code>isize::MAX</code> bytes with things like Physical Address
Extension. As such, memory acquired directly from allocators or memory
mapped files <em>may</em> be too large to handle with this function.</p>
<p>Consider using <a href="#method.wrapping_sub"><code>wrapping_sub</code></a> instead if these constraints are
difficult to satisfy. The only advantage of this method is that it
enables more aggressive compiler optimizations.</p>
<h1 id="examples-7" class="section-header"><a href="#examples-7">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;123&quot;</span>;

<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">end</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_ptr</span>().<span class="ident">add</span>(<span class="number">3</span>);
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">end</span>.<span class="ident">sub</span>(<span class="number">1</span>) <span class="kw">as</span> <span class="ident">char</span>);
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">end</span>.<span class="ident">sub</span>(<span class="number">2</span>) <span class="kw">as</span> <span class="ident">char</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%3A%20%26str%20%3D%20%22123%22%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20let%20end%3A%20*const%20u8%20%3D%20s.as_ptr().add(3)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*end.sub(1)%20as%20char)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*end.sub(2)%20as%20char)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></pre></div>
</div><h4 id='method.wrapping_add' class="method"><code id='wrapping_add.v'>pub fn <a href='#method.wrapping_add' class='fnname'>wrapping_add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#1512-1516' title='goto source code'>[src]</a></h4><div class='docblock'><p>Calculates the offset from a pointer using wrapping arithmetic.
(convenience for <code>.wrapping_offset(count as isize)</code>)</p>
<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-6" class="section-header"><a href="#safety-6">Safety</a></h1>
<p>The resulting pointer does not need to be in bounds, but it is
potentially hazardous to dereference (which requires <code>unsafe</code>).</p>
<p>In particular, the resulting pointer remains attached to the same allocated
object that <code>self</code> points to. It may <em>not</em> be used to access a
different allocated object. Note that in Rust,
every (stack-allocated) variable is considered a separate allocated object.</p>
<p>Compared to <a href="#method.add"><code>add</code></a>, this method basically delays the requirement of staying
within the same allocated object: <a href="#method.add"><code>add</code></a> is immediate Undefined Behavior when
crossing object boundaries; <code>wrapping_add</code> produces a pointer but still leads
to Undefined Behavior if that pointer is dereferenced. <a href="#method.add"><code>add</code></a> can be optimized
better and is thus preferrable in performance-sensitive code.</p>
<p>If you need to cross object boundaries, cast the pointer to an integer and
do the arithmetic there.</p>
<h1 id="examples-8" class="section-header"><a href="#examples-8">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Iterate using a raw pointer in increments of two elements</span>
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">as_ptr</span>();
<span class="kw">let</span> <span class="ident">step</span> <span class="op">=</span> <span class="number">2</span>;
<span class="kw">let</span> <span class="ident">end_rounded_up</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_add</span>(<span class="number">6</span>);

<span class="comment">// This loop prints &quot;1, 3, 5, &quot;</span>
<span class="kw">while</span> <span class="ident">ptr</span> <span class="op">!</span><span class="op">=</span> <span class="ident">end_rounded_up</span> {
    <span class="kw">unsafe</span> {
        <span class="macro">print</span><span class="macro">!</span>(<span class="string">&quot;{}, &quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>);
    }
    <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_add</span>(<span class="ident">step</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%2F%2F%20Iterate%20using%20a%20raw%20pointer%20in%20increments%20of%20two%20elements%0Afn%20main()%20%7B%0Alet%20data%20%3D%20%5B1u8%2C%202%2C%203%2C%204%2C%205%5D%3B%0Alet%20mut%20ptr%3A%20*const%20u8%20%3D%20data.as_ptr()%3B%0Alet%20step%20%3D%202%3B%0Alet%20end_rounded_up%20%3D%20ptr.wrapping_add(6)%3B%0A%0A%2F%2F%20This%20loop%20prints%20%221%2C%203%2C%205%2C%20%22%0Awhile%20ptr%20!%3D%20end_rounded_up%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20print!(%22%7B%7D%2C%20%22%2C%20*ptr)%3B%0A%20%20%20%20%7D%0A%20%20%20%20ptr%20%3D%20ptr.wrapping_add(step)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></pre></div>
</div><h4 id='method.wrapping_sub' class="method"><code id='wrapping_sub.v'>pub fn <a href='#method.wrapping_sub' class='fnname'>wrapping_sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#1566-1570' title='goto source code'>[src]</a></h4><div class='docblock'><p>Calculates the offset from a pointer using wrapping arithmetic.
(convenience for <code>.wrapping_offset((count as isize).wrapping_sub())</code>)</p>
<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-7" class="section-header"><a href="#safety-7">Safety</a></h1>
<p>The resulting pointer does not need to be in bounds, but it is
potentially hazardous to dereference (which requires <code>unsafe</code>).</p>
<p>In particular, the resulting pointer remains attached to the same allocated
object that <code>self</code> points to. It may <em>not</em> be used to access a
different allocated object. Note that in Rust,
every (stack-allocated) variable is considered a separate allocated object.</p>
<p>Compared to <a href="#method.sub"><code>sub</code></a>, this method basically delays the requirement of staying
within the same allocated object: <a href="#method.sub"><code>sub</code></a> is immediate Undefined Behavior when
crossing object boundaries; <code>wrapping_sub</code> produces a pointer but still leads
to Undefined Behavior if that pointer is dereferenced. <a href="#method.sub"><code>sub</code></a> can be optimized
better and is thus preferrable in performance-sensitive code.</p>
<p>If you need to cross object boundaries, cast the pointer to an integer and
do the arithmetic there.</p>
<h1 id="examples-9" class="section-header"><a href="#examples-9">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Iterate using a raw pointer in increments of two elements (backwards)</span>
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">as_ptr</span>();
<span class="kw">let</span> <span class="ident">start_rounded_down</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_sub</span>(<span class="number">2</span>);
<span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_add</span>(<span class="number">4</span>);
<span class="kw">let</span> <span class="ident">step</span> <span class="op">=</span> <span class="number">2</span>;
<span class="comment">// This loop prints &quot;5, 3, 1, &quot;</span>
<span class="kw">while</span> <span class="ident">ptr</span> <span class="op">!</span><span class="op">=</span> <span class="ident">start_rounded_down</span> {
    <span class="kw">unsafe</span> {
        <span class="macro">print</span><span class="macro">!</span>(<span class="string">&quot;{}, &quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>);
    }
    <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_sub</span>(<span class="ident">step</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%2F%2F%20Iterate%20using%20a%20raw%20pointer%20in%20increments%20of%20two%20elements%20(backwards)%0Afn%20main()%20%7B%0Alet%20data%20%3D%20%5B1u8%2C%202%2C%203%2C%204%2C%205%5D%3B%0Alet%20mut%20ptr%3A%20*const%20u8%20%3D%20data.as_ptr()%3B%0Alet%20start_rounded_down%20%3D%20ptr.wrapping_sub(2)%3B%0Aptr%20%3D%20ptr.wrapping_add(4)%3B%0Alet%20step%20%3D%202%3B%0A%2F%2F%20This%20loop%20prints%20%225%2C%203%2C%201%2C%20%22%0Awhile%20ptr%20!%3D%20start_rounded_down%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20print!(%22%7B%7D%2C%20%22%2C%20*ptr)%3B%0A%20%20%20%20%7D%0A%20%20%20%20ptr%20%3D%20ptr.wrapping_sub(step)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></pre></div>
</div><h4 id='method.read' class="method"><code id='read.v'>pub unsafe fn <a href='#method.read' class='fnname'>read</a>(self) -&gt; T</code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#1580-1584' title='goto source code'>[src]</a></h4><div class='docblock'><p>Reads the value from <code>self</code> without moving it. This leaves the
memory in <code>self</code> unchanged.</p>
<p>See <a href="./ptr/fn.read.html"><code>ptr::read</code></a> for safety concerns and examples.</p>
</div><h4 id='method.read_volatile' class="method"><code id='read_volatile.v'>pub unsafe fn <a href='#method.read_volatile' class='fnname'>read_volatile</a>(self) -&gt; T</code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#1598-1602' title='goto source code'>[src]</a></h4><div class='docblock'><p>Performs a volatile read of the value from <code>self</code> without moving it. This
leaves the memory in <code>self</code> unchanged.</p>
<p>Volatile operations are intended to act on I/O memory, and are guaranteed
to not be elided or reordered by the compiler across other volatile
operations.</p>
<p>See <a href="./ptr/fn.read_volatile.html"><code>ptr::read_volatile</code></a> for safety concerns and examples.</p>
</div><h4 id='method.read_unaligned' class="method"><code id='read_unaligned.v'>pub unsafe fn <a href='#method.read_unaligned' class='fnname'>read_unaligned</a>(self) -&gt; T</code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#1614-1618' title='goto source code'>[src]</a></h4><div class='docblock'><p>Reads the value from <code>self</code> without moving it. This leaves the
memory in <code>self</code> unchanged.</p>
<p>Unlike <code>read</code>, the pointer may be unaligned.</p>
<p>See <a href="./ptr/fn.read_unaligned.html"><code>ptr::read_unaligned</code></a> for safety concerns and examples.</p>
</div><h4 id='method.copy_to' class="method"><code id='copy_to.v'>pub unsafe fn <a href='#method.copy_to' class='fnname'>copy_to</a>(self, dest: <a class="primitive" href="primitive.pointer.html">*mut T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#1630-1634' title='goto source code'>[src]</a></h4><div class='docblock'><p>Copies <code>count * size_of&lt;T&gt;</code> bytes from <code>self</code> to <code>dest</code>. The source
and destination may overlap.</p>
<p>NOTE: this has the <em>same</em> argument order as <a href="./ptr/fn.copy.html"><code>ptr::copy</code></a>.</p>
<p>See <a href="./ptr/fn.copy.html"><code>ptr::copy</code></a> for safety concerns and examples.</p>
</div><h4 id='method.copy_to_nonoverlapping' class="method"><code id='copy_to_nonoverlapping.v'>pub unsafe fn <a href='#method.copy_to_nonoverlapping' class='fnname'>copy_to_nonoverlapping</a>(self, dest: <a class="primitive" href="primitive.pointer.html">*mut T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#1646-1650' title='goto source code'>[src]</a></h4><div class='docblock'><p>Copies <code>count * size_of&lt;T&gt;</code> bytes from <code>self</code> to <code>dest</code>. The source
and destination may <em>not</em> overlap.</p>
<p>NOTE: this has the <em>same</em> argument order as <a href="./ptr/fn.copy_nonoverlapping.html"><code>ptr::copy_nonoverlapping</code></a>.</p>
<p>See <a href="./ptr/fn.copy_nonoverlapping.html"><code>ptr::copy_nonoverlapping</code></a> for safety concerns and examples.</p>
</div><h4 id='method.align_offset' class="method"><code id='align_offset.v'>pub fn <a href='#method.align_offset' class='fnname'>align_offset</a>(self, align: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></code><span class='since' title='Stable since Rust version 1.36.0'>1.36.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#1692-1699' title='goto source code'>[src]</a></h4><div class='docblock'><p>Computes the offset that needs to be applied to the pointer in order to make it aligned to
<code>align</code>.</p>
<p>If it is not possible to align the pointer, the implementation returns
<code>usize::max_value()</code>. It is permissible for the implementation to <em>always</em>
return <code>usize::max_value()</code>. Only your algorithm's performance can depend
on getting a usable offset here, not its correctness.</p>
<p>The offset is expressed in number of <code>T</code> elements, and not bytes. The value returned can be
used with the <code>wrapping_add</code> method.</p>
<p>There are no guarantees whatsoever that offsetting the pointer will not overflow or go
beyond the allocation that the pointer points into. It is up to the caller to ensure that
the returned offset is correct in all terms other than alignment.</p>
<h1 id="panics-2" class="section-header"><a href="#panics-2">Panics</a></h1>
<p>The function panics if <code>align</code> is not a power-of-two.</p>
<h1 id="examples-10" class="section-header"><a href="#examples-10">Examples</a></h1>
<p>Accessing adjacent <code>u8</code> as <code>u16</code></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> [<span class="number">5u8</span>, <span class="number">6u8</span>, <span class="number">7u8</span>, <span class="number">8u8</span>, <span class="number">9u8</span>];
<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">x</span>[<span class="ident">n</span>] <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>;
<span class="kw">let</span> <span class="ident">offset</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">align_offset</span>(<span class="ident">align_of</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>());
<span class="kw">if</span> <span class="ident">offset</span> <span class="op">&lt;</span> <span class="ident">x</span>.<span class="ident">len</span>() <span class="op">-</span> <span class="ident">n</span> <span class="op">-</span> <span class="number">1</span> {
    <span class="kw">let</span> <span class="ident">u16_ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">add</span>(<span class="ident">offset</span>) <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u16</span>;
    <span class="macro">assert_ne</span><span class="macro">!</span>(<span class="kw-2">*</span><span class="ident">u16_ptr</span>, <span class="number">500</span>);
} <span class="kw">else</span> {
    <span class="comment">// while the pointer can be aligned via `offset`, it would point</span>
    <span class="comment">// outside the allocation</span>
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Afn%20foo(n%3A%20usize)%20%7B%0Ause%20std%3A%3Amem%3A%3Aalign_of%3B%0Aunsafe%20%7B%0Alet%20x%20%3D%20%5B5u8%2C%206u8%2C%207u8%2C%208u8%2C%209u8%5D%3B%0Alet%20ptr%20%3D%20%26x%5Bn%5D%20as%20*const%20u8%3B%0Alet%20offset%20%3D%20ptr.align_offset(align_of%3A%3A%3Cu16%3E())%3B%0Aif%20offset%20%3C%20x.len()%20-%20n%20-%201%20%7B%0A%20%20%20%20let%20u16_ptr%20%3D%20ptr.add(offset)%20as%20*const%20u16%3B%0A%20%20%20%20assert_ne!(*u16_ptr%2C%20500)%3B%0A%7D%20else%20%7B%0A%20%20%20%20%2F%2F%20while%20the%20pointer%20can%20be%20aligned%20via%20%60offset%60%2C%20it%20would%20point%0A%20%20%20%20%2F%2F%20outside%20the%20allocation%0A%7D%0A%7D%20%7D%0A%7D&amp;edition=2018">Run</a></pre></div>
</div></div><h3 id='impl-1' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-1' class='anchor'></a><a class='srclink' href='../src/core/ptr/mod.rs.html#1704-2550' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.is_null-1' class="method"><code id='is_null.v-1'>pub fn <a href='#method.is_null-1' class='fnname'>is_null</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></code><a class='srclink' href='../src/core/ptr/mod.rs.html#1723-1727' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns <code>true</code> if the pointer is null.</p>
<p>Note that unsized types have many possible null pointers, as only the
raw data pointer is considered, not their length, vtable, etc.
Therefore, two pointers that are null may still not compare equal to
each other.</p>
<h1 id="examples-11" class="section-header"><a href="#examples-11">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u32</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_mut_ptr</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">ptr</span>.<span class="ident">is_null</span>());<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20s%20%3D%20%5B1%2C%202%2C%203%5D%3B%0Alet%20ptr%3A%20*mut%20u32%20%3D%20s.as_mut_ptr()%3B%0Aassert!(!ptr.is_null())%3B%0A%7D&amp;edition=2018">Run</a></pre></div>
</div><h4 id='method.cast-1' class="method"><code id='cast.v-1'>pub const fn <a href='#method.cast-1' class='fnname'>cast</a>&lt;U&gt;(self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut U</a></code><span class='since' title='Stable since Rust version 1.38.0'>1.38.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#1732-1734' title='goto source code'>[src]</a></h4><div class='docblock'><p>Casts to a pointer of another type.</p>
</div><h4 id='method.as_ref-1' class="method"><code id='as_ref.v-1'>pub unsafe fn <a href='#method.as_ref-1' class='fnname'>as_ref</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="../std/option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;'a </a>T&gt;</code><span class='since' title='Stable since Rust version 1.9.0'>1.9.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#1788-1794' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns <code>None</code> if the pointer is null, or else returns a reference to
the value wrapped in <code>Some</code>.</p>
<h1 id="safety-8" class="section-header"><a href="#safety-8">Safety</a></h1>
<p>While this method and its mutable counterpart are useful for
null-safety, it is important to note that this is still an unsafe
operation because the returned value could be pointing to invalid
memory.</p>
<p>When calling this method, you have to ensure that if the pointer is
non-NULL, then it is properly aligned, dereferencable (for the whole
size of <code>T</code>) and points to an initialized instance of <code>T</code>. This applies
even if the result of this method is unused!
(The part about being initialized is not yet fully decided, but until
it is, the only safe approach is to ensure that they are indeed initialized.)</p>
<p>Additionally, the lifetime <code>'a</code> returned is arbitrarily chosen and does
not necessarily reflect the actual lifetime of the data. It is up to the
caller to ensure that for the duration of this lifetime, the memory this
pointer points to does not get written to outside of <code>UnsafeCell&lt;U&gt;</code>.</p>
<h1 id="examples-12" class="section-header"><a href="#examples-12">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="number">10u8</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>;

<span class="kw">unsafe</span> {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">val_back</span>) <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">as_ref</span>() {
        <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;We got back the value: {}!&quot;</span>, <span class="ident">val_back</span>);
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20ptr%3A%20*mut%20u8%20%3D%20%26mut%2010u8%20as%20*mut%20u8%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20if%20let%20Some(val_back)%20%3D%20ptr.as_ref()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22We%20got%20back%20the%20value%3A%20%7B%7D!%22%2C%20val_back)%3B%0A%20%20%20%20%7D%0A%7D%0A%7D&amp;edition=2018">Run</a></pre></div>
<h1 id="null-unchecked-version-1" class="section-header"><a href="#null-unchecked-version-1">Null-unchecked version</a></h1>
<p>If you are sure the pointer can never be null and are looking for some kind of
<code>as_ref_unchecked</code> that returns the <code>&amp;T</code> instead of <code>Option&lt;&amp;T&gt;</code>, know that you can
dereference the pointer directly.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="number">10u8</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>;

<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">val_back</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">ptr</span>;
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;We got back the value: {}!&quot;</span>, <span class="ident">val_back</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20ptr%3A%20*mut%20u8%20%3D%20%26mut%2010u8%20as%20*mut%20u8%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20let%20val_back%20%3D%20%26*ptr%3B%0A%20%20%20%20println!(%22We%20got%20back%20the%20value%3A%20%7B%7D!%22%2C%20val_back)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></pre></div>
</div><h4 id='method.offset-1' class="method"><code id='offset.v-1'>pub unsafe fn <a href='#method.offset-1' class='fnname'>offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></code><a class='srclink' href='../src/core/ptr/mod.rs.html#1849-1851' title='goto source code'>[src]</a></h4><div class='docblock'><p>Calculates the offset from a pointer.</p>
<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-9" class="section-header"><a href="#safety-9">Safety</a></h1>
<p>If any of the following conditions are violated, the result is Undefined
Behavior:</p>
<ul>
<li>
<p>Both the starting and resulting pointer must be either in bounds or one
byte past the end of the same allocated object. Note that in Rust,
every (stack-allocated) variable is considered a separate allocated object.</p>
</li>
<li>
<p>The computed offset, <strong>in bytes</strong>, cannot overflow an <code>isize</code>.</p>
</li>
<li>
<p>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address
space. That is, the infinite-precision sum, <strong>in bytes</strong> must fit in a usize.</p>
</li>
</ul>
<p>The compiler and standard library generally tries to ensure allocations
never reach a size where an offset is a concern. For instance, <code>Vec</code>
and <code>Box</code> ensure they never allocate more than <code>isize::MAX</code> bytes, so
<code>vec.as_ptr().add(vec.len())</code> is always safe.</p>
<p>Most platforms fundamentally can't even construct such an allocation.
For instance, no known 64-bit platform can ever serve a request
for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.
However, some 32-bit and 16-bit platforms may successfully serve a request for
more than <code>isize::MAX</code> bytes with things like Physical Address
Extension. As such, memory acquired directly from allocators or memory
mapped files <em>may</em> be too large to handle with this function.</p>
<p>Consider using <a href="#method.wrapping_offset"><code>wrapping_offset</code></a> instead if these constraints are
difficult to satisfy. The only advantage of this method is that it
enables more aggressive compiler optimizations.</p>
<h1 id="examples-13" class="section-header"><a href="#examples-13">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u32</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_mut_ptr</span>();

<span class="kw">unsafe</span> {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">offset</span>(<span class="number">1</span>));
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">offset</span>(<span class="number">2</span>));
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20s%20%3D%20%5B1%2C%202%2C%203%5D%3B%0Alet%20ptr%3A%20*mut%20u32%20%3D%20s.as_mut_ptr()%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.offset(1))%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.offset(2))%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></pre></div>
</div><h4 id='method.wrapping_offset-1' class="method"><code id='wrapping_offset.v-1'>pub fn <a href='#method.wrapping_offset-1' class='fnname'>wrapping_offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></code><span class='since' title='Stable since Rust version 1.16.0'>1.16.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#1903-1907' title='goto source code'>[src]</a></h4><div class='docblock'><p>Calculates the offset from a pointer using wrapping arithmetic.
<code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-10" class="section-header"><a href="#safety-10">Safety</a></h1>
<p>The resulting pointer does not need to be in bounds, but it is
potentially hazardous to dereference (which requires <code>unsafe</code>).</p>
<p>In particular, the resulting pointer remains attached to the same allocated
object that <code>self</code> points to. It may <em>not</em> be used to access a
different allocated object. Note that in Rust,
every (stack-allocated) variable is considered a separate allocated object.</p>
<p>In other words, <code>x.wrapping_offset(y.wrapping_offset_from(x))</code> is
<em>not</em> the same as <code>y</code>, and dereferencing it is undefined behavior
unless <code>x</code> and <code>y</code> point into the same allocated object.</p>
<p>Compared to <a href="#method.offset"><code>offset</code></a>, this method basically delays the requirement of staying
within the same allocated object: <a href="#method.offset"><code>offset</code></a> is immediate Undefined Behavior when
crossing object boundaries; <code>wrapping_offset</code> produces a pointer but still leads
to Undefined Behavior if that pointer is dereferenced. <a href="#method.offset"><code>offset</code></a> can be optimized
better and is thus preferrable in performance-sensitive code.</p>
<p>If you need to cross object boundaries, cast the pointer to an integer and
do the arithmetic there.</p>
<h1 id="examples-14" class="section-header"><a href="#examples-14">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Iterate using a raw pointer in increments of two elements</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">as_mut_ptr</span>();
<span class="kw">let</span> <span class="ident">step</span> <span class="op">=</span> <span class="number">2</span>;
<span class="kw">let</span> <span class="ident">end_rounded_up</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_offset</span>(<span class="number">6</span>);

<span class="kw">while</span> <span class="ident">ptr</span> <span class="op">!</span><span class="op">=</span> <span class="ident">end_rounded_up</span> {
    <span class="kw">unsafe</span> {
        <span class="kw-2">*</span><span class="ident">ptr</span> <span class="op">=</span> <span class="number">0</span>;
    }
    <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_offset</span>(<span class="ident">step</span>);
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">&amp;</span><span class="ident">data</span>, <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>]);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%2F%2F%20Iterate%20using%20a%20raw%20pointer%20in%20increments%20of%20two%20elements%0Afn%20main()%20%7B%0Alet%20mut%20data%20%3D%20%5B1u8%2C%202%2C%203%2C%204%2C%205%5D%3B%0Alet%20mut%20ptr%3A%20*mut%20u8%20%3D%20data.as_mut_ptr()%3B%0Alet%20step%20%3D%202%3B%0Alet%20end_rounded_up%20%3D%20ptr.wrapping_offset(6)%3B%0A%0Awhile%20ptr%20!%3D%20end_rounded_up%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20*ptr%20%3D%200%3B%0A%20%20%20%20%7D%0A%20%20%20%20ptr%20%3D%20ptr.wrapping_offset(step)%3B%0A%7D%0Aassert_eq!(%26data%2C%20%26%5B0%2C%202%2C%200%2C%204%2C%200%5D)%3B%0A%7D&amp;edition=2018">Run</a></pre></div>
</div><h4 id='method.as_mut' class="method"><code id='as_mut.v'>pub unsafe fn <a href='#method.as_mut' class='fnname'>as_mut</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="../std/option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;'a mut </a>T&gt;</code><span class='since' title='Stable since Rust version 1.9.0'>1.9.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#1945-1951' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns <code>None</code> if the pointer is null, or else returns a mutable
reference to the value wrapped in <code>Some</code>.</p>
<h1 id="safety-11" class="section-header"><a href="#safety-11">Safety</a></h1>
<p>As with <a href="#method.as_ref"><code>as_ref</code></a>, this is unsafe because it cannot verify the validity
of the returned pointer, nor can it ensure that the lifetime <code>'a</code>
returned is indeed a valid lifetime for the contained data.</p>
<p>When calling this method, you have to ensure that if the pointer is
non-NULL, then it is properly aligned, dereferencable (for the whole
size of <code>T</code>) and points to an initialized instance of <code>T</code>. This applies
even if the result of this method is unused!
(The part about being initialized is not yet fully decided, but until
it is the only safe approach is to ensure that they are indeed initialized.)</p>
<p>Additionally, the lifetime <code>'a</code> returned is arbitrarily chosen and does
not necessarily reflect the actual lifetime of the data. It is up to the
caller to ensure that for the duration of this lifetime, the memory this
pointer points to does not get accessed through any other pointer.</p>
<h1 id="examples-15" class="section-header"><a href="#examples-15">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u32</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_mut_ptr</span>();
<span class="kw">let</span> <span class="ident">first_value</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">ptr</span>.<span class="ident">as_mut</span>().<span class="ident">unwrap</span>() };
<span class="kw-2">*</span><span class="ident">first_value</span> <span class="op">=</span> <span class="number">4</span>;
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">s</span>); <span class="comment">// It&#39;ll print: &quot;[4, 2, 3]&quot;.</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20s%20%3D%20%5B1%2C%202%2C%203%5D%3B%0Alet%20ptr%3A%20*mut%20u32%20%3D%20s.as_mut_ptr()%3B%0Alet%20first_value%20%3D%20unsafe%20%7B%20ptr.as_mut().unwrap()%20%7D%3B%0A*first_value%20%3D%204%3B%0Aprintln!(%22%7B%3A%3F%7D%22%2C%20s)%3B%20%2F%2F%20It'll%20print%3A%20%22%5B4%2C%202%2C%203%5D%22.%0A%7D&amp;edition=2018">Run</a></pre></div>
</div><h4 id='method.offset_from-1' class="method"><code id='offset_from.v-1'>pub unsafe fn <a href='#method.offset_from-1' class='fnname'>offset_from</a>(self, origin: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.isize.html">isize</a></code><a class='srclink' href='../src/core/ptr/mod.rs.html#2017-2019' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>ptr_offset_from</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/41079">#41079</a>)</div></div><div class='docblock'><p>Calculates the distance between two pointers. The returned value is in
units of T: the distance in bytes is divided by <code>mem::size_of::&lt;T&gt;()</code>.</p>
<p>This function is the inverse of <a href="#method.offset-1"><code>offset</code></a>.</p>
<h1 id="safety-12" class="section-header"><a href="#safety-12">Safety</a></h1>
<p>If any of the following conditions are violated, the result is Undefined
Behavior:</p>
<ul>
<li>
<p>Both the starting and other pointer must be either in bounds or one
byte past the end of the same allocated object. Note that in Rust,
every (stack-allocated) variable is considered a separate allocated object.</p>
</li>
<li>
<p>The distance between the pointers, <strong>in bytes</strong>, cannot overflow an <code>isize</code>.</p>
</li>
<li>
<p>The distance between the pointers, in bytes, must be an exact multiple
of the size of <code>T</code>.</p>
</li>
<li>
<p>The distance being in bounds cannot rely on &quot;wrapping around&quot; the address space.</p>
</li>
</ul>
<p>The compiler and standard library generally try to ensure allocations
never reach a size where an offset is a concern. For instance, <code>Vec</code>
and <code>Box</code> ensure they never allocate more than <code>isize::MAX</code> bytes, so
<code>ptr_into_vec.offset_from(vec.as_ptr())</code> is always safe.</p>
<p>Most platforms fundamentally can't even construct such an allocation.
For instance, no known 64-bit platform can ever serve a request
for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.
However, some 32-bit and 16-bit platforms may successfully serve a request for
more than <code>isize::MAX</code> bytes with things like Physical Address
Extension. As such, memory acquired directly from allocators or memory
mapped files <em>may</em> be too large to handle with this function.</p>
<p>Consider using <a href="#method.wrapping_offset_from-1"><code>wrapping_offset_from</code></a> instead if these constraints are
difficult to satisfy. The only advantage of this method is that it
enables more aggressive compiler optimizations.</p>
<h1 id="panics-3" class="section-header"><a href="#panics-3">Panics</a></h1>
<p>This function panics if <code>T</code> is a Zero-Sized Type (&quot;ZST&quot;).</p>
<h1 id="examples-16" class="section-header"><a href="#examples-16">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">ptr_offset_from</span>)]</span>

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> [<span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let</span> <span class="ident">ptr1</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">a</span>[<span class="number">1</span>];
<span class="kw">let</span> <span class="ident">ptr2</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">a</span>[<span class="number">3</span>];
<span class="kw">unsafe</span> {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ptr2</span>.<span class="ident">offset_from</span>(<span class="ident">ptr1</span>), <span class="number">2</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ptr1</span>.<span class="ident">offset_from</span>(<span class="ident">ptr2</span>), <span class="op">-</span><span class="number">2</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ptr1</span>.<span class="ident">offset</span>(<span class="number">2</span>), <span class="ident">ptr2</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ptr2</span>.<span class="ident">offset</span>(<span class="op">-</span><span class="number">2</span>), <span class="ident">ptr1</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_offset_from)%5D%0A%0Afn%20main()%20%7B%0Alet%20mut%20a%20%3D%20%5B0%3B%205%5D%3B%0Alet%20ptr1%3A%20*mut%20i32%20%3D%20%26mut%20a%5B1%5D%3B%0Alet%20ptr2%3A%20*mut%20i32%20%3D%20%26mut%20a%5B3%5D%3B%0Aunsafe%20%7B%0A%20%20%20%20assert_eq!(ptr2.offset_from(ptr1)%2C%202)%3B%0A%20%20%20%20assert_eq!(ptr1.offset_from(ptr2)%2C%20-2)%3B%0A%20%20%20%20assert_eq!(ptr1.offset(2)%2C%20ptr2)%3B%0A%20%20%20%20assert_eq!(ptr2.offset(-2)%2C%20ptr1)%3B%0A%7D%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></pre></div>
</div><h4 id='method.wrapping_offset_from-1' class="method"><code id='wrapping_offset_from.v-1'>pub fn <a href='#method.wrapping_offset_from-1' class='fnname'>wrapping_offset_from</a>(self, origin: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.isize.html">isize</a></code><a class='srclink' href='../src/core/ptr/mod.rs.html#2057-2059' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>ptr_wrapping_offset_from</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/41079">#41079</a>)</div></div><div class='docblock'><p>Calculates the distance between two pointers. The returned value is in
units of T: the distance in bytes is divided by <code>mem::size_of::&lt;T&gt;()</code>.</p>
<p>If the address different between the two pointers is not a multiple of
<code>mem::size_of::&lt;T&gt;()</code> then the result of the division is rounded towards
zero.</p>
<p>Though this method is safe for any two pointers, note that its result
will be mostly useless if the two pointers aren't into the same allocated
object, for example if they point to two different local variables.</p>
<h1 id="panics-4" class="section-header"><a href="#panics-4">Panics</a></h1>
<p>This function panics if <code>T</code> is a zero-sized type.</p>
<h1 id="examples-17" class="section-header"><a href="#examples-17">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">ptr_wrapping_offset_from</span>)]</span>

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> [<span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let</span> <span class="ident">ptr1</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">a</span>[<span class="number">1</span>];
<span class="kw">let</span> <span class="ident">ptr2</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">a</span>[<span class="number">3</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ptr2</span>.<span class="ident">wrapping_offset_from</span>(<span class="ident">ptr1</span>), <span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ptr1</span>.<span class="ident">wrapping_offset_from</span>(<span class="ident">ptr2</span>), <span class="op">-</span><span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ptr1</span>.<span class="ident">wrapping_offset</span>(<span class="number">2</span>), <span class="ident">ptr2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ptr2</span>.<span class="ident">wrapping_offset</span>(<span class="op">-</span><span class="number">2</span>), <span class="ident">ptr1</span>);

<span class="kw">let</span> <span class="ident">ptr1</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span> <span class="op">=</span> <span class="number">3</span> <span class="kw">as</span> <span class="kw">_</span>;
<span class="kw">let</span> <span class="ident">ptr2</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span> <span class="op">=</span> <span class="number">13</span> <span class="kw">as</span> <span class="kw">_</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ptr2</span>.<span class="ident">wrapping_offset_from</span>(<span class="ident">ptr1</span>), <span class="number">2</span>);<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_wrapping_offset_from)%5D%0A%0Afn%20main()%20%7B%0Alet%20mut%20a%20%3D%20%5B0%3B%205%5D%3B%0Alet%20ptr1%3A%20*mut%20i32%20%3D%20%26mut%20a%5B1%5D%3B%0Alet%20ptr2%3A%20*mut%20i32%20%3D%20%26mut%20a%5B3%5D%3B%0Aassert_eq!(ptr2.wrapping_offset_from(ptr1)%2C%202)%3B%0Aassert_eq!(ptr1.wrapping_offset_from(ptr2)%2C%20-2)%3B%0Aassert_eq!(ptr1.wrapping_offset(2)%2C%20ptr2)%3B%0Aassert_eq!(ptr2.wrapping_offset(-2)%2C%20ptr1)%3B%0A%0Alet%20ptr1%3A%20*mut%20i32%20%3D%203%20as%20_%3B%0Alet%20ptr2%3A%20*mut%20i32%20%3D%2013%20as%20_%3B%0Aassert_eq!(ptr2.wrapping_offset_from(ptr1)%2C%202)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></pre></div>
</div><h4 id='method.add-1' class="method"><code id='add.v-1'>pub unsafe fn <a href='#method.add-1' class='fnname'>add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#2114-2118' title='goto source code'>[src]</a></h4><div class='docblock'><p>Calculates the offset from a pointer (convenience for <code>.offset(count as isize)</code>).</p>
<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-13" class="section-header"><a href="#safety-13">Safety</a></h1>
<p>If any of the following conditions are violated, the result is Undefined
Behavior:</p>
<ul>
<li>
<p>Both the starting and resulting pointer must be either in bounds or one
byte past the end of the same allocated object. Note that in Rust,
every (stack-allocated) variable is considered a separate allocated object.</p>
</li>
<li>
<p>The computed offset, <strong>in bytes</strong>, cannot overflow an <code>isize</code>.</p>
</li>
<li>
<p>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address
space. That is, the infinite-precision sum must fit in a <code>usize</code>.</p>
</li>
</ul>
<p>The compiler and standard library generally tries to ensure allocations
never reach a size where an offset is a concern. For instance, <code>Vec</code>
and <code>Box</code> ensure they never allocate more than <code>isize::MAX</code> bytes, so
<code>vec.as_ptr().add(vec.len())</code> is always safe.</p>
<p>Most platforms fundamentally can't even construct such an allocation.
For instance, no known 64-bit platform can ever serve a request
for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.
However, some 32-bit and 16-bit platforms may successfully serve a request for
more than <code>isize::MAX</code> bytes with things like Physical Address
Extension. As such, memory acquired directly from allocators or memory
mapped files <em>may</em> be too large to handle with this function.</p>
<p>Consider using <a href="#method.wrapping_add"><code>wrapping_add</code></a> instead if these constraints are
difficult to satisfy. The only advantage of this method is that it
enables more aggressive compiler optimizations.</p>
<h1 id="examples-18" class="section-header"><a href="#examples-18">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;123&quot;</span>;
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_ptr</span>();

<span class="kw">unsafe</span> {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">add</span>(<span class="number">1</span>) <span class="kw">as</span> <span class="ident">char</span>);
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">add</span>(<span class="number">2</span>) <span class="kw">as</span> <span class="ident">char</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%3A%20%26str%20%3D%20%22123%22%3B%0Alet%20ptr%3A%20*const%20u8%20%3D%20s.as_ptr()%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.add(1)%20as%20char)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.add(2)%20as%20char)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></pre></div>
</div><h4 id='method.sub-1' class="method"><code id='sub.v-1'>pub unsafe fn <a href='#method.sub-1' class='fnname'>sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#2174-2178' title='goto source code'>[src]</a></h4><div class='docblock'><p>Calculates the offset from a pointer (convenience for
<code>.offset((count as isize).wrapping_neg())</code>).</p>
<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-14" class="section-header"><a href="#safety-14">Safety</a></h1>
<p>If any of the following conditions are violated, the result is Undefined
Behavior:</p>
<ul>
<li>
<p>Both the starting and resulting pointer must be either in bounds or one
byte past the end of the same allocated object. Note that in Rust,
every (stack-allocated) variable is considered a separate allocated object.</p>
</li>
<li>
<p>The computed offset cannot exceed <code>isize::MAX</code> <strong>bytes</strong>.</p>
</li>
<li>
<p>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address
space. That is, the infinite-precision sum must fit in a usize.</p>
</li>
</ul>
<p>The compiler and standard library generally tries to ensure allocations
never reach a size where an offset is a concern. For instance, <code>Vec</code>
and <code>Box</code> ensure they never allocate more than <code>isize::MAX</code> bytes, so
<code>vec.as_ptr().add(vec.len()).sub(vec.len())</code> is always safe.</p>
<p>Most platforms fundamentally can't even construct such an allocation.
For instance, no known 64-bit platform can ever serve a request
for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.
However, some 32-bit and 16-bit platforms may successfully serve a request for
more than <code>isize::MAX</code> bytes with things like Physical Address
Extension. As such, memory acquired directly from allocators or memory
mapped files <em>may</em> be too large to handle with this function.</p>
<p>Consider using <a href="#method.wrapping_sub"><code>wrapping_sub</code></a> instead if these constraints are
difficult to satisfy. The only advantage of this method is that it
enables more aggressive compiler optimizations.</p>
<h1 id="examples-19" class="section-header"><a href="#examples-19">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;123&quot;</span>;

<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">end</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_ptr</span>().<span class="ident">add</span>(<span class="number">3</span>);
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">end</span>.<span class="ident">sub</span>(<span class="number">1</span>) <span class="kw">as</span> <span class="ident">char</span>);
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">end</span>.<span class="ident">sub</span>(<span class="number">2</span>) <span class="kw">as</span> <span class="ident">char</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%3A%20%26str%20%3D%20%22123%22%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20let%20end%3A%20*const%20u8%20%3D%20s.as_ptr().add(3)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*end.sub(1)%20as%20char)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*end.sub(2)%20as%20char)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></pre></div>
</div><h4 id='method.wrapping_add-1' class="method"><code id='wrapping_add.v-1'>pub fn <a href='#method.wrapping_add-1' class='fnname'>wrapping_add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#2228-2232' title='goto source code'>[src]</a></h4><div class='docblock'><p>Calculates the offset from a pointer using wrapping arithmetic.
(convenience for <code>.wrapping_offset(count as isize)</code>)</p>
<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-15" class="section-header"><a href="#safety-15">Safety</a></h1>
<p>The resulting pointer does not need to be in bounds, but it is
potentially hazardous to dereference (which requires <code>unsafe</code>).</p>
<p>In particular, the resulting pointer remains attached to the same allocated
object that <code>self</code> points to. It may <em>not</em> be used to access a
different allocated object. Note that in Rust,
every (stack-allocated) variable is considered a separate allocated object.</p>
<p>Compared to <a href="#method.add"><code>add</code></a>, this method basically delays the requirement of staying
within the same allocated object: <a href="#method.add"><code>add</code></a> is immediate Undefined Behavior when
crossing object boundaries; <code>wrapping_add</code> produces a pointer but still leads
to Undefined Behavior if that pointer is dereferenced. <a href="#method.add"><code>add</code></a> can be optimized
better and is thus preferrable in performance-sensitive code.</p>
<p>If you need to cross object boundaries, cast the pointer to an integer and
do the arithmetic there.</p>
<h1 id="examples-20" class="section-header"><a href="#examples-20">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Iterate using a raw pointer in increments of two elements</span>
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">as_ptr</span>();
<span class="kw">let</span> <span class="ident">step</span> <span class="op">=</span> <span class="number">2</span>;
<span class="kw">let</span> <span class="ident">end_rounded_up</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_add</span>(<span class="number">6</span>);

<span class="comment">// This loop prints &quot;1, 3, 5, &quot;</span>
<span class="kw">while</span> <span class="ident">ptr</span> <span class="op">!</span><span class="op">=</span> <span class="ident">end_rounded_up</span> {
    <span class="kw">unsafe</span> {
        <span class="macro">print</span><span class="macro">!</span>(<span class="string">&quot;{}, &quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>);
    }
    <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_add</span>(<span class="ident">step</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%2F%2F%20Iterate%20using%20a%20raw%20pointer%20in%20increments%20of%20two%20elements%0Afn%20main()%20%7B%0Alet%20data%20%3D%20%5B1u8%2C%202%2C%203%2C%204%2C%205%5D%3B%0Alet%20mut%20ptr%3A%20*const%20u8%20%3D%20data.as_ptr()%3B%0Alet%20step%20%3D%202%3B%0Alet%20end_rounded_up%20%3D%20ptr.wrapping_add(6)%3B%0A%0A%2F%2F%20This%20loop%20prints%20%221%2C%203%2C%205%2C%20%22%0Awhile%20ptr%20!%3D%20end_rounded_up%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20print!(%22%7B%7D%2C%20%22%2C%20*ptr)%3B%0A%20%20%20%20%7D%0A%20%20%20%20ptr%20%3D%20ptr.wrapping_add(step)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></pre></div>
</div><h4 id='method.wrapping_sub-1' class="method"><code id='wrapping_sub.v-1'>pub fn <a href='#method.wrapping_sub-1' class='fnname'>wrapping_sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#2282-2286' title='goto source code'>[src]</a></h4><div class='docblock'><p>Calculates the offset from a pointer using wrapping arithmetic.
(convenience for <code>.wrapping_offset((count as isize).wrapping_sub())</code>)</p>
<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer
offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>
<h1 id="safety-16" class="section-header"><a href="#safety-16">Safety</a></h1>
<p>The resulting pointer does not need to be in bounds, but it is
potentially hazardous to dereference (which requires <code>unsafe</code>).</p>
<p>In particular, the resulting pointer remains attached to the same allocated
object that <code>self</code> points to. It may <em>not</em> be used to access a
different allocated object. Note that in Rust,
every (stack-allocated) variable is considered a separate allocated object.</p>
<p>Compared to <a href="#method.sub"><code>sub</code></a>, this method basically delays the requirement of staying
within the same allocated object: <a href="#method.sub"><code>sub</code></a> is immediate Undefined Behavior when
crossing object boundaries; <code>wrapping_sub</code> produces a pointer but still leads
to Undefined Behavior if that pointer is dereferenced. <a href="#method.sub"><code>sub</code></a> can be optimized
better and is thus preferrable in performance-sensitive code.</p>
<p>If you need to cross object boundaries, cast the pointer to an integer and
do the arithmetic there.</p>
<h1 id="examples-21" class="section-header"><a href="#examples-21">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Iterate using a raw pointer in increments of two elements (backwards)</span>
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">as_ptr</span>();
<span class="kw">let</span> <span class="ident">start_rounded_down</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_sub</span>(<span class="number">2</span>);
<span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_add</span>(<span class="number">4</span>);
<span class="kw">let</span> <span class="ident">step</span> <span class="op">=</span> <span class="number">2</span>;
<span class="comment">// This loop prints &quot;5, 3, 1, &quot;</span>
<span class="kw">while</span> <span class="ident">ptr</span> <span class="op">!</span><span class="op">=</span> <span class="ident">start_rounded_down</span> {
    <span class="kw">unsafe</span> {
        <span class="macro">print</span><span class="macro">!</span>(<span class="string">&quot;{}, &quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>);
    }
    <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_sub</span>(<span class="ident">step</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%2F%2F%20Iterate%20using%20a%20raw%20pointer%20in%20increments%20of%20two%20elements%20(backwards)%0Afn%20main()%20%7B%0Alet%20data%20%3D%20%5B1u8%2C%202%2C%203%2C%204%2C%205%5D%3B%0Alet%20mut%20ptr%3A%20*const%20u8%20%3D%20data.as_ptr()%3B%0Alet%20start_rounded_down%20%3D%20ptr.wrapping_sub(2)%3B%0Aptr%20%3D%20ptr.wrapping_add(4)%3B%0Alet%20step%20%3D%202%3B%0A%2F%2F%20This%20loop%20prints%20%225%2C%203%2C%201%2C%20%22%0Awhile%20ptr%20!%3D%20start_rounded_down%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20print!(%22%7B%7D%2C%20%22%2C%20*ptr)%3B%0A%20%20%20%20%7D%0A%20%20%20%20ptr%20%3D%20ptr.wrapping_sub(step)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></pre></div>
</div><h4 id='method.read-1' class="method"><code id='read.v-1'>pub unsafe fn <a href='#method.read-1' class='fnname'>read</a>(self) -&gt; T</code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#2296-2300' title='goto source code'>[src]</a></h4><div class='docblock'><p>Reads the value from <code>self</code> without moving it. This leaves the
memory in <code>self</code> unchanged.</p>
<p>See <a href="./ptr/fn.read.html"><code>ptr::read</code></a> for safety concerns and examples.</p>
</div><h4 id='method.read_volatile-1' class="method"><code id='read_volatile.v-1'>pub unsafe fn <a href='#method.read_volatile-1' class='fnname'>read_volatile</a>(self) -&gt; T</code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#2314-2318' title='goto source code'>[src]</a></h4><div class='docblock'><p>Performs a volatile read of the value from <code>self</code> without moving it. This
leaves the memory in <code>self</code> unchanged.</p>
<p>Volatile operations are intended to act on I/O memory, and are guaranteed
to not be elided or reordered by the compiler across other volatile
operations.</p>
<p>See <a href="./ptr/fn.read_volatile.html"><code>ptr::read_volatile</code></a> for safety concerns and examples.</p>
</div><h4 id='method.read_unaligned-1' class="method"><code id='read_unaligned.v-1'>pub unsafe fn <a href='#method.read_unaligned-1' class='fnname'>read_unaligned</a>(self) -&gt; T</code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#2330-2334' title='goto source code'>[src]</a></h4><div class='docblock'><p>Reads the value from <code>self</code> without moving it. This leaves the
memory in <code>self</code> unchanged.</p>
<p>Unlike <code>read</code>, the pointer may be unaligned.</p>
<p>See <a href="./ptr/fn.read_unaligned.html"><code>ptr::read_unaligned</code></a> for safety concerns and examples.</p>
</div><h4 id='method.copy_to-1' class="method"><code id='copy_to.v-1'>pub unsafe fn <a href='#method.copy_to-1' class='fnname'>copy_to</a>(self, dest: <a class="primitive" href="primitive.pointer.html">*mut T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#2346-2350' title='goto source code'>[src]</a></h4><div class='docblock'><p>Copies <code>count * size_of&lt;T&gt;</code> bytes from <code>self</code> to <code>dest</code>. The source
and destination may overlap.</p>
<p>NOTE: this has the <em>same</em> argument order as <a href="./ptr/fn.copy.html"><code>ptr::copy</code></a>.</p>
<p>See <a href="./ptr/fn.copy.html"><code>ptr::copy</code></a> for safety concerns and examples.</p>
</div><h4 id='method.copy_to_nonoverlapping-1' class="method"><code id='copy_to_nonoverlapping.v-1'>pub unsafe fn <a href='#method.copy_to_nonoverlapping-1' class='fnname'>copy_to_nonoverlapping</a>(self, dest: <a class="primitive" href="primitive.pointer.html">*mut T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#2362-2366' title='goto source code'>[src]</a></h4><div class='docblock'><p>Copies <code>count * size_of&lt;T&gt;</code> bytes from <code>self</code> to <code>dest</code>. The source
and destination may <em>not</em> overlap.</p>
<p>NOTE: this has the <em>same</em> argument order as <a href="./ptr/fn.copy_nonoverlapping.html"><code>ptr::copy_nonoverlapping</code></a>.</p>
<p>See <a href="./ptr/fn.copy_nonoverlapping.html"><code>ptr::copy_nonoverlapping</code></a> for safety concerns and examples.</p>
</div><h4 id='method.copy_from' class="method"><code id='copy_from.v'>pub unsafe fn <a href='#method.copy_from' class='fnname'>copy_from</a>(self, src: <a class="primitive" href="primitive.pointer.html">*const T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#2378-2382' title='goto source code'>[src]</a></h4><div class='docblock'><p>Copies <code>count * size_of&lt;T&gt;</code> bytes from <code>src</code> to <code>self</code>. The source
and destination may overlap.</p>
<p>NOTE: this has the <em>opposite</em> argument order of <a href="./ptr/fn.copy.html"><code>ptr::copy</code></a>.</p>
<p>See <a href="./ptr/fn.copy.html"><code>ptr::copy</code></a> for safety concerns and examples.</p>
</div><h4 id='method.copy_from_nonoverlapping' class="method"><code id='copy_from_nonoverlapping.v'>pub unsafe fn <a href='#method.copy_from_nonoverlapping' class='fnname'>copy_from_nonoverlapping</a>(self, src: <a class="primitive" href="primitive.pointer.html">*const T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#2394-2398' title='goto source code'>[src]</a></h4><div class='docblock'><p>Copies <code>count * size_of&lt;T&gt;</code> bytes from <code>src</code> to <code>self</code>. The source
and destination may <em>not</em> overlap.</p>
<p>NOTE: this has the <em>opposite</em> argument order of <a href="./ptr/fn.copy_nonoverlapping.html"><code>ptr::copy_nonoverlapping</code></a>.</p>
<p>See <a href="./ptr/fn.copy_nonoverlapping.html"><code>ptr::copy_nonoverlapping</code></a> for safety concerns and examples.</p>
</div><h4 id='method.drop_in_place' class="method"><code id='drop_in_place.v'>pub unsafe fn <a href='#method.drop_in_place' class='fnname'>drop_in_place</a>(self)</code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#2407-2409' title='goto source code'>[src]</a></h4><div class='docblock'><p>Executes the destructor (if any) of the pointed-to value.</p>
<p>See <a href="./ptr/fn.drop_in_place.html"><code>ptr::drop_in_place</code></a> for safety concerns and examples.</p>
</div><h4 id='method.write' class="method"><code id='write.v'>pub unsafe fn <a href='#method.write' class='fnname'>write</a>(self, val: T)</code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#2419-2423' title='goto source code'>[src]</a></h4><div class='docblock'><p>Overwrites a memory location with the given value without reading or
dropping the old value.</p>
<p>See <a href="./ptr/fn.write.html"><code>ptr::write</code></a> for safety concerns and examples.</p>
</div><h4 id='method.write_bytes' class="method"><code id='write_bytes.v'>pub unsafe fn <a href='#method.write_bytes' class='fnname'>write_bytes</a>(self, val: <a class="primitive" href="primitive.u8.html">u8</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#2433-2437' title='goto source code'>[src]</a></h4><div class='docblock'><p>Invokes memset on the specified pointer, setting <code>count * size_of::&lt;T&gt;()</code>
bytes of memory starting at <code>self</code> to <code>val</code>.</p>
<p>See <a href="./ptr/fn.write_bytes.html"><code>ptr::write_bytes</code></a> for safety concerns and examples.</p>
</div><h4 id='method.write_volatile' class="method"><code id='write_volatile.v'>pub unsafe fn <a href='#method.write_volatile' class='fnname'>write_volatile</a>(self, val: T)</code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#2451-2455' title='goto source code'>[src]</a></h4><div class='docblock'><p>Performs a volatile write of a memory location with the given value without
reading or dropping the old value.</p>
<p>Volatile operations are intended to act on I/O memory, and are guaranteed
to not be elided or reordered by the compiler across other volatile
operations.</p>
<p>See <a href="./ptr/fn.write_volatile.html"><code>ptr::write_volatile</code></a> for safety concerns and examples.</p>
</div><h4 id='method.write_unaligned' class="method"><code id='write_unaligned.v'>pub unsafe fn <a href='#method.write_unaligned' class='fnname'>write_unaligned</a>(self, val: T)</code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#2467-2471' title='goto source code'>[src]</a></h4><div class='docblock'><p>Overwrites a memory location with the given value without reading or
dropping the old value.</p>
<p>Unlike <code>write</code>, the pointer may be unaligned.</p>
<p>See <a href="./ptr/fn.write_unaligned.html"><code>ptr::write_unaligned</code></a> for safety concerns and examples.</p>
</div><h4 id='method.replace' class="method"><code id='replace.v'>pub unsafe fn <a href='#method.replace' class='fnname'>replace</a>(self, src: T) -&gt; T</code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#2481-2485' title='goto source code'>[src]</a></h4><div class='docblock'><p>Replaces the value at <code>self</code> with <code>src</code>, returning the old
value, without dropping either.</p>
<p>See <a href="./ptr/fn.replace.html"><code>ptr::replace</code></a> for safety concerns and examples.</p>
</div><h4 id='method.swap' class="method"><code id='swap.v'>pub unsafe fn <a href='#method.swap' class='fnname'>swap</a>(self, with: <a class="primitive" href="primitive.pointer.html">*mut T</a>)</code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#2496-2500' title='goto source code'>[src]</a></h4><div class='docblock'><p>Swaps the values at two mutable locations of the same type, without
deinitializing either. They may overlap, unlike <code>mem::swap</code> which is
otherwise equivalent.</p>
<p>See <a href="./ptr/fn.swap.html"><code>ptr::swap</code></a> for safety concerns and examples.</p>
</div><h4 id='method.align_offset-1' class="method"><code id='align_offset.v-1'>pub fn <a href='#method.align_offset-1' class='fnname'>align_offset</a>(self, align: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></code><span class='since' title='Stable since Rust version 1.36.0'>1.36.0</span><a class='srclink' href='../src/core/ptr/mod.rs.html#2542-2549' title='goto source code'>[src]</a></h4><div class='docblock'><p>Computes the offset that needs to be applied to the pointer in order to make it aligned to
<code>align</code>.</p>
<p>If it is not possible to align the pointer, the implementation returns
<code>usize::max_value()</code>. It is permissible for the implementation to <em>always</em>
return <code>usize::max_value()</code>. Only your algorithm's performance can depend
on getting a usable offset here, not its correctness.</p>
<p>The offset is expressed in number of <code>T</code> elements, and not bytes. The value returned can be
used with the <code>wrapping_add</code> method.</p>
<p>There are no guarantees whatsoever that offsetting the pointer will not overflow or go
beyond the allocation that the pointer points into. It is up to the caller to ensure that
the returned offset is correct in all terms other than alignment.</p>
<h1 id="panics-5" class="section-header"><a href="#panics-5">Panics</a></h1>
<p>The function panics if <code>align</code> is not a power-of-two.</p>
<h1 id="examples-22" class="section-header"><a href="#examples-22">Examples</a></h1>
<p>Accessing adjacent <code>u8</code> as <code>u16</code></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> [<span class="number">5u8</span>, <span class="number">6u8</span>, <span class="number">7u8</span>, <span class="number">8u8</span>, <span class="number">9u8</span>];
<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">x</span>[<span class="ident">n</span>] <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>;
<span class="kw">let</span> <span class="ident">offset</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">align_offset</span>(<span class="ident">align_of</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>());
<span class="kw">if</span> <span class="ident">offset</span> <span class="op">&lt;</span> <span class="ident">x</span>.<span class="ident">len</span>() <span class="op">-</span> <span class="ident">n</span> <span class="op">-</span> <span class="number">1</span> {
    <span class="kw">let</span> <span class="ident">u16_ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">add</span>(<span class="ident">offset</span>) <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u16</span>;
    <span class="macro">assert_ne</span><span class="macro">!</span>(<span class="kw-2">*</span><span class="ident">u16_ptr</span>, <span class="number">500</span>);
} <span class="kw">else</span> {
    <span class="comment">// while the pointer can be aligned via `offset`, it would point</span>
    <span class="comment">// outside the allocation</span>
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Afn%20foo(n%3A%20usize)%20%7B%0Ause%20std%3A%3Amem%3A%3Aalign_of%3B%0Aunsafe%20%7B%0Alet%20x%20%3D%20%5B5u8%2C%206u8%2C%207u8%2C%208u8%2C%209u8%5D%3B%0Alet%20ptr%20%3D%20%26x%5Bn%5D%20as%20*const%20u8%3B%0Alet%20offset%20%3D%20ptr.align_offset(align_of%3A%3A%3Cu16%3E())%3B%0Aif%20offset%20%3C%20x.len()%20-%20n%20-%201%20%7B%0A%20%20%20%20let%20u16_ptr%20%3D%20ptr.add(offset)%20as%20*const%20u16%3B%0A%20%20%20%20assert_ne!(*u16_ptr%2C%20500)%3B%0A%7D%20else%20%7B%0A%20%20%20%20%2F%2F%20while%20the%20pointer%20can%20be%20aligned%20via%20%60offset%60%2C%20it%20would%20point%0A%20%20%20%20%2F%2F%20outside%20the%20allocation%0A%7D%0A%7D%20%7D%0A%7D&amp;edition=2018">Run</a></pre></div>
</div></div><h2 id='implementations' class='small-section-header'>Trait Implementations<a href='#implementations' class='anchor'></a></h2><div id='implementations-list'><h3 id='impl-Debug' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/fmt/trait.Debug.html" title="trait std::fmt::Debug">Debug</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Debug' class='anchor'></a><a class='srclink' href='../src/core/fmt/mod.rs.html#2071-2073' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.fmt' class="method hidden"><code id='fmt.v'>fn <a href='../std/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../std/fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>) -&gt; <a class="enum" href="../std/result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="../std/fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</code><a class='srclink' href='../src/core/fmt/mod.rs.html#2072' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter. <a href="../std/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></div><h3 id='impl-Debug-1' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/fmt/trait.Debug.html" title="trait std::fmt::Debug">Debug</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Debug-1' class='anchor'></a><a class='srclink' href='../src/core/fmt/mod.rs.html#2075-2077' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.fmt-1' class="method hidden"><code id='fmt.v-1'>fn <a href='../std/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../std/fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>) -&gt; <a class="enum" href="../std/result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="../std/fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</code><a class='srclink' href='../src/core/fmt/mod.rs.html#2076' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter. <a href="../std/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></div><h3 id='impl-Hash' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/hash/trait.Hash.html" title="trait std::hash::Hash">Hash</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Hash' class='anchor'></a><a class='srclink' href='../src/core/hash/mod.rs.html#684-698' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.hash' class="method hidden"><code id='hash.v'>fn <a href='../std/hash/trait.Hash.html#tymethod.hash' class='fnname'>hash</a>&lt;H&gt;(&amp;self, state: <a class="primitive" href="primitive.reference.html">&amp;mut </a>H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="../std/hash/trait.Hasher.html" title="trait std::hash::Hasher">Hasher</a>,&nbsp;</span></code><a class='srclink' href='../src/core/hash/mod.rs.html#685-697' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Feeds this value into the given [<code>Hasher</code>]. <a href="../std/hash/trait.Hash.html#tymethod.hash">Read more</a></p>
</div><h4 id='method.hash_slice' class="method hidden"><code id='hash_slice.v'>fn <a href='../std/hash/trait.Hash.html#method.hash_slice' class='fnname'>hash_slice</a>&lt;H&gt;(data: <a class="primitive" href="primitive.slice.html">&amp;[Self]</a>, state: <a class="primitive" href="primitive.reference.html">&amp;mut </a>H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="../std/hash/trait.Hasher.html" title="trait std::hash::Hasher">Hasher</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.3.0'>1.3.0</span><a class='srclink' href='../src/core/hash/mod.rs.html#192-198' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Feeds a slice of this type into the given [<code>Hasher</code>]. <a href="../std/hash/trait.Hash.html#method.hash_slice">Read more</a></p>
</div></div><h3 id='impl-Hash-1' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/hash/trait.Hash.html" title="trait std::hash::Hash">Hash</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Hash-1' class='anchor'></a><a class='srclink' href='../src/core/hash/mod.rs.html#701-715' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.hash-1' class="method hidden"><code id='hash.v-1'>fn <a href='../std/hash/trait.Hash.html#tymethod.hash' class='fnname'>hash</a>&lt;H&gt;(&amp;self, state: <a class="primitive" href="primitive.reference.html">&amp;mut </a>H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="../std/hash/trait.Hasher.html" title="trait std::hash::Hasher">Hasher</a>,&nbsp;</span></code><a class='srclink' href='../src/core/hash/mod.rs.html#702-714' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Feeds this value into the given [<code>Hasher</code>]. <a href="../std/hash/trait.Hash.html#tymethod.hash">Read more</a></p>
</div><h4 id='method.hash_slice-1' class="method hidden"><code id='hash_slice.v-1'>fn <a href='../std/hash/trait.Hash.html#method.hash_slice' class='fnname'>hash_slice</a>&lt;H&gt;(data: <a class="primitive" href="primitive.slice.html">&amp;[Self]</a>, state: <a class="primitive" href="primitive.reference.html">&amp;mut </a>H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="../std/hash/trait.Hasher.html" title="trait std::hash::Hasher">Hasher</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.3.0'>1.3.0</span><a class='srclink' href='../src/core/hash/mod.rs.html#192-198' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Feeds a slice of this type into the given [<code>Hasher</code>]. <a href="../std/hash/trait.Hash.html#method.hash_slice">Read more</a></p>
</div></div><h3 id='impl-Sync' class='impl'><code class='in-band'>impl&lt;T&gt; !<a class="trait" href="../std/marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Sync' class='anchor'></a><a class='srclink' href='../src/core/marker.rs.html#387' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-Sync-1' class='impl'><code class='in-band'>impl&lt;T&gt; !<a class="trait" href="../std/marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Sync-1' class='anchor'></a><a class='srclink' href='../src/core/marker.rs.html#389' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-Eq' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/cmp/trait.Eq.html" title="trait std::cmp::Eq">Eq</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Eq' class='anchor'></a><a class='srclink' href='../src/core/ptr/mod.rs.html#2677' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-Eq-1' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/cmp/trait.Eq.html" title="trait std::cmp::Eq">Eq</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Eq-1' class='anchor'></a><a class='srclink' href='../src/core/ptr/mod.rs.html#2686' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-Pointer' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/fmt/trait.Pointer.html" title="trait std::fmt::Pointer">Pointer</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Pointer' class='anchor'></a><a class='srclink' href='../src/core/fmt/mod.rs.html#2048-2052' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.fmt-2' class="method hidden"><code id='fmt.v-2'>fn <a href='../std/fmt/trait.Pointer.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../std/fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>) -&gt; <a class="enum" href="../std/result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="../std/fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</code><a class='srclink' href='../src/core/fmt/mod.rs.html#2049-2051' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter.</p>
</div></div><h3 id='impl-Pointer-1' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/fmt/trait.Pointer.html" title="trait std::fmt::Pointer">Pointer</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Pointer-1' class='anchor'></a><a class='srclink' href='../src/core/fmt/mod.rs.html#2020-2045' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.fmt-3' class="method hidden"><code id='fmt.v-3'>fn <a href='../std/fmt/trait.Pointer.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../std/fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>) -&gt; <a class="enum" href="../std/result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="../std/fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</code><a class='srclink' href='../src/core/fmt/mod.rs.html#2021-2044' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter.</p>
</div></div><h3 id='impl-Clone' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Clone' class='anchor'></a><a class='srclink' href='../src/core/clone.rs.html#198-203' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.clone' class="method hidden"><code id='clone.v'>fn <a href='../std/clone/trait.Clone.html#tymethod.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></code><a class='srclink' href='../src/core/clone.rs.html#200-202' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Returns a copy of the value. <a href="../std/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div><h4 id='method.clone_from' class="method hidden"><code id='clone_from.v'>fn <a href='../std/clone/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: <a class="primitive" href="primitive.reference.html">&amp;</a>Self)</code><a class='srclink' href='../src/core/clone.rs.html#131-133' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs copy-assignment from <code>source</code>. <a href="../std/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div><h3 id='impl-Clone-1' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Clone-1' class='anchor'></a><a class='srclink' href='../src/core/clone.rs.html#206-211' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.clone-1' class="method hidden"><code id='clone.v-1'>fn <a href='../std/clone/trait.Clone.html#tymethod.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></code><a class='srclink' href='../src/core/clone.rs.html#208-210' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Returns a copy of the value. <a href="../std/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div><h4 id='method.clone_from-1' class="method hidden"><code id='clone_from.v-1'>fn <a href='../std/clone/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: <a class="primitive" href="primitive.reference.html">&amp;</a>Self)</code><a class='srclink' href='../src/core/clone.rs.html#131-133' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs copy-assignment from <code>source</code>. <a href="../std/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div><h3 id='impl-PartialEq%3C*mut%20T%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut T</a>&gt; for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-PartialEq%3C*mut%20T%3E' class='anchor'></a><a class='srclink' href='../src/core/ptr/mod.rs.html#2680-2683' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.eq' class="method hidden"><code id='eq.v'>fn <a href='../std/cmp/trait.PartialEq.html#tymethod.eq' class='fnname'>eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></code><a class='srclink' href='../src/core/ptr/mod.rs.html#2682' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../std/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id='method.ne' class="method hidden"><code id='ne.v'><span class="docblock attributes">#[must_use]
</span>fn <a href='../std/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></code><a class='srclink' href='../src/core/cmp.rs.html#208' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 id='impl-PartialEq%3C*const%20T%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.pointer.html">*const T</a>&gt; for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-PartialEq%3C*const%20T%3E' class='anchor'></a><a class='srclink' href='../src/core/ptr/mod.rs.html#2671-2674' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.eq-1' class="method hidden"><code id='eq.v-1'>fn <a href='../std/cmp/trait.PartialEq.html#tymethod.eq' class='fnname'>eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></code><a class='srclink' href='../src/core/ptr/mod.rs.html#2673' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../std/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id='method.ne-1' class="method hidden"><code id='ne.v-1'><span class="docblock attributes">#[must_use]
</span>fn <a href='../std/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></code><a class='srclink' href='../src/core/cmp.rs.html#208' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 id='impl-PartialOrd%3C*mut%20T%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/cmp/trait.PartialOrd.html" title="trait std::cmp::PartialOrd">PartialOrd</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut T</a>&gt; for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-PartialOrd%3C*mut%20T%3E' class='anchor'></a><a class='srclink' href='../src/core/ptr/mod.rs.html#2934-2951' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.partial_cmp' class="method hidden"><code id='partial_cmp.v'>fn <a href='../std/cmp/trait.PartialOrd.html#tymethod.partial_cmp' class='fnname'>partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="enum" href="../std/option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="enum" href="../std/cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a>&gt;</code><a class='srclink' href='../src/core/ptr/mod.rs.html#2936-2938' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../std/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div><h4 id='method.lt' class="method hidden"><code id='lt.v'>fn <a href='../std/cmp/trait.PartialOrd.html#method.lt' class='fnname'>lt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></code><a class='srclink' href='../src/core/ptr/mod.rs.html#2941' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../std/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div><h4 id='method.le' class="method hidden"><code id='le.v'>fn <a href='../std/cmp/trait.PartialOrd.html#method.le' class='fnname'>le</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></code><a class='srclink' href='../src/core/ptr/mod.rs.html#2944' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="../std/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div><h4 id='method.gt' class="method hidden"><code id='gt.v'>fn <a href='../std/cmp/trait.PartialOrd.html#method.gt' class='fnname'>gt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></code><a class='srclink' href='../src/core/ptr/mod.rs.html#2947' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../std/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div><h4 id='method.ge' class="method hidden"><code id='ge.v'>fn <a href='../std/cmp/trait.PartialOrd.html#method.ge' class='fnname'>ge</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></code><a class='srclink' href='../src/core/ptr/mod.rs.html#2950' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="../std/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></div><h3 id='impl-PartialOrd%3C*const%20T%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/cmp/trait.PartialOrd.html" title="trait std::cmp::PartialOrd">PartialOrd</a>&lt;<a class="primitive" href="primitive.pointer.html">*const T</a>&gt; for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-PartialOrd%3C*const%20T%3E' class='anchor'></a><a class='srclink' href='../src/core/ptr/mod.rs.html#2900-2917' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.partial_cmp-1' class="method hidden"><code id='partial_cmp.v-1'>fn <a href='../std/cmp/trait.PartialOrd.html#tymethod.partial_cmp' class='fnname'>partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="enum" href="../std/option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="enum" href="../std/cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a>&gt;</code><a class='srclink' href='../src/core/ptr/mod.rs.html#2902-2904' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../std/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div><h4 id='method.lt-1' class="method hidden"><code id='lt.v-1'>fn <a href='../std/cmp/trait.PartialOrd.html#method.lt' class='fnname'>lt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></code><a class='srclink' href='../src/core/ptr/mod.rs.html#2907' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../std/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div><h4 id='method.le-1' class="method hidden"><code id='le.v-1'>fn <a href='../std/cmp/trait.PartialOrd.html#method.le' class='fnname'>le</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></code><a class='srclink' href='../src/core/ptr/mod.rs.html#2910' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="../std/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div><h4 id='method.gt-1' class="method hidden"><code id='gt.v-1'>fn <a href='../std/cmp/trait.PartialOrd.html#method.gt' class='fnname'>gt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></code><a class='srclink' href='../src/core/ptr/mod.rs.html#2913' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../std/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div><h4 id='method.ge-1' class="method hidden"><code id='ge.v-1'>fn <a href='../std/cmp/trait.PartialOrd.html#method.ge' class='fnname'>ge</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></code><a class='srclink' href='../src/core/ptr/mod.rs.html#2916' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="../std/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></div><h3 id='impl-CoerceUnsized%3C*mut%20U%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="../std/ops/trait.CoerceUnsized.html" title="trait std::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../std/marker/trait.Unsize.html" title="trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-CoerceUnsized%3C*mut%20U%3E' class='anchor'></a><a class='srclink' href='../src/core/ops/unsize.rs.html#62' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-CoerceUnsized%3C*const%20U%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="../std/ops/trait.CoerceUnsized.html" title="trait std::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.pointer.html">*const U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../std/marker/trait.Unsize.html" title="trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-CoerceUnsized%3C*const%20U%3E' class='anchor'></a><a class='srclink' href='../src/core/ops/unsize.rs.html#69' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-CoerceUnsized%3C*const%20U%3E-1' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="../std/ops/trait.CoerceUnsized.html" title="trait std::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.pointer.html">*const U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../std/marker/trait.Unsize.html" title="trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-CoerceUnsized%3C*const%20U%3E-1' class='anchor'></a><a class='srclink' href='../src/core/ops/unsize.rs.html#65' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-Send' class='impl'><code class='in-band'>impl&lt;T&gt; !<a class="trait" href="../std/marker/trait.Send.html" title="trait std::marker::Send">Send</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Send' class='anchor'></a><a class='srclink' href='../src/core/marker.rs.html#43' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-Send-1' class='impl'><code class='in-band'>impl&lt;T&gt; !<a class="trait" href="../std/marker/trait.Send.html" title="trait std::marker::Send">Send</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Send-1' class='anchor'></a><a class='srclink' href='../src/core/marker.rs.html#41' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-DispatchFromDyn%3C*const%20U%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="../std/ops/trait.DispatchFromDyn.html" title="trait std::ops::DispatchFromDyn">DispatchFromDyn</a>&lt;<a class="primitive" href="primitive.pointer.html">*const U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../std/marker/trait.Unsize.html" title="trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-DispatchFromDyn%3C*const%20U%3E' class='anchor'></a><a class='srclink' href='../src/core/ops/unsize.rs.html#99' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-DispatchFromDyn%3C*mut%20U%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="../std/ops/trait.DispatchFromDyn.html" title="trait std::ops::DispatchFromDyn">DispatchFromDyn</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../std/marker/trait.Unsize.html" title="trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-DispatchFromDyn%3C*mut%20U%3E' class='anchor'></a><a class='srclink' href='../src/core/ops/unsize.rs.html#102' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-Unpin' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Unpin' class='anchor'></a><span class='since' title='Stable since Rust version 1.38.0'>1.38.0</span><a class='srclink' href='../src/core/marker.rs.html#666' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-Unpin-1' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Unpin-1' class='anchor'></a><span class='since' title='Stable since Rust version 1.38.0'>1.38.0</span><a class='srclink' href='../src/core/marker.rs.html#669' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-Ord' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/cmp/trait.Ord.html" title="trait std::cmp::Ord">Ord</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Ord' class='anchor'></a><a class='srclink' href='../src/core/ptr/mod.rs.html#2886-2897' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.cmp' class="method hidden"><code id='cmp.v'>fn <a href='../std/cmp/trait.Ord.html#tymethod.cmp' class='fnname'>cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="enum" href="../std/cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a></code><a class='srclink' href='../src/core/ptr/mod.rs.html#2888-2896' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method returns an <code>Ordering</code> between <code>self</code> and <code>other</code>. <a href="../std/cmp/trait.Ord.html#tymethod.cmp">Read more</a></p>
</div><h4 id='method.max' class="method hidden"><code id='max.v'>fn <a href='../std/cmp/trait.Ord.html#method.max' class='fnname'>max</a>(self, other: Self) -&gt; Self</code><span class='since' title='Stable since Rust version 1.21.0'>1.21.0</span><a class='srclink' href='../src/core/cmp.rs.html#571-574' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Compares and returns the maximum of two values. <a href="../std/cmp/trait.Ord.html#method.max">Read more</a></p>
</div><h4 id='method.min' class="method hidden"><code id='min.v'>fn <a href='../std/cmp/trait.Ord.html#method.min' class='fnname'>min</a>(self, other: Self) -&gt; Self</code><span class='since' title='Stable since Rust version 1.21.0'>1.21.0</span><a class='srclink' href='../src/core/cmp.rs.html#588-591' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Compares and returns the minimum of two values. <a href="../std/cmp/trait.Ord.html#method.min">Read more</a></p>
</div><h4 id='method.clamp' class="method hidden"><code id='clamp.v'>fn <a href='../std/cmp/trait.Ord.html#method.clamp' class='fnname'>clamp</a>(self, min: Self, max: Self) -&gt; Self</code><a class='srclink' href='../src/core/cmp.rs.html#612-622' title='goto source code'>[src]</a></h4><div class='stability hidden'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>clamp</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/44095">#44095</a>)</div></div><div class='docblock hidden'><p>Restrict a value to a certain interval. <a href="../std/cmp/trait.Ord.html#method.clamp">Read more</a></p>
</div></div><h3 id='impl-Ord-1' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/cmp/trait.Ord.html" title="trait std::cmp::Ord">Ord</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Ord-1' class='anchor'></a><a class='srclink' href='../src/core/ptr/mod.rs.html#2920-2931' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.cmp-1' class="method hidden"><code id='cmp.v-1'>fn <a href='../std/cmp/trait.Ord.html#tymethod.cmp' class='fnname'>cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="enum" href="../std/cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a></code><a class='srclink' href='../src/core/ptr/mod.rs.html#2922-2930' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method returns an <code>Ordering</code> between <code>self</code> and <code>other</code>. <a href="../std/cmp/trait.Ord.html#tymethod.cmp">Read more</a></p>
</div><h4 id='method.max-1' class="method hidden"><code id='max.v-1'>fn <a href='../std/cmp/trait.Ord.html#method.max' class='fnname'>max</a>(self, other: Self) -&gt; Self</code><span class='since' title='Stable since Rust version 1.21.0'>1.21.0</span><a class='srclink' href='../src/core/cmp.rs.html#571-574' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Compares and returns the maximum of two values. <a href="../std/cmp/trait.Ord.html#method.max">Read more</a></p>
</div><h4 id='method.min-1' class="method hidden"><code id='min.v-1'>fn <a href='../std/cmp/trait.Ord.html#method.min' class='fnname'>min</a>(self, other: Self) -&gt; Self</code><span class='since' title='Stable since Rust version 1.21.0'>1.21.0</span><a class='srclink' href='../src/core/cmp.rs.html#588-591' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Compares and returns the minimum of two values. <a href="../std/cmp/trait.Ord.html#method.min">Read more</a></p>
</div><h4 id='method.clamp-1' class="method hidden"><code id='clamp.v-1'>fn <a href='../std/cmp/trait.Ord.html#method.clamp' class='fnname'>clamp</a>(self, min: Self, max: Self) -&gt; Self</code><a class='srclink' href='../src/core/cmp.rs.html#612-622' title='goto source code'>[src]</a></h4><div class='stability hidden'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>clamp</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/44095">#44095</a>)</div></div><div class='docblock hidden'><p>Restrict a value to a certain interval. <a href="../std/cmp/trait.Ord.html#method.clamp">Read more</a></p>
</div></div><h3 id='impl-Copy' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/marker/trait.Copy.html" title="trait std::marker::Copy">Copy</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Copy' class='anchor'></a><a class='srclink' href='../src/core/marker.rs.html#699' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-Copy-1' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/marker/trait.Copy.html" title="trait std::marker::Copy">Copy</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Copy-1' class='anchor'></a><a class='srclink' href='../src/core/marker.rs.html#702' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-UnwindSafe' class='impl'><code class='in-band'>impl&lt;T:&nbsp;<a class="trait" href="../std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="../std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="primitive" href="primitive.pointer.html">*const T</a></code><a href='#impl-UnwindSafe' class='anchor'></a><span class='since' title='Stable since Rust version 1.9.0'>1.9.0</span><a class='srclink' href='../src/std/panic.rs.html#207' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-UnwindSafe-1' class='impl'><code class='in-band'>impl&lt;T:&nbsp;<a class="trait" href="../std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="../std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a></code><a href='#impl-UnwindSafe-1' class='anchor'></a><span class='since' title='Stable since Rust version 1.9.0'>1.9.0</span><a class='srclink' href='../src/std/panic.rs.html#209' title='goto source code'>[src]</a></h3><div class='impl-items'></div></div><h2 id='synthetic-implementations' class='small-section-header'>Auto Trait Implementations<a href='#synthetic-implementations' class='anchor'></a></h2><div id='synthetic-implementations-list'><h3 id='impl-RefUnwindSafe' class='impl'><code class='in-band'>impl&lt;T:&nbsp;?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="../std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,&nbsp;</span></code><a href='#impl-RefUnwindSafe' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-RefUnwindSafe-1' class='impl'><code class='in-band'>impl&lt;T:&nbsp;?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="../std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,&nbsp;</span></code><a href='#impl-RefUnwindSafe-1' class='anchor'></a></h3><div class='impl-items'></div></div><h2 id='blanket-implementations' class='small-section-header'>Blanket Implementations<a href='#blanket-implementations' class='anchor'></a></h2><div id='blanket-implementations-list'><h3 id='impl-From%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for T</code><a href='#impl-From%3CT%3E' class='anchor'></a><a class='srclink' href='../src/core/convert.rs.html#553-555' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from' class="method hidden"><code id='from.v'>fn <a href='../std/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(t: T) -&gt; T</code><a class='srclink' href='../src/core/convert.rs.html#554' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-TryFrom%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="../std/convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../std/convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryFrom%3CU%3E' class='anchor'></a><a class='srclink' href='../src/core/convert.rs.html#572-578' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error' class="type"><code id='Error.t'>type <a href='../std/convert/trait.TryFrom.html#associatedtype.Error' class="type">Error</a> = <a class="enum" href="../std/convert/enum.Infallible.html" title="enum std::convert::Infallible">Infallible</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_from' class="method hidden"><code id='try_from.v'>fn <a href='../std/convert/trait.TryFrom.html#tymethod.try_from' class='fnname'>try_from</a>(value: U) -&gt; <a class="enum" href="../std/result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="../std/convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="../std/convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='../src/core/convert.rs.html#575-577' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Into%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="../std/convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../std/convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-Into%3CU%3E' class='anchor'></a><a class='srclink' href='../src/core/convert.rs.html#544-549' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.into' class="method hidden"><code id='into.v'>fn <a href='../std/convert/trait.Into.html#tymethod.into' class='fnname'>into</a>(self) -&gt; U</code><a class='srclink' href='../src/core/convert.rs.html#546-548' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-TryInto%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="../std/convert/trait.TryInto.html" title="trait std::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../std/convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryInto%3CU%3E' class='anchor'></a><a class='srclink' href='../src/core/convert.rs.html#560-567' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error-1' class="type"><code id='Error.t-1'>type <a href='../std/convert/trait.TryInto.html#associatedtype.Error' class="type">Error</a> = &lt;U as <a class="trait" href="../std/convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="../std/convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_into' class="method hidden"><code id='try_into.v'>fn <a href='../std/convert/trait.TryInto.html#tymethod.try_into' class='fnname'>try_into</a>(self) -&gt; <a class="enum" href="../std/result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="../std/convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="../std/convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='../src/core/convert.rs.html#564-566' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Borrow%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Borrow%3CT%3E' class='anchor'></a><a class='srclink' href='../src/core/borrow.rs.html#213-215' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow' class="method hidden"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>F</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>F</h3><code class="content"><span class="where fmt-newline">impl&lt;'_, F&gt; <a class="trait" href="../std/future/trait.Future.html" title="trait std::future::Future">Future</a> for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>F <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../std/marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> + <a class="trait" href="../std/future/trait.Future.html" title="trait std::future::Future">Future</a> + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='../std/future/trait.Future.html#associatedtype.Output' class="type">Output</a> = &lt;F as <a class="trait" href="../std/future/trait.Future.html" title="trait std::future::Future">Future</a>&gt;::<a class="type" href="../std/future/trait.Future.html#associatedtype.Output" title="type std::future::Future::Output">Output</a>;</span><span class="where fmt-newline">impl&lt;'_, I&gt; <a class="trait" href="../std/iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>I <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../std/iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='../std/iter/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &lt;I as <a class="trait" href="../std/iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a>&gt;::<a class="type" href="../std/iter/trait.Iterator.html#associatedtype.Item" title="type std::iter::Iterator::Item">Item</a>;</span><span class="where fmt-newline">impl&lt;'_, R:&nbsp;<a class="trait" href="../std/io/trait.Read.html" title="trait std::io::Read">Read</a> + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="../std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>R</span><span class="where fmt-newline">impl&lt;'_, W:&nbsp;<a class="trait" href="../std/io/trait.Write.html" title="trait std::io::Write">Write</a> + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="../std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>W</span></code></div></div><code id='borrow.v'>fn <a href='../std/borrow/trait.Borrow.html#tymethod.borrow' class='fnname'>borrow</a>(&amp;self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;</a>T</code><a class='srclink' href='../src/core/borrow.rs.html#214' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="../std/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id='impl-BorrowMut%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/borrow/trait.BorrowMut.html" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-BorrowMut%3CT%3E' class='anchor'></a><a class='srclink' href='../src/core/borrow.rs.html#218-220' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow_mut' class="method hidden"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>F</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>F</h3><code class="content"><span class="where fmt-newline">impl&lt;'_, F&gt; <a class="trait" href="../std/future/trait.Future.html" title="trait std::future::Future">Future</a> for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>F <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../std/marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> + <a class="trait" href="../std/future/trait.Future.html" title="trait std::future::Future">Future</a> + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='../std/future/trait.Future.html#associatedtype.Output' class="type">Output</a> = &lt;F as <a class="trait" href="../std/future/trait.Future.html" title="trait std::future::Future">Future</a>&gt;::<a class="type" href="../std/future/trait.Future.html#associatedtype.Output" title="type std::future::Future::Output">Output</a>;</span><span class="where fmt-newline">impl&lt;'_, I&gt; <a class="trait" href="../std/iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>I <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../std/iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='../std/iter/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &lt;I as <a class="trait" href="../std/iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a>&gt;::<a class="type" href="../std/iter/trait.Iterator.html#associatedtype.Item" title="type std::iter::Iterator::Item">Item</a>;</span><span class="where fmt-newline">impl&lt;'_, R:&nbsp;<a class="trait" href="../std/io/trait.Read.html" title="trait std::io::Read">Read</a> + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="../std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>R</span><span class="where fmt-newline">impl&lt;'_, W:&nbsp;<a class="trait" href="../std/io/trait.Write.html" title="trait std::io::Write">Write</a> + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="../std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>W</span></code></div></div><code id='borrow_mut.v'>fn <a href='../std/borrow/trait.BorrowMut.html#tymethod.borrow_mut' class='fnname'>borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;mut </a>T</code><a class='srclink' href='../src/core/borrow.rs.html#219' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="../std/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id='impl-Any' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/any/trait.Any.html" title="trait std::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Any' class='anchor'></a><a class='srclink' href='../src/core/any.rs.html#100-102' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.type_id' class="method hidden"><code id='type_id.v'>fn <a href='../std/any/trait.Any.html#tymethod.type_id' class='fnname'>type_id</a>(&amp;self) -&gt; <a class="struct" href="../std/any/struct.TypeId.html" title="struct std::any::TypeId">TypeId</a></code><a class='srclink' href='../src/core/any.rs.html#101' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="../std/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></div><h3 id='impl-ToOwned' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/borrow/trait.ToOwned.html" title="trait std::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../std/clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a>,&nbsp;</span></code><a href='#impl-ToOwned' class='anchor'></a><a class='srclink' href='../src/alloc/borrow.rs.html#81-92' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Owned' class="type"><code id='Owned.t'>type <a href='../std/borrow/trait.ToOwned.html#associatedtype.Owned' class="type">Owned</a> = T</code></h4><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div><h4 id='method.to_owned' class="method hidden"><code id='to_owned.v'>fn <a href='../std/borrow/trait.ToOwned.html#tymethod.to_owned' class='fnname'>to_owned</a>(&amp;self) -&gt; T</code><a class='srclink' href='../src/alloc/borrow.rs.html#85-87' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Creates owned data from borrowed data, usually by cloning. <a href="../std/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div><h4 id='method.clone_into' class="method hidden"><code id='clone_into.v'>fn <a href='../std/borrow/trait.ToOwned.html#method.clone_into' class='fnname'>clone_into</a>(&amp;self, target: <a class="primitive" href="primitive.reference.html">&amp;mut </a>T)</code><a class='srclink' href='../src/alloc/borrow.rs.html#89-91' title='goto source code'>[src]</a></h4><div class='stability hidden'><div class='stab unstable'><details><summary><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/41263">#41263</a>)</summary><p>recently added</p>
</details></div></div><div class='docblock hidden'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="../std/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></div><h3 id='impl-From%3CT%3E-1' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for T</code><a href='#impl-From%3CT%3E-1' class='anchor'></a><a class='srclink' href='../src/core/convert.rs.html#553-555' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from-1' class="method hidden"><code id='from.v-1'>fn <a href='../std/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(t: T) -&gt; T</code><a class='srclink' href='../src/core/convert.rs.html#554' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-TryFrom%3CU%3E-1' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="../std/convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../std/convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryFrom%3CU%3E-1' class='anchor'></a><a class='srclink' href='../src/core/convert.rs.html#572-578' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error-2' class="type"><code id='Error.t-2'>type <a href='../std/convert/trait.TryFrom.html#associatedtype.Error' class="type">Error</a> = <a class="enum" href="../std/convert/enum.Infallible.html" title="enum std::convert::Infallible">Infallible</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_from-1' class="method hidden"><code id='try_from.v-1'>fn <a href='../std/convert/trait.TryFrom.html#tymethod.try_from' class='fnname'>try_from</a>(value: U) -&gt; <a class="enum" href="../std/result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="../std/convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="../std/convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='../src/core/convert.rs.html#575-577' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Into%3CU%3E-1' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="../std/convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../std/convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-Into%3CU%3E-1' class='anchor'></a><a class='srclink' href='../src/core/convert.rs.html#544-549' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.into-1' class="method hidden"><code id='into.v-1'>fn <a href='../std/convert/trait.Into.html#tymethod.into' class='fnname'>into</a>(self) -&gt; U</code><a class='srclink' href='../src/core/convert.rs.html#546-548' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-TryInto%3CU%3E-1' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="../std/convert/trait.TryInto.html" title="trait std::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../std/convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryInto%3CU%3E-1' class='anchor'></a><a class='srclink' href='../src/core/convert.rs.html#560-567' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error-3' class="type"><code id='Error.t-3'>type <a href='../std/convert/trait.TryInto.html#associatedtype.Error' class="type">Error</a> = &lt;U as <a class="trait" href="../std/convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="../std/convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_into-1' class="method hidden"><code id='try_into.v-1'>fn <a href='../std/convert/trait.TryInto.html#tymethod.try_into' class='fnname'>try_into</a>(self) -&gt; <a class="enum" href="../std/result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="../std/convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="../std/convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='../src/core/convert.rs.html#564-566' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Borrow%3CT%3E-1' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Borrow%3CT%3E-1' class='anchor'></a><a class='srclink' href='../src/core/borrow.rs.html#213-215' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow-1' class="method hidden"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>F</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>F</h3><code class="content"><span class="where fmt-newline">impl&lt;'_, F&gt; <a class="trait" href="../std/future/trait.Future.html" title="trait std::future::Future">Future</a> for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>F <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../std/marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> + <a class="trait" href="../std/future/trait.Future.html" title="trait std::future::Future">Future</a> + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='../std/future/trait.Future.html#associatedtype.Output' class="type">Output</a> = &lt;F as <a class="trait" href="../std/future/trait.Future.html" title="trait std::future::Future">Future</a>&gt;::<a class="type" href="../std/future/trait.Future.html#associatedtype.Output" title="type std::future::Future::Output">Output</a>;</span><span class="where fmt-newline">impl&lt;'_, I&gt; <a class="trait" href="../std/iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>I <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../std/iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='../std/iter/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &lt;I as <a class="trait" href="../std/iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a>&gt;::<a class="type" href="../std/iter/trait.Iterator.html#associatedtype.Item" title="type std::iter::Iterator::Item">Item</a>;</span><span class="where fmt-newline">impl&lt;'_, R:&nbsp;<a class="trait" href="../std/io/trait.Read.html" title="trait std::io::Read">Read</a> + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="../std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>R</span><span class="where fmt-newline">impl&lt;'_, W:&nbsp;<a class="trait" href="../std/io/trait.Write.html" title="trait std::io::Write">Write</a> + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="../std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>W</span></code></div></div><code id='borrow.v-1'>fn <a href='../std/borrow/trait.Borrow.html#tymethod.borrow' class='fnname'>borrow</a>(&amp;self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;</a>T</code><a class='srclink' href='../src/core/borrow.rs.html#214' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="../std/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id='impl-BorrowMut%3CT%3E-1' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/borrow/trait.BorrowMut.html" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-BorrowMut%3CT%3E-1' class='anchor'></a><a class='srclink' href='../src/core/borrow.rs.html#218-220' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow_mut-1' class="method hidden"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>F</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>F</h3><code class="content"><span class="where fmt-newline">impl&lt;'_, F&gt; <a class="trait" href="../std/future/trait.Future.html" title="trait std::future::Future">Future</a> for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>F <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../std/marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> + <a class="trait" href="../std/future/trait.Future.html" title="trait std::future::Future">Future</a> + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='../std/future/trait.Future.html#associatedtype.Output' class="type">Output</a> = &lt;F as <a class="trait" href="../std/future/trait.Future.html" title="trait std::future::Future">Future</a>&gt;::<a class="type" href="../std/future/trait.Future.html#associatedtype.Output" title="type std::future::Future::Output">Output</a>;</span><span class="where fmt-newline">impl&lt;'_, I&gt; <a class="trait" href="../std/iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>I <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../std/iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='../std/iter/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = &lt;I as <a class="trait" href="../std/iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a>&gt;::<a class="type" href="../std/iter/trait.Iterator.html#associatedtype.Item" title="type std::iter::Iterator::Item">Item</a>;</span><span class="where fmt-newline">impl&lt;'_, R:&nbsp;<a class="trait" href="../std/io/trait.Read.html" title="trait std::io::Read">Read</a> + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="../std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>R</span><span class="where fmt-newline">impl&lt;'_, W:&nbsp;<a class="trait" href="../std/io/trait.Write.html" title="trait std::io::Write">Write</a> + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="../std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="primitive.reference.html">&amp;'_ mut </a>W</span></code></div></div><code id='borrow_mut.v-1'>fn <a href='../std/borrow/trait.BorrowMut.html#tymethod.borrow_mut' class='fnname'>borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;mut </a>T</code><a class='srclink' href='../src/core/borrow.rs.html#219' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="../std/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id='impl-Any-1' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/any/trait.Any.html" title="trait std::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="../std/marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Any-1' class='anchor'></a><a class='srclink' href='../src/core/any.rs.html#100-102' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.type_id-1' class="method hidden"><code id='type_id.v-1'>fn <a href='../std/any/trait.Any.html#tymethod.type_id' class='fnname'>type_id</a>(&amp;self) -&gt; <a class="struct" href="../std/any/struct.TypeId.html" title="struct std::any::TypeId">TypeId</a></code><a class='srclink' href='../src/core/any.rs.html#101' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="../std/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></div><h3 id='impl-ToOwned-1' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/borrow/trait.ToOwned.html" title="trait std::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../std/clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a>,&nbsp;</span></code><a href='#impl-ToOwned-1' class='anchor'></a><a class='srclink' href='../src/alloc/borrow.rs.html#81-92' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Owned-1' class="type"><code id='Owned.t-1'>type <a href='../std/borrow/trait.ToOwned.html#associatedtype.Owned' class="type">Owned</a> = T</code></h4><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div><h4 id='method.to_owned-1' class="method hidden"><code id='to_owned.v-1'>fn <a href='../std/borrow/trait.ToOwned.html#tymethod.to_owned' class='fnname'>to_owned</a>(&amp;self) -&gt; T</code><a class='srclink' href='../src/alloc/borrow.rs.html#85-87' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Creates owned data from borrowed data, usually by cloning. <a href="../std/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div><h4 id='method.clone_into-1' class="method hidden"><code id='clone_into.v-1'>fn <a href='../std/borrow/trait.ToOwned.html#method.clone_into' class='fnname'>clone_into</a>(&amp;self, target: <a class="primitive" href="primitive.reference.html">&amp;mut </a>T)</code><a class='srclink' href='../src/alloc/borrow.rs.html#89-91' title='goto source code'>[src]</a></h4><div class='stability hidden'><div class='stab unstable'><details><summary><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/41263">#41263</a>)</summary><p>recently added</p>
</details></div></div><div class='docblock hidden'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="../std/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "std";</script><script src="../aliases1.39.0.js"></script><script src="../main1.39.0.js"></script><script defer src="../search-index1.39.0.js"></script></body></html>