initSidebarItems({"fn":[["atomic_notify","Corresponding intrinsic to wasm's [`atomic.notify` instruction][instr]"],["f32x4_abs","Calculates the absolute value of each lane of a 128-bit vector interpreted as four 32-bit floating point numbers."],["f32x4_add","Adds pairwise lanes of two 128-bit vectors interpreted as four 32-bit floating point numbers."],["f32x4_convert_i32x4_s","Converts a 128-bit vector interpreted as four 32-bit signed integers into a 128-bit vector of four 32-bit floating point numbers."],["f32x4_convert_i32x4_u","Converts a 128-bit vector interpreted as four 32-bit unsigned integers into a 128-bit vector of four 32-bit floating point numbers."],["f32x4_div","Divides pairwise lanes of two 128-bit vectors interpreted as four 32-bit floating point numbers."],["f32x4_eq","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit floating point numbers."],["f32x4_extract_lane","Extracts a lane from a 128-bit vector interpreted as 4 packed f32 numbers."],["f32x4_ge","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit floating point numbers."],["f32x4_gt","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit floating point numbers."],["f32x4_le","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit floating point numbers."],["f32x4_lt","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit floating point numbers."],["f32x4_max","Calculates the maximum of pairwise lanes of two 128-bit vectors interpreted as four 32-bit floating point numbers."],["f32x4_min","Calculates the minimum of pairwise lanes of two 128-bit vectors interpreted as four 32-bit floating point numbers."],["f32x4_mul","Multiplies pairwise lanes of two 128-bit vectors interpreted as four 32-bit floating point numbers."],["f32x4_ne","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit floating point numbers."],["f32x4_neg","Negates each lane of a 128-bit vector interpreted as four 32-bit floating point numbers."],["f32x4_replace_lane","Replaces a lane from a 128-bit vector interpreted as 4 packed f32 numbers."],["f32x4_splat","Creates a vector with identical lanes."],["f32x4_sqrt","Calculates the square root of each lane of a 128-bit vector interpreted as four 32-bit floating point numbers."],["f32x4_sub","Subtracts pairwise lanes of two 128-bit vectors interpreted as four 32-bit floating point numbers."],["f64x2_abs","Calculates the absolute value of each lane of a 128-bit vector interpreted as two 64-bit floating point numbers."],["f64x2_add","Adds pairwise lanes of two 128-bit vectors interpreted as two 64-bit floating point numbers."],["f64x2_convert_s_i64x2","Converts a 128-bit vector interpreted as two 64-bit signed integers into a 128-bit vector of two 64-bit floating point numbers."],["f64x2_convert_u_i64x2","Converts a 128-bit vector interpreted as two 64-bit unsigned integers into a 128-bit vector of two 64-bit floating point numbers."],["f64x2_div","Divides pairwise lanes of two 128-bit vectors interpreted as two 64-bit floating point numbers."],["f64x2_eq","Compares two 128-bit vectors as if they were two vectors of 2 sixty-four-bit floating point numbers."],["f64x2_extract_lane","Extracts lane from a 128-bit vector interpreted as 2 packed f64 numbers."],["f64x2_ge","Compares two 128-bit vectors as if they were two vectors of 2 sixty-four-bit floating point numbers."],["f64x2_gt","Compares two 128-bit vectors as if they were two vectors of 2 sixty-four-bit floating point numbers."],["f64x2_le","Compares two 128-bit vectors as if they were two vectors of 2 sixty-four-bit floating point numbers."],["f64x2_lt","Compares two 128-bit vectors as if they were two vectors of 2 sixty-four-bit floating point numbers."],["f64x2_max","Calculates the maximum of pairwise lanes of two 128-bit vectors interpreted as two 64-bit floating point numbers."],["f64x2_min","Calculates the minimum of pairwise lanes of two 128-bit vectors interpreted as two 64-bit floating point numbers."],["f64x2_mul","Multiplies pairwise lanes of two 128-bit vectors interpreted as two 64-bit floating point numbers."],["f64x2_ne","Compares two 128-bit vectors as if they were two vectors of 2 sixty-four-bit floating point numbers."],["f64x2_neg","Negates each lane of a 128-bit vector interpreted as two 64-bit floating point numbers."],["f64x2_replace_lane","Replaces a lane from a 128-bit vector interpreted as 2 packed f64 numbers."],["f64x2_splat","Creates a vector with identical lanes."],["f64x2_sqrt","Calculates the square root of each lane of a 128-bit vector interpreted as two 64-bit floating point numbers."],["f64x2_sub","Subtracts pairwise lanes of two 128-bit vectors interpreted as two 64-bit floating point numbers."],["i16x8_add","Adds two 128-bit vectors as if they were two packed eight 16-bit integers."],["i16x8_add_saturate_s","Adds two 128-bit vectors as if they were two packed eight 16-bit signed integers, saturating on overflow to `i16::max_value()`."],["i16x8_add_saturate_u","Adds two 128-bit vectors as if they were two packed eight 16-bit unsigned integers, saturating on overflow to `u16::max_value()`."],["i16x8_all_true","Returns 1 if all lanes are nonzero or 0 if any lane is nonzero."],["i16x8_any_true","Returns 1 if any lane is nonzero or 0 if all lanes are zero."],["i16x8_eq","Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit integers."],["i16x8_extract_lane","Extracts a lane from a 128-bit vector interpreted as 8 packed i16 numbers."],["i16x8_ge_s","Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit signed integers."],["i16x8_ge_u","Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit unsigned integers."],["i16x8_gt_s","Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit signed integers."],["i16x8_gt_u","Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit unsigned integers."],["i16x8_le_s","Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit signed integers."],["i16x8_le_u","Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit unsigned integers."],["i16x8_lt_s","Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit signed integers."],["i16x8_lt_u","Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit unsigned integers."],["i16x8_mul","Multiplies two 128-bit vectors as if they were two packed eight 16-bit signed integers."],["i16x8_ne","Compares two 128-bit vectors as if they were two vectors of 8 sixteen-bit integers."],["i16x8_neg","Negates a 128-bit vectors intepreted as eight 16-bit signed integers"],["i16x8_replace_lane","Replaces a lane from a 128-bit vector interpreted as 8 packed i16 numbers."],["i16x8_shl","Shifts each lane to the left by the specified number of bits."],["i16x8_shr_s","Shifts each lane to the right by the specified number of bits, sign extending."],["i16x8_shr_u","Shifts each lane to the right by the specified number of bits, shifting in zeros."],["i16x8_splat","Creates a vector with identical lanes."],["i16x8_sub","Subtracts two 128-bit vectors as if they were two packed eight 16-bit integers."],["i16x8_sub_saturate_s","Subtracts two 128-bit vectors as if they were two packed eight 16-bit signed integers, saturating on overflow to `i16::min_value()`."],["i16x8_sub_saturate_u","Subtracts two 128-bit vectors as if they were two packed eight 16-bit unsigned integers, saturating on overflow to 0."],["i32_atomic_wait","Corresponding intrinsic to wasm's [`i32.atomic.wait` instruction][instr]"],["i32x4_add","Adds two 128-bit vectors as if they were two packed four 32-bit integers."],["i32x4_all_true","Returns 1 if all lanes are nonzero or 0 if any lane is nonzero."],["i32x4_any_true","Returns 1 if any lane is nonzero or 0 if all lanes are zero."],["i32x4_eq","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit integers."],["i32x4_extract_lane","Extracts a lane from a 128-bit vector interpreted as 4 packed i32 numbers."],["i32x4_ge_s","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit signed integers."],["i32x4_ge_u","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit unsigned integers."],["i32x4_gt_s","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit signed integers."],["i32x4_gt_u","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit unsigned integers."],["i32x4_le_s","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit signed integers."],["i32x4_le_u","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit unsigned integers."],["i32x4_lt_s","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit signed integers."],["i32x4_lt_u","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit unsigned integers."],["i32x4_mul","Multiplies two 128-bit vectors as if they were two packed four 32-bit signed integers."],["i32x4_ne","Compares two 128-bit vectors as if they were two vectors of 4 thirty-two-bit integers."],["i32x4_neg","Negates a 128-bit vectors intepreted as four 32-bit signed integers"],["i32x4_replace_lane","Replaces a lane from a 128-bit vector interpreted as 4 packed i32 numbers."],["i32x4_shl","Shifts each lane to the left by the specified number of bits."],["i32x4_shr_s","Shifts each lane to the right by the specified number of bits, sign extending."],["i32x4_shr_u","Shifts each lane to the right by the specified number of bits, shifting in zeros."],["i32x4_splat","Creates a vector with identical lanes."],["i32x4_sub","Subtracts two 128-bit vectors as if they were two packed four 32-bit integers."],["i32x4_trunc_s_f32x4_sat","Converts a 128-bit vector interpreted as four 32-bit floating point numbers into a 128-bit vector of four 32-bit signed integers."],["i32x4_trunc_u_f32x4_sat","Converts a 128-bit vector interpreted as four 32-bit floating point numbers into a 128-bit vector of four 32-bit unsigned integers."],["i64_atomic_wait","Corresponding intrinsic to wasm's [`i64.atomic.wait` instruction][instr]"],["i64x2_add","Adds two 128-bit vectors as if they were two packed two 64-bit integers."],["i64x2_all_true","Returns 1 if all lanes are nonzero or 0 if any lane is nonzero."],["i64x2_any_true","Returns 1 if any lane is nonzero or 0 if all lanes are zero."],["i64x2_extract_lane","Extracts a lane from a 128-bit vector interpreted as 2 packed i64 numbers."],["i64x2_neg","Negates a 128-bit vectors intepreted as two 64-bit signed integers"],["i64x2_replace_lane","Replaces a lane from a 128-bit vector interpreted as 2 packed i64 numbers."],["i64x2_shl","Shifts each lane to the left by the specified number of bits."],["i64x2_shr_s","Shifts each lane to the right by the specified number of bits, sign extending."],["i64x2_shr_u","Shifts each lane to the right by the specified number of bits, shifting in zeros."],["i64x2_splat","Creates a vector with identical lanes."],["i64x2_sub","Subtracts two 128-bit vectors as if they were two packed two 64-bit integers."],["i64x2_trunc_s_f64x2_sat","Converts a 128-bit vector interpreted as two 64-bit floating point numbers into a 128-bit vector of two 64-bit signed integers."],["i64x2_trunc_u_f64x2_sat","Converts a 128-bit vector interpreted as two 64-bit floating point numbers into a 128-bit vector of two 64-bit unsigned integers."],["i8x16_add","Adds two 128-bit vectors as if they were two packed sixteen 8-bit integers."],["i8x16_add_saturate_s","Adds two 128-bit vectors as if they were two packed sixteen 8-bit signed integers, saturating on overflow to `i8::max_value()`."],["i8x16_add_saturate_u","Adds two 128-bit vectors as if they were two packed sixteen 8-bit unsigned integers, saturating on overflow to `u8::max_value()`."],["i8x16_all_true","Returns 1 if all lanes are nonzero or 0 if any lane is nonzero."],["i8x16_any_true","Returns 1 if any lane is nonzero or 0 if all lanes are zero."],["i8x16_eq","Compares two 128-bit vectors as if they were two vectors of 16 eight-bit integers."],["i8x16_extract_lane","Extracts a lane from a 128-bit vector interpreted as 16 packed i8 numbers."],["i8x16_ge_s","Compares two 128-bit vectors as if they were two vectors of 16 eight-bit signed integers."],["i8x16_ge_u","Compares two 128-bit vectors as if they were two vectors of 16 eight-bit unsigned integers."],["i8x16_gt_s","Compares two 128-bit vectors as if they were two vectors of 16 eight-bit signed integers."],["i8x16_gt_u","Compares two 128-bit vectors as if they were two vectors of 16 eight-bit unsigned integers."],["i8x16_le_s","Compares two 128-bit vectors as if they were two vectors of 16 eight-bit signed integers."],["i8x16_le_u","Compares two 128-bit vectors as if they were two vectors of 16 eight-bit unsigned integers."],["i8x16_lt_s","Compares two 128-bit vectors as if they were two vectors of 16 eight-bit signed integers."],["i8x16_lt_u","Compares two 128-bit vectors as if they were two vectors of 16 eight-bit unsigned integers."],["i8x16_mul","Multiplies two 128-bit vectors as if they were two packed sixteen 8-bit signed integers."],["i8x16_ne","Compares two 128-bit vectors as if they were two vectors of 16 eight-bit integers."],["i8x16_neg","Negates a 128-bit vectors intepreted as sixteen 8-bit signed integers"],["i8x16_replace_lane","Replaces a lane from a 128-bit vector interpreted as 16 packed i8 numbers."],["i8x16_shl","Shifts each lane to the left by the specified number of bits."],["i8x16_shr_s","Shifts each lane to the right by the specified number of bits, sign extending."],["i8x16_shr_u","Shifts each lane to the right by the specified number of bits, shifting in zeros."],["i8x16_splat","Creates a vector with identical lanes."],["i8x16_sub","Subtracts two 128-bit vectors as if they were two packed sixteen 8-bit integers."],["i8x16_sub_saturate_s","Subtracts two 128-bit vectors as if they were two packed sixteen 8-bit signed integers, saturating on overflow to `i8::min_value()`."],["i8x16_sub_saturate_u","Subtracts two 128-bit vectors as if they were two packed sixteen 8-bit unsigned integers, saturating on overflow to 0."],["memory_grow","Corresponding intrinsic to wasm's [`memory.grow` instruction][instr]"],["memory_size","Corresponding intrinsic to wasm's [`memory.size` instruction][instr]"],["unreachable","Generates the trap instruction `UNREACHABLE`"],["v128_and","Performs a bitwise and of the two input 128-bit vectors, returning the resulting vector."],["v128_bitselect","Use the bitmask in `c` to select bits from `v1` when 1 and `v2` when 0."],["v128_const","Materializes a constant SIMD value from the immediate operands."],["v128_load","Loads a `v128` vector from the given heap address."],["v128_not","Flips each bit of the 128-bit input vector."],["v128_or","Performs a bitwise or of the two input 128-bit vectors, returning the resulting vector."],["v128_store","Stores a `v128` vector to the given heap address."],["v128_xor","Performs a bitwise xor of the two input 128-bit vectors, returning the resulting vector."]],"struct":[["v128","WASM-specific 128-bit wide SIMD vector type."]]});