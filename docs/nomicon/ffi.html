<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>FFI - </title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="index.html">Introduction</a></li><li><a href="meet-safe-and-unsafe.html"><strong aria-hidden="true">1.</strong> Meet Safe and Unsafe</a></li><li><ol class="section"><li><a href="safe-unsafe-meaning.html"><strong aria-hidden="true">1.1.</strong> How Safe and Unsafe Interact</a></li><li><a href="what-unsafe-does.html"><strong aria-hidden="true">1.2.</strong> What Unsafe Can Do</a></li><li><a href="working-with-unsafe.html"><strong aria-hidden="true">1.3.</strong> Working with Unsafe</a></li></ol></li><li><a href="data.html"><strong aria-hidden="true">2.</strong> Data Layout</a></li><li><ol class="section"><li><a href="repr-rust.html"><strong aria-hidden="true">2.1.</strong> repr(Rust)</a></li><li><a href="exotic-sizes.html"><strong aria-hidden="true">2.2.</strong> Exotically Sized Types</a></li><li><a href="other-reprs.html"><strong aria-hidden="true">2.3.</strong> Other reprs</a></li></ol></li><li><a href="ownership.html"><strong aria-hidden="true">3.</strong> Ownership</a></li><li><ol class="section"><li><a href="references.html"><strong aria-hidden="true">3.1.</strong> References</a></li><li><a href="aliasing.html"><strong aria-hidden="true">3.2.</strong> Aliasing</a></li><li><a href="lifetimes.html"><strong aria-hidden="true">3.3.</strong> Lifetimes</a></li><li><a href="lifetime-mismatch.html"><strong aria-hidden="true">3.4.</strong> Limits of Lifetimes</a></li><li><a href="lifetime-elision.html"><strong aria-hidden="true">3.5.</strong> Lifetime Elision</a></li><li><a href="unbounded-lifetimes.html"><strong aria-hidden="true">3.6.</strong> Unbounded Lifetimes</a></li><li><a href="hrtb.html"><strong aria-hidden="true">3.7.</strong> Higher-Rank Trait Bounds</a></li><li><a href="subtyping.html"><strong aria-hidden="true">3.8.</strong> Subtyping and Variance</a></li><li><a href="dropck.html"><strong aria-hidden="true">3.9.</strong> Drop Check</a></li><li><a href="phantom-data.html"><strong aria-hidden="true">3.10.</strong> PhantomData</a></li><li><a href="borrow-splitting.html"><strong aria-hidden="true">3.11.</strong> Splitting Borrows</a></li></ol></li><li><a href="conversions.html"><strong aria-hidden="true">4.</strong> Type Conversions</a></li><li><ol class="section"><li><a href="coercions.html"><strong aria-hidden="true">4.1.</strong> Coercions</a></li><li><a href="dot-operator.html"><strong aria-hidden="true">4.2.</strong> The Dot Operator</a></li><li><a href="casts.html"><strong aria-hidden="true">4.3.</strong> Casts</a></li><li><a href="transmutes.html"><strong aria-hidden="true">4.4.</strong> Transmutes</a></li></ol></li><li><a href="uninitialized.html"><strong aria-hidden="true">5.</strong> Uninitialized Memory</a></li><li><ol class="section"><li><a href="checked-uninit.html"><strong aria-hidden="true">5.1.</strong> Checked</a></li><li><a href="drop-flags.html"><strong aria-hidden="true">5.2.</strong> Drop Flags</a></li><li><a href="unchecked-uninit.html"><strong aria-hidden="true">5.3.</strong> Unchecked</a></li></ol></li><li><a href="obrm.html"><strong aria-hidden="true">6.</strong> Ownership Based Resource Management</a></li><li><ol class="section"><li><a href="constructors.html"><strong aria-hidden="true">6.1.</strong> Constructors</a></li><li><a href="destructors.html"><strong aria-hidden="true">6.2.</strong> Destructors</a></li><li><a href="leaking.html"><strong aria-hidden="true">6.3.</strong> Leaking</a></li></ol></li><li><a href="unwinding.html"><strong aria-hidden="true">7.</strong> Unwinding</a></li><li><ol class="section"><li><a href="exception-safety.html"><strong aria-hidden="true">7.1.</strong> Exception Safety</a></li><li><a href="poisoning.html"><strong aria-hidden="true">7.2.</strong> Poisoning</a></li></ol></li><li><a href="concurrency.html"><strong aria-hidden="true">8.</strong> Concurrency</a></li><li><ol class="section"><li><a href="races.html"><strong aria-hidden="true">8.1.</strong> Races</a></li><li><a href="send-and-sync.html"><strong aria-hidden="true">8.2.</strong> Send and Sync</a></li><li><a href="atomics.html"><strong aria-hidden="true">8.3.</strong> Atomics</a></li></ol></li><li><a href="vec.html"><strong aria-hidden="true">9.</strong> Implementing Vec</a></li><li><ol class="section"><li><a href="vec-layout.html"><strong aria-hidden="true">9.1.</strong> Layout</a></li><li><a href="vec-alloc.html"><strong aria-hidden="true">9.2.</strong> Allocating</a></li><li><a href="vec-push-pop.html"><strong aria-hidden="true">9.3.</strong> Push and Pop</a></li><li><a href="vec-dealloc.html"><strong aria-hidden="true">9.4.</strong> Deallocating</a></li><li><a href="vec-deref.html"><strong aria-hidden="true">9.5.</strong> Deref</a></li><li><a href="vec-insert-remove.html"><strong aria-hidden="true">9.6.</strong> Insert and Remove</a></li><li><a href="vec-into-iter.html"><strong aria-hidden="true">9.7.</strong> IntoIter</a></li><li><a href="vec-raw.html"><strong aria-hidden="true">9.8.</strong> RawVec</a></li><li><a href="vec-drain.html"><strong aria-hidden="true">9.9.</strong> Drain</a></li><li><a href="vec-zsts.html"><strong aria-hidden="true">9.10.</strong> Handling Zero-Sized Types</a></li><li><a href="vec-final.html"><strong aria-hidden="true">9.11.</strong> Final Code</a></li></ol></li><li><a href="arc-and-mutex.html"><strong aria-hidden="true">10.</strong> Implementing Arc and Mutex</a></li><li><a href="ffi.html" class="active"><strong aria-hidden="true">11.</strong> FFI</a></li><li><a href="beneath-std.html"><strong aria-hidden="true">12.</strong> Beneath std</a></li><li><ol class="section"><li><a href="panic-handler.html"><strong aria-hidden="true">12.1.</strong> #[panic_handler]</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="%e5%a4%96%e9%83%a8%e5%87%bd%e6%95%b0%e6%8e%a5%e5%8f%a3">外部函数接口</h1>
<blockquote>
<p>源：<a href="https://github.com/rust-lang-nursery/nomicon/blob/master/src/ffi.md">ffi.md</a>   Commit: b3d532f55bea88bf34aae8d3b6af4c5d1ceaf31e</p>
</blockquote>
<h2 id="%e4%bb%8b%e7%bb%8d">介绍</h2>
<p>这个教程会使用<a href="https://github.com/google/snappy">snappy</a>压缩/解压缩库来介绍外部代码绑定的编写方法。Rust目前还不能直接调用C++的库，但是snappy有C的接口（文档在<code>snappy-c.h</code>中）。</p>
<h3 id="%e5%85%b3%e4%ba%8elibc%e7%9a%84%e8%af%b4%e6%98%8e">关于libc的说明</h3>
<p>接下来很多的例子会使用<a href="https://crates.io/crates/libc"><code>libc</code> crate</a>，它为我们提供了很多C类型的定义。如果你要亲自尝试一下这些例子的话，你需要把<code>libc</code>添加到你的<code>Cargo.toml</code>:</p>
<pre><code class="language-Toml"><div><span class="hljs-section">[dependencies]</span>
<span class="hljs-attr">libc</span> = <span class="hljs-string">"0.2.0"</span>
</div></code></pre>
<p>然后在你的crate的根文件插入一句<code>extern crate libc;</code></p>
<h3 id="%e8%b0%83%e7%94%a8%e5%a4%96%e9%83%a8%e5%87%bd%e6%95%b0">调用外部函数</h3>
<p>下面是一个调用外部函数的小例子，安装了snappy才能编译成功。</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> libc;
<span class="hljs-keyword">use</span> libc::size_t;

<span class="hljs-meta">#[link(name = <span class="hljs-meta-string">"snappy"</span>)]</span>
<span class="hljs-keyword">extern</span> {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">snappy_mx_compressed_length</span></span>(source_length: size_t) -&gt; size_t;
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x = <span class="hljs-keyword">unsafe</span> { snappy_max_compressed_length(<span class="hljs-number">100</span>) };
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"max compressed length of a 100 byte buffer: {}"</span>, x);
}
</div></code></pre>
<p><code>extern</code>代码块中是外部库的函数签名的列表，这个例子中使用的是平台相关的C的ABI。<code>#[link(...)]</code>属性用来构建一个链接snappy库的链接器，以便解析库中的符号(symbol)。</p>
<p>外部函数都被认为是不安全的，所以对它们的调用必须包装在<code>unsafe {}</code>中，也就是向编译器承诺块中的代码都是安全的。C的库经常暴露非线程安全的接口，而且几乎所有的接受指针参数的函数都是不合法的，因为指针可能是悬垂指针，而裸指针不符合Rust的内存安全模型。</p>
<p>在声明外部函数的参数类型时，Rust编译器不能检查声明的正确性，所以我们需要自己保证它是正确的，这也是运行期正确绑定的条件之一。</p>
<p><code>extern</code>块还可以继续扩展，包含所有的snappy API：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> libc;
<span class="hljs-keyword">use</span> libc::{c_int, size_t};

<span class="hljs-meta">#[link(name = <span class="hljs-meta-string">"snappy"</span>)]</span>
<span class="hljs-keyword">extern</span> {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">snappy_compress</span></span>(input: *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span>,
                       input_length: size_t,
                       compressed: *<span class="hljs-keyword">mut</span> <span class="hljs-built_in">u8</span>,
                       compressed_length: *<span class="hljs-keyword">mut</span> size_t) -&gt; c_int;
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">snappy_uncompress</span></span>(compressed: *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span>,
                         compressed_length: size_t,
                         uncompressed: *<span class="hljs-keyword">mut</span> <span class="hljs-built_in">u8</span>,
                         uncompressed_length: *<span class="hljs-keyword">mut</span> size_t) -&gt; c_int;
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">snappy_max_compressed_length</span></span>(source_length: size_t) -&gt; size_t;
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">snappy_uncompressed_length</span></span>(compressed: *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span>,
                                  compressed_length: size_t,
                                  result: *<span class="hljs-keyword">mut</span> size_t) -&gt; c_int;
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">snappy_validate_compressed_buffer</span></span>(compressed: *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span>,
                                         compressed_length: size_t) -&gt; c_int;
}
</div></code></pre>
<h2 id="%e5%88%9b%e5%bb%ba%e5%ae%89%e5%85%a8%e6%8e%a5%e5%8f%a3">创建安全接口</h2>
<p>原生的C API进行封装，以保证内存安全，还有使用vector等高级概念。库可以选择只暴露安全的、高级的接口，并隐藏非安全的内部细节。</p>
<p>我们使用<code>slice::raw</code>模块封装接受内存块的函数，这个模块会把Rust的vector转换为内存的指针。Rust的vector是一块连续的内存。它的长度是当前包含的元素的数量，容量是分配内存可存储的元素的总数。长度是小于等于容量的。</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">validate_compressed_buffer</span></span>(src: &amp;[<span class="hljs-built_in">u8</span>]) -&gt; <span class="hljs-built_in">bool</span> {
    <span class="hljs-keyword">unsafe</span> {
        snappy_validate_compressed_buffer(src.as_ptr(), src.len() <span class="hljs-keyword">as</span> size_t) == <span class="hljs-number">0</span>
    }
}
</div></code></pre>
<p>上方的<code>validate_compressed_buffer</code>包装器用到了<code>unsafe</code>代码块，但是函数签名里没有<code>unsafe</code>关键字，这说明它保证函数调用对所有的输入都是安全的。</p>
<p><code>snappy_compress</code>和<code>snappy_uncompress</code>函数更复杂一些，因为它们需要分配一块空间储存输出的结果。</p>
<p><code>snappy_max_compressed_length</code>函数可以用来分配一段最大容积内的vector，以保存输出的结果。这个vector可以传递给<code>snappy_compress</code>函数作为输出参数。还会传递一个输出参数获取压缩后的真实长度，以便设置返回值的长度。</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">compress</span></span>(src: &amp;[<span class="hljs-built_in">u8</span>]) -&gt; <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; {
    <span class="hljs-keyword">unsafe</span> {
        <span class="hljs-keyword">let</span> srclen = src.len() <span class="hljs-keyword">as</span> size_t;
        <span class="hljs-keyword">let</span> psrc = src.as_ptr();

        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> dstlen = snappy_max_compressed_length(srclen);
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> dst = <span class="hljs-built_in">Vec</span>::with_capacity(dstlen <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>);
        <span class="hljs-keyword">let</span> pdst = dst.as_mut_ptr();

        snappy_compress(psrc, srclen, pdst, &amp;<span class="hljs-keyword">mut</span> dstlen);
        dst.set_len(dstlen <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>);
        dst
    }
}
</div></code></pre>
<p>解压缩也是类似的，因为snappy的压缩格式中保存了未压缩时的大小，函数<code>snappy_uncompressed_length</code>可以获取需要的缓存区的尺寸。</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">uncompress</span></span>(src: &amp;[<span class="hljs-built_in">u8</span>]) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;&gt; {
    <span class="hljs-keyword">unsafe</span> {
        <span class="hljs-keyword">let</span> srclen = src.len() <span class="hljs-keyword">as</span> size_t;
        <span class="hljs-keyword">let</span> psrc = src.as_ptr();

        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> dstlen: size_t = <span class="hljs-number">0</span>;
        snappy_uncompressed_length(psrc, srclen, &amp;<span class="hljs-keyword">mut</span> dstlen);

        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> dst = <span class="hljs-built_in">Vec</span>::with_capacity(dstlen <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>);
        <span class="hljs-keyword">let</span> pdst = dst.as_mut_ptr();

        <span class="hljs-keyword">if</span> snappy_uncompress(psrc, srclen, pdst, &amp;<span class="hljs-keyword">mut</span> dstlen) == <span class="hljs-number">0</span> {
            dst.set_len(dstlen <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>);
            <span class="hljs-literal">Some</span>(dst)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-literal">None</span> <span class="hljs-comment">// SNAPPY_INVALID_INPUT</span>
        }
    }
}
</div></code></pre>
<p>接下来，我们添加一些测试用例来展示如何使用它们。</p>
<pre><code class="language-Rust"><div><span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">valid</span></span>() {
        <span class="hljs-keyword">let</span> d = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0xde</span>, <span class="hljs-number">0xad</span>, <span class="hljs-number">0xd0</span>, <span class="hljs-number">0x0d</span>];
        <span class="hljs-keyword">let</span> c: &amp;[<span class="hljs-built_in">u8</span>] = &amp;compress(&amp;d);
        <span class="hljs-built_in">assert!</span>(validate_compressed_buffer(c));
        <span class="hljs-built_in">assert!</span>(uncompress(c) == <span class="hljs-literal">Some</span>(d));
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">invalid</span></span>() {
        <span class="hljs-keyword">let</span> d = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];
        <span class="hljs-built_in">assert!</span>(!validate_compressed_buffer(&amp;d));
        <span class="hljs-built_in">assert!</span>(uncompress(&amp;d).is_none());
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">empty</span></span>() {
        <span class="hljs-keyword">let</span> d = <span class="hljs-built_in">vec!</span>[];
        <span class="hljs-built_in">assert!</span>(!validate_compressed_buffer(&amp;d));
        <span class="hljs-built_in">assert!</span>(uncompress(&amp;d).is_none());
        <span class="hljs-keyword">let</span> c = compress(&amp;d);
        <span class="hljs-built_in">assert!</span>(validate_compressed_buffer(&amp;c));
        <span class="hljs-built_in">assert!</span>(uncompress(&amp;c) == <span class="hljs-literal">Some</span>(d));
    }
}
</div></code></pre>
<h2 id="%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0">析构函数</h2>
<p>外部库经常把资源的所有权返还给调用代码。如果是这样，我们必须用Rust的析构函数保证所有的资源都被释放了（特别是在panic的情况下）。</p>
<p>更多关于析构函数的内容，请见<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">Drop trait</a>。</p>
<h2 id="c%e4%bb%a3%e7%a0%81%e5%88%b0rust%e5%87%bd%e6%95%b0%e7%9a%84%e5%9b%9e%e8%b0%83">C代码到Rust函数的回调</h2>
<p>一些外部库需要用到回调向调用者报告当前状态或者中间数据。我们是可以把Rust写的函数传递给外部库的。要求是回调函数必须标为<code>extern</code>并遵守正确的调用规范，以保证C代码可以调用它。</p>
<p>然后回调函数会通过注册调用传递给C的库，并在外部库中被触发。</p>
<p>下面是一个简单的例子。</p>
<p>Rust代码：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">extern</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">callback</span></span>(a: <span class="hljs-built_in">i32</span>) {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"I'm called from C with value {0}"</span>, a);
}

<span class="hljs-meta">#[link(name = <span class="hljs-meta-string">"extlib"</span>)]</span>
<span class="hljs-keyword">extern</span> {
   <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">register_callback</span></span>(cb: <span class="hljs-keyword">extern</span> <span class="hljs-function"><span class="hljs-keyword">fn</span></span>(<span class="hljs-built_in">i32</span>)) -&gt; <span class="hljs-built_in">i32</span>;
   <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">trigger_callback</span></span>();
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">unsafe</span> {
        register_callback(callback);
        trigger_callback(); <span class="hljs-comment">// 触发回调</span>
    }
}
</div></code></pre>
<p>C代码：</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*rust_callback)</span><span class="hljs-params">(<span class="hljs-keyword">int32_t</span>)</span></span>;
rust_callback cb;

<span class="hljs-keyword">int32_t</span> register_callback(rust_callback callback) {
    cb = callback;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trigger_callback</span><span class="hljs-params">()</span> </span>{
  cb(<span class="hljs-number">7</span>); <span class="hljs-comment">// Will call callback(7) in Rust.</span>
}
</div></code></pre>
<p>这个例子中，Rust的<code>main()</code>要调用C的<code>trigger_callback()</code>，而这个函数会反过来调用Rust中的<code>callback()</code>。</p>
<h3 id="%e5%b0%86rust%e5%af%b9%e8%b1%a1%e4%bd%9c%e4%b8%ba%e5%9b%9e%e8%b0%83">将Rust对象作为回调</h3>
<p>之前的例子演示了C代码如何调用全局函数。但是很多情况下回调也可能是一个Rust对象，比如说封装了某个C的结构体的Rust对象。</p>
<p>要实现这一点，我们可以传递一个指向这个对象的裸指针给C的库。C的库接下来可以将指针转换为Rust的对象。这样回调函数就可以非安全地访问相应的Rust对象了。</p>
<pre><code class="language-Rust"><div><span class="hljs-meta">#[repr(C)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RustObject</span></span> {
    a: <span class="hljs-built_in">i32</span>,
    <span class="hljs-comment">// 其他成员……</span>
}

<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">callback</span></span>(target: *<span class="hljs-keyword">mut</span> RustObject, a: <span class="hljs-built_in">i32</span>) {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"I'm called from C with value {0}"</span>, a);
    <span class="hljs-keyword">unsafe</span> {
        <span class="hljs-comment">// 用回调函数接收的值更新RustObject的值：</span>
        (*target).a = a;
    }
}

<span class="hljs-meta">#[link(name = <span class="hljs-meta-string">"extlib"</span>)]</span>
<span class="hljs-keyword">extern</span> {
   <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">register_callback</span></span>(target: *<span class="hljs-keyword">mut</span> RustObject,
                        cb: <span class="hljs-keyword">extern</span> <span class="hljs-function"><span class="hljs-keyword">fn</span></span>(*<span class="hljs-keyword">mut</span> RustObject, <span class="hljs-built_in">i32</span>)) -&gt; <span class="hljs-built_in">i32</span>;
   <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">trigger_callback</span></span>();
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-comment">// 创建回调用到的对象：</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> rust_object = <span class="hljs-built_in">Box</span>::new(RustObject { a: <span class="hljs-number">5</span> });

    <span class="hljs-keyword">unsafe</span> {
        register_callback(&amp;<span class="hljs-keyword">mut</span> *rust_object, callback);
        trigger_callback();
    }
}
</div></code></pre>
<p>C代码：</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*rust_callback)</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">int32_t</span>)</span></span>;
<span class="hljs-keyword">void</span>* cb_target;
rust_callback cb;

<span class="hljs-keyword">int32_t</span> register_callback(<span class="hljs-keyword">void</span>* callback_target, rust_callback callback) {
    cb_target = callback_target;
    cb = callback;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trigger_callback</span><span class="hljs-params">()</span> </span>{
  cb(cb_target, <span class="hljs-number">7</span>); <span class="hljs-comment">// 调用Rust的callback(&amp;rustObject, 7)</span>
}
</div></code></pre>
<h3 id="%e5%bc%82%e6%ad%a5%e5%9b%9e%e8%b0%83">异步回调</h3>
<p>上面给出的例子里，回调都是外部C库的直接的函数调用。当前线程的控制权从Rust转移到C再转移回Rust，不过最终回调都是在调用触发回调的函数的线程里执行的。</p>
<p>如果外部库启动了自己的线程，并在那个线程里调用回调函数，情况就变得复杂了。这时再访问回调中的Rust数据结构是非常不安全的，必须使用正常地同步机制。除了Mutex等传统的同步机制，还有另一个选项就是使用channel（在<code>std::sync::mpsc</code>中）将数据从触发回调的C线程传送给一个Rust线程。</p>
<p>如果一个异步回调使用了一个Rust地址空间里的对象，一定要注意，在这个对象销毁之后C的库不能再调用任何的回调。我们可以在对象的析构函数里注销回调，并且重新设计库确保毁掉注销后就不会被调用了。</p>
<h2 id="%e9%93%be%e6%8e%a5">链接</h2>
<p><code>extern</code>代码块上的<code>link</code>属性用于指导rustc如何链接到一个本地的库。现在<code>link</code>属性有两种可用的形式：</p>
<ul>
<li><code>#[link(name = &quot;foo&quot;)]</code></li>
<li><code>#[link(name = &quot;foo&quot;, kind = &quot;bar&quot;)]</code></li>
</ul>
<p>两种形式中，<code>foo</code>都是我们要链接的本地库的名字。而第二种形式中的<code>bar</code>是要链接的本地库的类型。目前有三种已知的本地库类型：</p>
<ul>
<li>动态 - <code>#[link(name = &quot;readline&quot;)]</code></li>
<li>静态 - <code>#[link(name = &quot;my_build_dependency&quot;, kind = &quot;static&quot;)]</code></li>
<li>框架 - <code>#[link(name = &quot;CoreFundation&quot;, kind = &quot;framework&quot;)]</code></li>
</ul>
<p>注意，框架只适用于MacOS平台。</p>
<p>不同的<code>kind</code>表明本地库以不同的方式参与链接。从链接器的角度看，Rust编译器产生两种输出结果：部分结果(rlib/staticlib)和最终结果(dylib/binary)。本地动态库和框架依赖可以被最终结果使用，而静态库则不会，因为静态库是直接集成在接下来的输出里的。</p>
<p>举几个这个模型用法的例子：</p>
<ul>
<li>
<p>本地构建依赖。有时候编写Rust代码需要一些C/C++作为补充，但是把C/C++代码以一个库的形式发布却不容易。这种情况下，代码应该包装在<code>libfoo.a</code>中，然后Rust的crate会声明一个依赖<code>#[link(name = &quot;foo&quot;, kind = &quot;static&quot;)]</code>。
不管crate最终以哪种形式输出，本地静态库都会被包含在输出中，这表明发布静态库并不必要。</p>
</li>
<li>
<p>普通动态库。通用的系统库（比如<code>readline</code>）在许多系统中都支持，而我们经常遇到找不到库的本地备份的的情况。如果这样的依赖被包含在Rust的crate中，部分结果（比如rlib）不会链接到这个库中。但是如果rlib被最终结果包含了，本地库也会被链接。</p>
</li>
</ul>
<p>在MacOS中，框架和动态库具有相同的语义。</p>
<h2 id="%e9%9d%9e%e5%ae%89%e5%85%a8%e4%bb%a3%e7%a0%81%e5%9d%97">非安全代码块</h2>
<p>有一些操作，比如解引用裸指针、或者调用被标为unsafe的函数，它们只能存在于非安全代码块中。非安全代码块隔离了非安全性，并向编译器承诺非安全性不会影响到块以外的代码。</p>
<p>非安全函数则不同，它们声明非安全性一定会影响到函数之外。一个非安全函数写法如下：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">kaboom</span></span>(ptr: *<span class="hljs-keyword">const</span> <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> { *ptr }
</div></code></pre>
<p>这个函数只能在<code>unsafe</code>代码块或者另外一个<code>unsafe</code>函数里被调用。</p>
<h2 id="%e8%ae%bf%e9%97%ae%e5%a4%96%e9%83%a8%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f">访问外部全局变量</h2>
<p>外部API经常暴露一些全局变量，用于记录全局状态等。为了访问这些变量，你需要在<code>extern</code>块中用<code>static</code>关键字声明它们：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> libc;

<span class="hljs-meta">#[link(name = <span class="hljs-meta-string">"readline"</span>)]</span>
<span class="hljs-keyword">extern</span> {
    <span class="hljs-keyword">static</span> rl_readline_version: libc::c_int;
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"You have readline version {} installed."</span>,
             <span class="hljs-keyword">unsafe</span> { rl_readline_version <span class="hljs-keyword">as</span> <span class="hljs-built_in">i32</span> });
}
</div></code></pre>
<p>有时也可能需要通过外部的接口修改全局状态。如果要这么做，静态变量还要添加<code>mut</code>，让我们可以修改它们。</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> libc;

<span class="hljs-keyword">use</span> std::ffi::CString;
<span class="hljs-keyword">use</span> std::ptr;

<span class="hljs-meta">#[link(name = <span class="hljs-meta-string">"readline"</span>)]</span>
<span class="hljs-keyword">extern</span> {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> rl_prompt: *<span class="hljs-keyword">const</span> libc::c_char;
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> prompt = CString::new(<span class="hljs-string">"[my-awesome-shell] $"</span>).unwrap();
    <span class="hljs-keyword">unsafe</span> {
        rl_prompt = prompt.as_ptr();

        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, rl_prompt);

        rl_prompt = ptr::null();
    }
}
</div></code></pre>
<p>注意，所有和<code>static mut</code>的操作都是非安全的，不管是读还是写。处理全局可变状态的时候一定要格外的小心。</p>
<h2 id="%e5%a4%96%e9%83%a8%e8%b0%83%e7%94%a8%e8%a7%84%e8%8c%83">外部调用规范</h2>
<p>大多数外部代码都暴露C的ABI，而Rust默认根据平台相关的C的调用规范调用外部函数。还有一些外部函数使用其他的规范，最典型的就是WindowsAPI。Rust也有方法告诉编译器使用哪种规范：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> libc;

<span class="hljs-meta">#[cfg(all(target_os = <span class="hljs-meta-string">"win32"</span>, target_arch = <span class="hljs-meta-string">"x86"</span>))]</span>
<span class="hljs-meta">#[link(name = <span class="hljs-meta-string">"kernel32"</span>)]</span>
<span class="hljs-meta">#[allow(non_snake_case)]</span>
<span class="hljs-keyword">extern</span> <span class="hljs-string">"stdcall"</span> {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">SetEnvironmentVariableA</span></span>(n: *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span>, v: *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span>) -&gt; libc::c_int;
}
</div></code></pre>
<p>这段代码作用于整个<code>extern</code>代码块。支持的ABI包括：</p>
<ul>
<li><code>stdcall</code></li>
<li><code>appcs</code></li>
<li><code>cdecl</code></li>
<li><code>fastcall</code></li>
<li><code>vectorcall</code> 这个目前被<code>abi_vectorcall</code>隐藏着，不允许修改。</li>
<li><code>Rust</code></li>
<li><code>rust-intrinsic</code></li>
<li><code>system</code></li>
<li><code>C</code></li>
<li><code>win64</code></li>
<li><code>sysv64</code></li>
</ul>
<p>列表中所有的abi都是自解释的，但是<code>system</code>可能会显得有些奇怪。它的意思是选择一个合适的与目标库通信的ABI。比如，在win32的x86架构上，它实际使用的是<code>stdcall</code>。而在x86_64上，Windows使用<code>C</code>调用规范，所以它实际使用的是<code>C</code>。这意味着在我们之前的例子中，我们可以使用<code>extern &quot;system&quot; { ... }</code>为所有的Windows系统定义块，而不仅仅是x86的平台。</p>
<h2 id="%e4%b8%8e%e5%a4%96%e9%83%a8%e4%bb%a3%e7%a0%81%e4%ba%92%e7%94%a8%e6%80%a7">与外部代码互用性</h2>
<p>只有给一个结构体指定了<code>#[repr(C)]</code>，Rust才保证结构体的布局与平台的C的表示方法相兼容。<code>#[repr(C, packed)]</code>可以让结构体成员之间无填充。<code>#[repr(C)]</code>也可以作用于枚举类型。</p>
<p>Rust的<code>Box&lt;T&gt;</code>用一个非空的指针指向它包含的对象。但是，这些指针不能手工创建，而是要由内部分配器去管理。引用可以安全地等同于非空指针。不过，违背借用检查和可变性规则就不能保证是安全的了，所以在需要使用指针的地方我们尽量使用裸指针，因为编译器不会对它做过多的限制。</p>
<p>Vector和String拥有相同的内存布局，而且<code>vec</code>和<code>str</code>模块里也有一些与C API相关的工具。但是，字符串不是以<code>\0</code>结尾的。如果你想要一个与C兼容的Null结尾的字符串，你应该使用<code>std::ffi</code>模块中的<code>CString</code>类型。</p>
<p>[crate.io的<code>libc</code> crate]<code>(https://crates.io/crates/libc)在</code>libc<code>模块中包含了C标准库的类型别名和函数定义，而Rust默认链接</code>libc<code>和</code>libm`。</p>
<h2 id="%e5%8f%af%e5%8f%98%e5%87%bd%e6%95%b0">可变函数</h2>
<p>在C中，函数可以是“可变的”，也就是说可以接收可变数量的参数。在Rust中可以在外部函数声明的参数类表中插入<code>...</code>实现这一点：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">extern</span> {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(x: <span class="hljs-built_in">i32</span>, ...);
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">unsafe</span> {
        foo(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>);
    }
}
</div></code></pre>
<p>普通的Rust函数不能是可变的：</p>
<pre><code class="language-Rust"><div><span class="hljs-comment">// 这段不能通过编译</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(x: <span class="hljs-built_in">i32</span>, ...) { }
</div></code></pre>
<h2 id="%e7%a9%ba%e6%8c%87%e9%92%88%e4%bc%98%e5%8c%96">空指针优化</h2>
<p>一些Rust类型被定义为永不为<code>null</code>，包括引用（<code>&amp;T</code>、<code>&amp;mut T</code>）、<code>Box&lt;T&gt;</code>、以及函数指针（<code>extern &quot;abi&quot; fn()</code>）。可是在使用C的接口时，指针是经常可能为<code>null</code>的。看起来似乎需要用到<code>transmute</code>或者非安全代码来处理各种混乱的类型转换。但是，Rust其实提供了另外的方法。</p>
<p>一些特殊情况中，<code>enum</code>很适合做空指针优化，只要它包含两个变量，其中一个不包含数据，而另外一个包含一个非空类型的成员。这样就不需要额外的空间做判断了：给那个包含非空成员的变量传递一个<code>null</code>，用它来表示另外那个空的变量。这种行为虽然被叫做“优化”，但是和其他的优化不同，它只适用于合适的类型。</p>
<p>最常见的受益于空指针优化的类型是<code>Option&lt;T&gt;</code>，其中<code>None</code>可以用<code>null</code>表示。所以<code>Option&lt;extern &quot;C&quot; fn(c_int) - &gt; c_int&gt;</code>就很适合表示一个使用C ABI的可为空的函数指针（对应于C的<code>int (*)(int)</code>）。</p>
<p>下面是一个刻意造出来的例子。假设一些C的库提供了注册回调的方法，然后在特定的条件下调用回调。回调接受一个函数指针和一个整数，然后用这个整数作为参数调用指针指向的函数。所以我们会向FFI边界的两侧都传递函数指针。</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> libc;
<span class="hljs-keyword">use</span> libc::c_int;

<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> {
    <span class="hljs-comment">// 注册回调。</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">register</span></span>(cb: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">fn</span></span>(<span class="hljs-built_in">Option</span>&lt;<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">fn</span></span>(c_int) -&gt; c_int&gt;, c_int) -&gt; c_int&gt;);
}

<span class="hljs-comment">// 这个函数其实没什么实际的用处。它从C代码接受一个函数指针和一个整数，</span>
<span class="hljs-comment">// 用整数做参数调用指针指向的函数，并返回函数的返回值。</span>
<span class="hljs-comment">// 如果没有指定函数，那默认就返回整数的平方。</span>
<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">apply</span></span>(process: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">fn</span></span>(c_int) -&gt; c_int&gt;, int: c_int) -&gt; c_int {
    <span class="hljs-keyword">match</span> process {
        <span class="hljs-literal">Some</span>(f) =&gt; f(int),
        <span class="hljs-literal">None</span>    =&gt; int * int
    }
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">unsafe</span> {
        register(<span class="hljs-literal">Some</span>(apply));
    }
}
</div></code></pre>
<p>C的代码是像这样的：</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(<span class="hljs-keyword">void</span> (*f)(<span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">int</span>), <span class="hljs-keyword">int</span>))</span> </span>{
    ...
}
</div></code></pre>
<p>看，并不需要<code>transmute</code>！</p>
<h2 id="c%e8%b0%83%e7%94%a8rust">C调用Rust</h2>
<p>你可能想要用某种方式编译Rust，让C可以直接调用它。这件事很简单，只需要做少数的处理：</p>
<pre><code class="language-Rust"><div><span class="hljs-meta">#[no_mangle]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">extern</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">hello_rust</span></span>() -&gt; *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span> {
    <span class="hljs-string">"Hello, world!\0"</span>.as_ptr()
}
</div></code></pre>
<p><code>extern</code>让它对应的函数符合C的调用规范，在上面的<a href="https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions">外部调用规范</a>一节有详细讨论。<code>no_mangle</code>属性关闭Rust的name mangling，让它更方便被链接。</p>
<h2 id="ffi%e5%92%8cpanic">FFI和panic</h2>
<p>使用FFI的时候要格外注意<code>panic!</code>。跨越FFI边界的<code>panic!</code>属于未定义行为。如果你写的代码可能会panic，你应该使用<code>catch_unwind</code>在一个闭包里执行它：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">use</span> std::panic::catch_unwind;

<span class="hljs-meta">#[no_mangle]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">extern</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">oh_no</span></span>() -&gt; <span class="hljs-built_in">i32</span> {
    <span class="hljs-keyword">let</span> result = catch_unwind(|| {
        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"Oops!"</span>);
    });
    <span class="hljs-keyword">match</span> result {
        <span class="hljs-literal">Ok</span>(_) =&gt; <span class="hljs-number">0</span>,
        <span class="hljs-literal">Err</span>(_) =&gt; <span class="hljs-number">1</span>,
    }
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {}
</div></code></pre>
<p>请注意，<code>catch_unwind</code>只能捕获可展开的panic，不能捕获abort。更多的信息请参考<code>catch_unwind</code>的文档。</p>
<h2 id="%e8%a1%a8%e7%a4%ba%e4%b8%8d%e9%80%8f%e6%98%8e%e7%bb%93%e6%9e%84%e4%bd%93">表示不透明结构体</h2>
<p>有时候，C的库要提供一个指针指向某个东西，但又不想让你知道那个东西的内部细节。最简单的方式是使用<code>void *</code>：</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span>;
</div></code></pre>
<p>在Rust中我们可以用<code>c_void</code>类型表示它：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> libc;

<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(arg: *<span class="hljs-keyword">mut</span> libc::c_void);
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bar</span></span>(arg: *<span class="hljs-keyword">mut</span> libc::c_void);
}
</div></code></pre>
<p>这是一个完全合法的方法。不过，我们其实还可以做得更好。要解决这个问题，一些C库可能会创建一个结构体，可结构体的细节和内存布局是私有的。这样提高了类型的安全性。这种结构体被称为”不透明“的。下面是一个C的例子：</p>
<pre><code class="language-C"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span>;</span> <span class="hljs-comment">/* Foo是一个接口，但它的内容不属于公共接口 */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Bar</span>;</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(struct Foo *arg)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(struct Bar *arg)</span></span>;
</div></code></pre>
<p>在Rust中，我们可以使用枚举来创建我们自己的不透明类型：</p>
<pre><code class="language-Rust"><div><span class="hljs-meta">#[repr(C)]</span> <span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span> { _private: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">0</span>] }
<span class="hljs-meta">#[repr(C)]</span> <span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Bar</span></span> { _private: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">0</span>] }

<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(arg: *<span class="hljs-keyword">mut</span> Foo);
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bar</span></span>(arg: *<span class="hljs-keyword">mut</span> Bar);
}
# <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {}
</div></code></pre>
<p>给结构体一个私有成员而不给它构造函数，这样我们就创建了一个不透明的类型，而且我们不能在模块之外实例化它。（没有成员的结构体可以在任何地方实例化）因为我们希望在FFI中使用这个类型，我们必须加上<code>#[repr(C)]</code>。还为了避免在FFI中使用<code>()</code>的时候出现警告，我们用了一个空数组。空数组和空类型的行为一致，同时它还是FFI兼容的。</p>
<p>但因为<code>Foo</code>和<code>Bar</code>是不同的类型，我们需要保证两者之间的类型安全性，所以我们不能把<code>Foo</code>的指针传递给<code>bar()</code>。</p>
<p>注意，用空枚举作为FFI类型是一个很不好的设计。编译器将空枚举视为不可达的空类型，所以使用<code>&amp;Empty</code>类型的值是很危险的，这可能导致很多程序中的问题（触发未定义行为）。</p>


                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="arc-and-mutex.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="beneath-std.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="arc-and-mutex.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="beneath-std.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
