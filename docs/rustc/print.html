<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The rustc book</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="what-is-rustc.html"><strong aria-hidden="true">1.</strong> What is rustc?</a></li><li><a href="command-line-arguments.html"><strong aria-hidden="true">2.</strong> Command-line arguments</a></li><li><a href="lints/index.html"><strong aria-hidden="true">3.</strong> Lints</a></li><li><ol class="section"><li><a href="lints/levels.html"><strong aria-hidden="true">3.1.</strong> Lint levels</a></li><li><a href="lints/groups.html"><strong aria-hidden="true">3.2.</strong> Lint Groups</a></li><li><a href="lints/listing/index.html"><strong aria-hidden="true">3.3.</strong> Lint listing</a></li><li><ol class="section"><li><a href="lints/listing/allowed-by-default.html"><strong aria-hidden="true">3.3.1.</strong> Allowed-by-default lints</a></li><li><a href="lints/listing/warn-by-default.html"><strong aria-hidden="true">3.3.2.</strong> Warn-by-default lints</a></li><li><a href="lints/listing/deny-by-default.html"><strong aria-hidden="true">3.3.3.</strong> Deny-by-default lints</a></li></ol></li></ol></li><li><a href="codegen-options/index.html"><strong aria-hidden="true">4.</strong> Codegen options</a></li><li><a href="targets/index.html"><strong aria-hidden="true">5.</strong> Targets</a></li><li><ol class="section"><li><a href="targets/built-in.html"><strong aria-hidden="true">5.1.</strong> Built-in Targets</a></li><li><a href="targets/custom.html"><strong aria-hidden="true">5.2.</strong> Custom Targets</a></li></ol></li><li><a href="profile-guided-optimization.html"><strong aria-hidden="true">6.</strong> Profile-guided Optimization</a></li><li><a href="linker-plugin-lto.html"><strong aria-hidden="true">7.</strong> Linker-plugin based LTO</a></li><li><a href="contributing.html"><strong aria-hidden="true">8.</strong> Contributing to rustc</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The rustc book</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#what-is-rustc" id="what-is-rustc">What is rustc?</a></h1>
<p>Welcome to &quot;The rustc book&quot;! <code>rustc</code> is the compiler for the Rust programming
language, provided by the project itself. Compilers take your source code and
produce binary code, either as a library or executable.</p>
<p>Most Rust programmers don't invoke <code>rustc</code> directly, but instead do it through
<a href="../cargo/index.html">Cargo</a>. It's all in service of <code>rustc</code> though! If you
want to see how Cargo calls <code>rustc</code>, you can</p>
<pre><code class="language-bash">$ cargo build --verbose
</code></pre>
<p>And it will print out each <code>rustc</code> invocation. This book can help you
understand what each of these options does. Additionally, while most
Rustaceans use Cargo, not all do: sometimes they integrate <code>rustc</code> into other
build systems. This book should provide a guide to all of the options you'd
need to do so.</p>
<h2><a class="header" href="#basic-usage" id="basic-usage">Basic usage</a></h2>
<p>Let's say you've got a little hello world program in a file <code>hello.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>To turn this source code into an executable, you can use <code>rustc</code>:</p>
<pre><code class="language-bash">$ rustc hello.rs
$ ./hello # on a *NIX
$ .\hello.exe # on Windows
</code></pre>
<p>Note that we only ever pass <code>rustc</code> the <em>crate root</em>, not every file we wish
to compile. For example, if we had a <code>main.rs</code> that looked like this:</p>
<pre><code class="language-rust ignore">mod foo;

fn main() {
    foo::hello();
}
</code></pre>
<p>And a <code>foo.rs</code> that had this:</p>
<pre><code class="language-rust ignore">pub fn hello() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre>
<p>To compile this, we'd run this command:</p>
<pre><code class="language-bash">$ rustc main.rs
</code></pre>
<p>No need to tell <code>rustc</code> about <code>foo.rs</code>; the <code>mod</code> statements give it
everything that it needs. This is different than how you would use a C
compiler, where you invoke the compiler on each file, and then link
everything together. In other words, the <em>crate</em> is a translation unit, not a
particular module.</p>
<h1><a class="header" href="#command-line-arguments" id="command-line-arguments">Command-line arguments</a></h1>
<p>Here's a list of command-line arguments to <code>rustc</code> and what they do.</p>
<h2><a class="header" href="#-h--help-get-help" id="-h--help-get-help"><code>-h</code>/<code>--help</code>: get help</a></h2>
<p>This flag will print out help information for <code>rustc</code>.</p>
<h2><a class="header" href="#--cfg-configure-the-compilation-environment" id="--cfg-configure-the-compilation-environment"><code>--cfg</code>: configure the compilation environment</a></h2>
<p>This flag can turn on or off various <code>#[cfg]</code> settings.</p>
<p>The value can either be a single identifier or two identifiers separated by <code>=</code>.</p>
<p>For examples, <code>--cfg 'verbose'</code> or <code>--cfg 'feature=&quot;serde&quot;'</code>. These correspond
to <code>#[cfg(verbose)]</code> and <code>#[cfg(feature = &quot;serde&quot;)]</code> respectively.</p>
<h2><a class="header" href="#-l-add-a-directory-to-the-library-search-path" id="-l-add-a-directory-to-the-library-search-path"><code>-L</code>: add a directory to the library search path</a></h2>
<p>When looking for external crates or libraries, a directory passed to this flag
will be searched.</p>
<p>The kind of search path can optionally be specified with the form <code>-L KIND=PATH</code> where <code>KIND</code> may be one of:</p>
<ul>
<li><code>dependency</code> — Only search for transitive dependencies in this directory.</li>
<li><code>crate</code> — Only search for this crate's direct dependencies in this
directory.</li>
<li><code>native</code> — Only search for native libraries in this directory.</li>
<li><code>framework</code> — Only search for macOS frameworks in this directory.</li>
<li><code>all</code> — Search for all library kinds in this directory. This is the default
if <code>KIND</code> is not specified.</li>
</ul>
<h2><a class="header" href="#-l-link-the-generated-crate-to-a-native-library" id="-l-link-the-generated-crate-to-a-native-library"><code>-l</code>: link the generated crate to a native library</a></h2>
<p>This flag allows you to specify linking to a specific native library when building
a crate.</p>
<p>The kind of library can optionally be specified with the form <code>-l KIND=lib</code>
where <code>KIND</code> may be one of:</p>
<ul>
<li><code>dylib</code> — A native dynamic library.</li>
<li><code>static</code> — A native static library (such as a <code>.a</code> archive).</li>
<li><code>framework</code> — A macOS framework.</li>
</ul>
<p>The kind of library can be specified in a <a href="../reference/items/external-blocks.html#the-link-attribute"><code>#[link]</code>
attribute</a>. If the kind is not specified in the <code>link</code>
attribute or on the command-line, it will link a dynamic library if available,
otherwise it will use a static library. If the kind is specified on the
command-line, it will override the kind specified in a <code>link</code> attribute.</p>
<p>The name used in a <code>link</code> attribute may be overridden using the form <code>-l ATTR_NAME:LINK_NAME</code> where <code>ATTR_NAME</code> is the name in the <code>link</code> attribute,
and <code>LINK_NAME</code> is the name of the actual library that will be linked.</p>
<h2><a class="header" href="#--crate-type-a-list-of-types-of-crates-for-the-compiler-to-emit" id="--crate-type-a-list-of-types-of-crates-for-the-compiler-to-emit"><code>--crate-type</code>: a list of types of crates for the compiler to emit</a></h2>
<p>This instructs <code>rustc</code> on which crate type to build. This flag accepts a
comma-separated list of values, and may be specified multiple times. The valid
crate types are:</p>
<ul>
<li><code>lib</code> — Generates a library kind preferred by the compiler, currently
defaults to <code>rlib</code>.</li>
<li><code>rlib</code> — A Rust static library.</li>
<li><code>staticlib</code> — A native static library.</li>
<li><code>dylib</code> — A Rust dynamic library.</li>
<li><code>cdylib</code> — A native dynamic library.</li>
<li><code>bin</code> — A runnable executable program.</li>
<li><code>proc-macro</code> — Generates a format suitable for a procedural macro library
that may be loaded by the compiler.</li>
</ul>
<p>The crate type may be specified with the <a href="../reference/linkage.html"><code>crate_type</code> attribute</a>.
The <code>--crate-type</code> command-line value will override the <code>crate_type</code>
attribute.</p>
<p>More details may be found in the <a href="../reference/linkage.html">linkage chapter</a> of the reference.</p>
<h2><a class="header" href="#--crate-name-specify-the-name-of-the-crate-being-built" id="--crate-name-specify-the-name-of-the-crate-being-built"><code>--crate-name</code>: specify the name of the crate being built</a></h2>
<p>This informs <code>rustc</code> of the name of your crate.</p>
<h2><a class="header" href="#--edition-specify-the-edition-to-use" id="--edition-specify-the-edition-to-use"><code>--edition</code>: specify the edition to use</a></h2>
<p>This flag takes a value of <code>2015</code> or <code>2018</code>. The default is <code>2015</code>. More
information about editions may be found in the <a href="../edition-guide/introduction.html">edition guide</a>.</p>
<h2><a class="header" href="#--emit-specifies-the-types-of-output-files-to-generate" id="--emit-specifies-the-types-of-output-files-to-generate"><code>--emit</code>: specifies the types of output files to generate</a></h2>
<p>This flag controls the types of output files generated by the compiler. It
accepts a comma-separated list of values, and may be specified multiple times.
The valid emit kinds are:</p>
<ul>
<li><code>asm</code> — Generates a file with the crate's assembly code. The default output
filename is <code>CRATE_NAME.s</code>.</li>
<li><code>dep-info</code> — Generates a file with Makefile syntax that indicates all the
source files that were loaded to generate the crate. The default output
filename is <code>CRATE_NAME.d</code>.</li>
<li><code>link</code> — Generates the crates specified by <code>--crate-type</code>. The default
output filenames depend on the crate type and platform. This is the default
if <code>--emit</code> is not specified.</li>
<li><code>llvm-bc</code> — Generates a binary file containing the <a href="https://llvm.org/docs/BitCodeFormat.html">LLVM bitcode</a>. The
default output filename is <code>CRATE_NAME.bc</code>.</li>
<li><code>llvm-ir</code> — Generates a file containing <a href="https://llvm.org/docs/LangRef.html">LLVM IR</a>. The default output
filename is <code>CRATE_NAME.ll</code>.</li>
<li><code>metadata</code> — Generates a file containing metadata about the crate. The
default output filename is <code>CRATE_NAME.rmeta</code>.</li>
<li><code>mir</code> — Generates a file containing rustc's mid-level intermediate
representation. The default output filename is <code>CRATE_NAME.mir</code>.</li>
<li><code>obj</code> — Generates a native object file. The default output filename is
<code>CRATE_NAME.o</code>.</li>
</ul>
<p>The output filename can be set with the <code>-o</code> flag. A suffix may be added to
the filename with the <code>-C extra-filename</code> flag. The files are written to the
current directory unless the <code>--out-dir</code> flag is used. Each emission type may
also specify the output filename with the form <code>KIND=PATH</code>, which takes
precedence over the <code>-o</code> flag.</p>
<h2><a class="header" href="#--print-print-compiler-information" id="--print-print-compiler-information"><code>--print</code>: print compiler information</a></h2>
<p>This flag prints out various information about the compiler. This flag may be
specified multiple times, and the information is printed in the order the
flags are specified. Specifying a <code>--print</code> flag will usually disable the
<code>--emit</code> step and will only print the requested information. The valid types
of print values are:</p>
<ul>
<li><code>crate-name</code> — The name of the crate.</li>
<li><code>file-names</code> — The names of the files created by the <code>link</code> emit kind.</li>
<li><code>sysroot</code> — Path to the sysroot.</li>
<li><code>cfg</code> — List of cfg values. See <a href="../reference/conditional-compilation.html">conditional compilation</a> for more
information about cfg values.</li>
<li><code>target-list</code> — List of known targets. The target may be selected with the
<code>--target</code> flag.</li>
<li><code>target-cpus</code> — List of available CPU values for the current target. The
target CPU may be selected with the <code>-C target-cpu=val</code> flag.</li>
<li><code>target-features</code> — List of available target features for the current
target. Target features may be enabled with the <code>-C target-feature=val</code>
flag.</li>
<li><code>relocation-models</code> — List of relocation models. Relocation models may be
selected with the <code>-C relocation-model=val</code> flag.</li>
<li><code>code-models</code> — List of code models. Code models may be selected with the
<code>-C code-model=val</code> flag.</li>
<li><code>tls-models</code> — List of Thread Local Storage models supported. The model may
be selected with the <code>-Z tls-model=val</code> flag.</li>
<li><code>native-static-libs</code> — This may be used when creating a <code>staticlib</code> crate
type. If this is the only flag, it will perform a full compilation and
include a diagnostic note that indicates the linker flags to use when
linking the resulting static library. The note starts with the text
<code>native-static-libs:</code> to make it easier to fetch the output.</li>
</ul>
<h2><a class="header" href="#-g-include-debug-information" id="-g-include-debug-information"><code>-g</code>: include debug information</a></h2>
<p>A synonym for <code>-C debuginfo=2</code>, for more see <a href="codegen-options/index.html#debuginfo">here</a>.</p>
<h2><a class="header" href="#-o-optimize-your-code" id="-o-optimize-your-code"><code>-O</code>: optimize your code</a></h2>
<p>A synonym for <code>-C opt-level=2</code>, for more see <a href="codegen-options/index.html#opt-level">here</a>.</p>
<h2><a class="header" href="#-o-filename-of-the-output" id="-o-filename-of-the-output"><code>-o</code>: filename of the output</a></h2>
<p>This flag controls the output filename.</p>
<h2><a class="header" href="#--out-dir-directory-to-write-the-output-in" id="--out-dir-directory-to-write-the-output-in"><code>--out-dir</code>: directory to write the output in</a></h2>
<p>The outputted crate will be written to this directory. This flag is ignored if
the <code>-o</code> flag is used.</p>
<h2><a class="header" href="#--explain-provide-a-detailed-explanation-of-an-error-message" id="--explain-provide-a-detailed-explanation-of-an-error-message"><code>--explain</code>: provide a detailed explanation of an error message</a></h2>
<p>Each error of <code>rustc</code>'s comes with an error code; this will print
out a longer explanation of a given error.</p>
<h2><a class="header" href="#--test-build-a-test-harness" id="--test-build-a-test-harness"><code>--test</code>: build a test harness</a></h2>
<p>When compiling this crate, <code>rustc</code> will ignore your <code>main</code> function
and instead produce a test harness.</p>
<h2><a class="header" href="#--target-select-a-target-triple-to-build" id="--target-select-a-target-triple-to-build"><code>--target</code>: select a target triple to build</a></h2>
<p>This controls which <a href="targets/index.html">target</a> to produce.</p>
<h2><a class="header" href="#-w-set-lint-warnings" id="-w-set-lint-warnings"><code>-W</code>: set lint warnings</a></h2>
<p>This flag will set which lints should be set to the <a href="lints/levels.html#warn">warn level</a>.</p>
<h2><a class="header" href="#-a-set-lint-allowed" id="-a-set-lint-allowed"><code>-A</code>: set lint allowed</a></h2>
<p>This flag will set which lints should be set to the <a href="lints/levels.html#allow">allow level</a>.</p>
<h2><a class="header" href="#-d-set-lint-denied" id="-d-set-lint-denied"><code>-D</code>: set lint denied</a></h2>
<p>This flag will set which lints should be set to the <a href="lints/levels.html#deny">deny level</a>.</p>
<h2><a class="header" href="#-f-set-lint-forbidden" id="-f-set-lint-forbidden"><code>-F</code>: set lint forbidden</a></h2>
<p>This flag will set which lints should be set to the <a href="lints/levels.html#forbid">forbid level</a>.</p>
<h2><a class="header" href="#-z-set-unstable-options" id="-z-set-unstable-options"><code>-Z</code>: set unstable options</a></h2>
<p>This flag will allow you to set unstable options of rustc. In order to set multiple options,
the -Z flag can be used multiple times. For example: <code>rustc -Z verbose -Z time</code>.
Specifying options with -Z is only available on nightly. To view all available options
run: <code>rustc -Z help</code>.</p>
<h2><a class="header" href="#--cap-lints-set-the-most-restrictive-lint-level" id="--cap-lints-set-the-most-restrictive-lint-level"><code>--cap-lints</code>: set the most restrictive lint level</a></h2>
<p>This flag lets you 'cap' lints, for more, <a href="lints/levels.html#capping-lints">see here</a>.</p>
<h2><a class="header" href="#-c--codegen-code-generation-options" id="-c--codegen-code-generation-options"><code>-C</code>/<code>--codegen</code>: code generation options</a></h2>
<p>This flag will allow you to set <a href="codegen-options/index.html">codegen options</a>.</p>
<h2><a class="header" href="#-v--version-print-a-version" id="-v--version-print-a-version"><code>-V</code>/<code>--version</code>: print a version</a></h2>
<p>This flag will print out <code>rustc</code>'s version.</p>
<h2><a class="header" href="#-v--verbose-use-verbose-output" id="-v--verbose-use-verbose-output"><code>-v</code>/<code>--verbose</code>: use verbose output</a></h2>
<p>This flag, when combined with other flags, makes them produce extra output.</p>
<h2><a class="header" href="#--extern-specify-where-an-external-library-is-located" id="--extern-specify-where-an-external-library-is-located"><code>--extern</code>: specify where an external library is located</a></h2>
<p>This flag allows you to pass the name and location of an external crate that
will be linked into the crate you are building. This flag may be specified
multiple times. The format of the value should be <code>CRATENAME=PATH</code>.</p>
<h2><a class="header" href="#--sysroot-override-the-system-root" id="--sysroot-override-the-system-root"><code>--sysroot</code>: Override the system root</a></h2>
<p>The &quot;sysroot&quot; is where <code>rustc</code> looks for the crates that come with the Rust
distribution; this flag allows that to be overridden.</p>
<h2><a class="header" href="#--error-format-control-how-errors-are-produced" id="--error-format-control-how-errors-are-produced"><code>--error-format</code>: control how errors are produced</a></h2>
<p>This flag lets you control the format of messages. Messages are printed to
stderr. The valid options are:</p>
<ul>
<li><code>human</code> — Human-readable output. This is the default.</li>
<li><code>json</code> — Structured JSON output.</li>
<li><code>short</code> — Short, one-line messages.</li>
</ul>
<h2><a class="header" href="#--color-configure-coloring-of-output" id="--color-configure-coloring-of-output"><code>--color</code>: configure coloring of output</a></h2>
<p>This flag lets you control color settings of the output. The valid options
are:</p>
<ul>
<li><code>auto</code> — Use colors if output goes to a tty. This is the default.</li>
<li><code>always</code> — Always use colors.</li>
<li><code>never</code> — Never colorize output.</li>
</ul>
<h2><a class="header" href="#--remap-path-prefix-remap-source-names-in-output" id="--remap-path-prefix-remap-source-names-in-output"><code>--remap-path-prefix</code>: remap source names in output</a></h2>
<p>Remap source path prefixes in all output, including compiler diagnostics,
debug information, macro expansions, etc. It takes a value of the form
<code>FROM=TO</code> where a path prefix equal to <code>FROM</code> is rewritten to the value <code>TO</code>.
The <code>FROM</code> may itself contain an <code>=</code> symbol, but the <code>TO</code> value may not. This
flag may be specified multiple times.</p>
<p>This is useful for normalizing build products, for example by removing the
current directory out of pathnames emitted into the object files. The
replacement is purely textual, with no consideration of the current system's
pathname syntax. For example <code>--remap-path-prefix foo=bar</code> will match
<code>foo/lib.rs</code> but not <code>./foo/lib.rs</code>.</p>
<h2><a class="header" href="#--json-configure-json-messages-printed-by-the-compiler" id="--json-configure-json-messages-printed-by-the-compiler"><code>--json</code>: configure json messages printed by the compiler</a></h2>
<p>When the <code>--error-format=json</code> option is passed to rustc then all of the
compiler's diagnostic output will be emitted in the form of JSON blobs. The
<code>--json</code> argument can be used in conjunction with <code>--error-format=json</code> to
configure what the JSON blobs contain as well as which ones are emitted.</p>
<p>With <code>--error-format=json</code> the compiler will always emit any compiler errors as
a JSON blob, but the following options are also available to the <code>--json</code> flag
to customize the output:</p>
<ul>
<li>
<p><code>diagnostic-short</code> - json blobs for diagnostic messages should use the &quot;short&quot;
rendering instead of the normal &quot;human&quot; default. This means that the output of
<code>--error-format=short</code> will be embedded into the JSON diagnostics instead of
the default <code>--error-format=human</code>.</p>
</li>
<li>
<p><code>diagnostic-rendered-ansi</code> - by default JSON blobs in their <code>rendered</code> field
will contain a plain text rendering of the diagnostic. This option instead
indicates that the diagnostic should have embedded ANSI color codes intended
to be used to colorize the message in the manner rustc typically already does
for terminal outputs. Note that this is usefully combined with crates like
<code>fwdansi</code> to translate these ANSI codes on Windows to console commands or
<code>strip-ansi-escapes</code> if you'd like to optionally remove the ansi colors
afterwards.</p>
</li>
<li>
<p><code>artifacts</code> - this instructs rustc to emit a JSON blob for each artifact that
is emitted. An artifact corresponds to a request from the <code>--emit</code> CLI
argument, and as soon as the artifact is available on the filesystem a
notification will be emitted.</p>
</li>
</ul>
<p>Note that it is invalid to combine the <code>--json</code> argument with the <code>--color</code>
argument, and it is required to combine <code>--json</code> with <code>--error-format=json</code>.</p>
<h2><a class="header" href="#path-load-command-line-flags-from-a-path" id="path-load-command-line-flags-from-a-path"><code>@path</code>: load command-line flags from a path</a></h2>
<p>If you specify <code>@path</code> on the command-line, then it will open <code>path</code> and read
command line options from it. These options are one per line; a blank line indicates
an empty option. The file can use Unix or Windows style line endings, and must be
encoded as UTF-8.</p>
<h1><a class="header" href="#lints" id="lints">Lints</a></h1>
<p>In software, a &quot;lint&quot; is a tool used to help improve your source code. The
Rust compiler contains a number of lints, and when it compiles your code, it will
also run the lints. These lints may produce a warning, an error, or nothing at all,
depending on how you've configured things.</p>
<p>Here's a small example:</p>
<pre><code class="language-bash">$ cat main.rs
fn main() {
    let x = 5;
}
$ rustc main.rs
warning: unused variable: `x`
 --&gt; main.rs:2:9
  |
2 |     let x = 5;
  |         ^
  |
  = note: `#[warn(unused_variables)]` on by default
  = note: to avoid this warning, consider using `_x` instead
</code></pre>
<p>This is the <code>unused_variables</code> lint, and it tells you that you've introduced
a variable that you don't use in your code. That's not <em>wrong</em>, so it's not
an error, but it might be a bug, so you get a warning.</p>
<h1><a class="header" href="#lint-levels" id="lint-levels">Lint levels</a></h1>
<p>In <code>rustc</code>, lints are divided into four <em>levels</em>:</p>
<ol>
<li>allow</li>
<li>warn</li>
<li>deny</li>
<li>forbid</li>
</ol>
<p>Each lint has a default level (explained in the lint listing later in this
chapter), and the compiler has a default warning level. First, let's explain
what these levels mean, and then we'll talk about configuration.</p>
<h2><a class="header" href="#allow" id="allow">allow</a></h2>
<p>These lints exist, but by default, do nothing. For example, consider this
source:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn foo() {}
#}</code></pre></pre>
<p>Compiling this file produces no warnings:</p>
<pre><code class="language-bash">$ rustc lib.rs --crate-type=lib
$
</code></pre>
<p>But this code violates the <code>missing_docs</code> lint.</p>
<p>These lints exist mostly to be manually turned on via configuration, as we'll
talk about later in this section.</p>
<h2><a class="header" href="#warn" id="warn">warn</a></h2>
<p>The 'warn' lint level will produce a warning if you violate the lint. For example,
this code runs afoul of the <code>unused_variable</code> lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn foo() {
    let x = 5;
}
#}</code></pre></pre>
<p>This will produce this warning:</p>
<pre><code class="language-bash">$ rustc lib.rs --crate-type=lib
warning: unused variable: `x`
 --&gt; lib.rs:2:9
  |
2 |     let x = 5;
  |         ^
  |
  = note: `#[warn(unused_variables)]` on by default
  = note: to avoid this warning, consider using `_x` instead
</code></pre>
<h2><a class="header" href="#deny" id="deny">deny</a></h2>
<p>A 'deny' lint produces an error if you violate it. For example, this code
runs into the <code>exceeding_bitshifts</code> lint.</p>
<pre><code class="language-rust ignore">fn main() {
    100u8 &lt;&lt; 10;
}
</code></pre>
<pre><code class="language-bash">$ rustc main.rs
error: bitshift exceeds the type's number of bits
 --&gt; main.rs:2:13
  |
2 |     100u8 &lt;&lt; 10;
  |     ^^^^^^^^^^^
  |
  = note: `#[deny(exceeding_bitshifts)]` on by default
</code></pre>
<p>What's the difference between an error from a lint and a regular old error?
Lints are configurable via levels, so in a similar way to 'allow' lints,
warnings that are 'deny' by default let you allow them. Similarly, you may
wish to set up a lint that is <code>warn</code> by default to produce an error instead.
This lint level gives you that.</p>
<h2><a class="header" href="#forbid" id="forbid">forbid</a></h2>
<p>'forbid' is a special lint level that's stronger than 'deny'. It's the same
as 'deny' in that a lint at this level will produce an error, but unlike the
'deny' level, the 'forbid' level can not be overridden to be anything lower
than an error.  However, lint levels may still be capped with <code>--cap-lints</code>
(see below) so <code>rustc --cap-lints warn</code> will make lints set to 'forbid' just
warn.</p>
<h2><a class="header" href="#configuring-warning-levels" id="configuring-warning-levels">Configuring warning levels</a></h2>
<p>Remember our <code>missing_docs</code> example from the 'allow' lint level?</p>
<pre><code class="language-bash">$ cat lib.rs
pub fn foo() {}
$ rustc lib.rs --crate-type=lib
$
</code></pre>
<p>We can configure this lint to operate at a higher level, both with
compiler flags, as well as with an attribute in the source code.</p>
<p>You can also &quot;cap&quot; lints so that the compiler can choose to ignore
certain lint levels. We'll talk about that last.</p>
<h3><a class="header" href="#via-compiler-flag" id="via-compiler-flag">Via compiler flag</a></h3>
<p>The <code>-A</code>, <code>-W</code>, <code>-D</code>, and <code>-F</code> flags let you turn one or more lints
into allowed, warning, deny, or forbid levels, like this:</p>
<pre><code class="language-bash">$ rustc lib.rs --crate-type=lib -W missing-docs
warning: missing documentation for crate
 --&gt; lib.rs:1:1
  |
1 | pub fn foo() {}
  | ^^^^^^^^^^^^
  |
  = note: requested on the command line with `-W missing-docs`

warning: missing documentation for a function
 --&gt; lib.rs:1:1
  |
1 | pub fn foo() {}
  | ^^^^^^^^^^^^
</code></pre>
<pre><code class="language-bash">$ rustc lib.rs --crate-type=lib -D missing-docs
error: missing documentation for crate
 --&gt; lib.rs:1:1
  |
1 | pub fn foo() {}
  | ^^^^^^^^^^^^
  |
  = note: requested on the command line with `-D missing-docs`

error: missing documentation for a function
 --&gt; lib.rs:1:1
  |
1 | pub fn foo() {}
  | ^^^^^^^^^^^^

error: aborting due to 2 previous errors
</code></pre>
<p>You can also pass each flag more than once for changing multiple lints:</p>
<pre><code class="language-bash">$ rustc lib.rs --crate-type=lib -D missing-docs -D unused-variables
</code></pre>
<p>And of course, you can mix these four flags together:</p>
<pre><code class="language-bash">$ rustc lib.rs --crate-type=lib -D missing-docs -A unused-variables
</code></pre>
<h3><a class="header" href="#via-an-attribute" id="via-an-attribute">Via an attribute</a></h3>
<p>You can also modify the lint level with a crate-wide attribute:</p>
<pre><code class="language-bash">$ cat lib.rs
#![warn(missing_docs)]

pub fn foo() {}
$ rustc lib.rs --crate-type=lib
warning: missing documentation for crate
 --&gt; lib.rs:1:1
  |
1 | / #![warn(missing_docs)]
2 | |
3 | | pub fn foo() {}
  | |_______________^
  |
note: lint level defined here
 --&gt; lib.rs:1:9
  |
1 | #![warn(missing_docs)]
  |         ^^^^^^^^^^^^

warning: missing documentation for a function
 --&gt; lib.rs:3:1
  |
3 | pub fn foo() {}
  | ^^^^^^^^^^^^
</code></pre>
<p>All four, <code>warn</code>, <code>allow</code>, <code>deny</code>, and <code>forbid</code> all work this way.</p>
<p>You can also pass in multiple lints per attribute:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![warn(missing_docs, unused_variables)]

#fn main() {
pub fn foo() {}
#}</code></pre></pre>
<p>And use multiple attributes together:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![warn(missing_docs)]
#![deny(unused_variables)]

#fn main() {
pub fn foo() {}
#}</code></pre></pre>
<h3><a class="header" href="#capping-lints" id="capping-lints">Capping lints</a></h3>
<p><code>rustc</code> supports a flag, <code>--cap-lints LEVEL</code> that sets the &quot;lint cap level.&quot;
This is the maximum level for all lints. So for example, if we take our
code sample from the &quot;deny&quot; lint level above:</p>
<pre><code class="language-rust ignore">fn main() {
    100u8 &lt;&lt; 10;
}
</code></pre>
<p>And we compile it, capping lints to warn:</p>
<pre><code class="language-bash">$ rustc lib.rs --cap-lints warn
warning: bitshift exceeds the type's number of bits
 --&gt; lib.rs:2:5
  |
2 |     100u8 &lt;&lt; 10;
  |     ^^^^^^^^^^^
  |
  = note: `#[warn(exceeding_bitshifts)]` on by default

warning: this expression will panic at run-time
 --&gt; lib.rs:2:5
  |
2 |     100u8 &lt;&lt; 10;
  |     ^^^^^^^^^^^ attempt to shift left with overflow
</code></pre>
<p>It now only warns, rather than errors. We can go further and allow all lints:</p>
<pre><code class="language-bash">$ rustc lib.rs --cap-lints allow
$
</code></pre>
<p>This feature is used heavily by Cargo; it will pass <code>--cap-lints allow</code> when
compiling your dependencies, so that if they have any warnings, they do not
pollute the output of your build.</p>
<h1><a class="header" href="#lint-groups" id="lint-groups">Lint Groups</a></h1>
<p><code>rustc</code> has the concept of a &quot;lint group&quot;, where you can toggle several warnings
through one name.</p>
<p>For example, the <code>nonstandard-style</code> lint sets <code>non-camel-case-types</code>,
<code>non-snake-case</code>, and <code>non-upper-case-globals</code> all at once. So these are
equivalent:</p>
<pre><code class="language-bash">$ rustc -D nonstandard-style
$ rustc -D non-camel-case-types -D non-snake-case -D non-upper-case-globals
</code></pre>
<p>Here's a list of each lint group, and the lints that they are made up of:</p>
<table><thead><tr><th>group</th><th>description</th><th>lints</th></tr></thead><tbody>
<tr><td>nonstandard-style</td><td>Violation of standard naming conventions</td><td>non-camel-case-types, non-snake-case, non-upper-case-globals</td></tr>
<tr><td>warnings</td><td>all lints that would be issuing warnings</td><td>all lints that would be issuing warnings</td></tr>
<tr><td>edition-2018</td><td>Lints that will be turned into errors in Rust 2018</td><td>tyvar-behind-raw-pointer</td></tr>
<tr><td>rust-2018-idioms</td><td>Lints to nudge you toward idiomatic features of Rust 2018</td><td>bare-trait-object, unreachable-pub</td></tr>
<tr><td>unused</td><td>These lints detect things being declared but not used</td><td>unused-imports, unused-variables, unused-assignments, dead-code, unused-mut, unreachable-code, unreachable-patterns, unused-must-use, unused-unsafe, path-statements, unused-attributes, unused-macros, unused-allocation, unused-doc-comment, unused-extern-crates, unused-features, unused-parens</td></tr>
<tr><td>future-incompatible</td><td>Lints that detect code that has future-compatibility problems</td><td>private-in-public, pub-use-of-private-extern-crate, patterns-in-fns-without-body, safe-extern-statics, invalid-type-param-default, legacy-directory-ownership, legacy-imports, legacy-constructor-visibility, missing-fragment-specifier, illegal-floating-point-literal-pattern, anonymous-parameters, parenthesized-params-in-types-and-modules, late-bound-lifetime-arguments, safe-packed-borrows, tyvar-behind-raw-pointer, unstable-name-collision</td></tr>
</tbody></table>
<p>Additionally, there's a <code>bad-style</code> lint group that's a deprecated alias for <code>nonstandard-style</code>.</p>
<p>Finally, you can also see the table above by invoking <code>rustc -W help</code>. This will give you the exact values for the specific
compiler you have installed.</p>
<h1><a class="header" href="#lint-listing" id="lint-listing">Lint listing</a></h1>
<p>This section lists out all of the lints, grouped by their default lint levels.</p>
<p>You can also see this list by running <code>rustc -W help</code>.</p>
<h1><a class="header" href="#allowed-by-default-lints" id="allowed-by-default-lints">Allowed-by-default lints</a></h1>
<p>These lints are all set to the 'allow' level by default. As such, they won't show up
unless you set them to a higher lint level with a flag or attribute.</p>
<h2><a class="header" href="#anonymous-parameters" id="anonymous-parameters">anonymous-parameters</a></h2>
<p>This lint detects anonymous parameters. Some example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo {
    fn foo(usize);
}
#}</code></pre></pre>
<p>When set to 'deny', this will produce:</p>
<pre><code class="language-text">error: use of deprecated anonymous parameter
 --&gt; src/lib.rs:5:11
  |
5 |     fn foo(usize);
  |           ^
  |
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #41686 &lt;https://github.com/rust-lang/rust/issues/41686&gt;
</code></pre>
<p>This syntax is mostly a historical accident, and can be worked around quite
easily:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo {
    fn foo(_: usize);
}
#}</code></pre></pre>
<h2><a class="header" href="#bare-trait-object" id="bare-trait-object">bare-trait-object</a></h2>
<p>This lint suggests using <code>dyn Trait</code> for trait objects. Some example code
that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(dyn_trait)]

#fn main() {
trait Trait { }

fn takes_trait_object(_: Box&lt;Trait&gt;) {
}
#}</code></pre></pre>
<p>When set to 'deny', this will produce:</p>
<pre><code class="language-text">error: trait objects without an explicit `dyn` are deprecated
 --&gt; src/lib.rs:7:30
  |
7 | fn takes_trait_object(_: Box&lt;Trait&gt;) {
  |                              ^^^^^ help: use `dyn`: `dyn Trait`
  |
</code></pre>
<p>To fix it, do as the help message suggests:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(dyn_trait)]
#![deny(bare_trait_objects)]

#fn main() {
trait Trait { }

fn takes_trait_object(_: Box&lt;dyn Trait&gt;) {
}
#}</code></pre></pre>
<h2><a class="header" href="#box-pointers" id="box-pointers">box-pointers</a></h2>
<p>This lints use of the Box type. Some example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Foo {
    x: Box&lt;isize&gt;,
}
#}</code></pre></pre>
<p>When set to 'deny', this will produce:</p>
<pre><code class="language-text">error: type uses owned (Box type) pointers: std::boxed::Box&lt;isize&gt;
 --&gt; src/lib.rs:6:5
  |
6 |     x: Box&lt;isize&gt; //~ ERROR type uses owned
  |     ^^^^^^^^^^^^^
  |
</code></pre>
<p>This lint is mostly historical, and not particularly useful. <code>Box&lt;T&gt;</code> used to
be built into the language, and the only way to do heap allocation. Today's
Rust can call into other allocators, etc.</p>
<h2><a class="header" href="#elided-lifetime-in-path" id="elided-lifetime-in-path">elided-lifetime-in-path</a></h2>
<p>This lint detects the use of hidden lifetime parameters. Some example code
that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Foo&lt;'a&gt; {
    x: &amp;'a u32
}

fn foo(x: &amp;Foo) {
}
#}</code></pre></pre>
<p>When set to 'deny', this will produce:</p>
<pre><code class="language-text">error: hidden lifetime parameters are deprecated, try `Foo&lt;'_&gt;`
 --&gt; src/lib.rs:5:12
  |
5 | fn foo(x: &amp;Foo) {
  |            ^^^
  |
</code></pre>
<p>Lifetime elision elides this lifetime, but that is being deprecated.</p>
<h2><a class="header" href="#missing-copy-implementations" id="missing-copy-implementations">missing-copy-implementations</a></h2>
<p>This lint detects potentially-forgotten implementations of <code>Copy</code>. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Foo {
    pub field: i32
}
#}</code></pre></pre>
<p>When set to 'deny', this will produce:</p>
<pre><code class="language-text">error: type could implement `Copy`; consider adding `impl Copy`
 --&gt; src/main.rs:3:1
  |
3 | / pub struct Foo { //~ ERROR type could implement `Copy`; consider adding `impl Copy`
4 | |     pub field: i32
5 | | }
  | |_^
  |
</code></pre>
<p>You can fix the lint by deriving <code>Copy</code>.</p>
<p>This lint is set to 'allow' because this code isn't bad; it's common to write
newtypes like this specifically so that a <code>Copy</code> type is no longer <code>Copy</code>.</p>
<h2><a class="header" href="#missing-debug-implementations" id="missing-debug-implementations">missing-debug-implementations</a></h2>
<p>This lint detects missing implementations of <code>fmt::Debug</code>. Some example code
that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Foo;
#}</code></pre></pre>
<p>When set to 'deny', this will produce:</p>
<pre><code class="language-text">error: type does not implement `fmt::Debug`; consider adding `#[derive(Debug)]` or a manual implementation
 --&gt; src/main.rs:3:1
  |
3 | pub struct Foo;
  | ^^^^^^^^^^^^^^^
  |
</code></pre>
<p>You can fix the lint by deriving <code>Debug</code>.</p>
<h2><a class="header" href="#missing-docs" id="missing-docs">missing-docs</a></h2>
<p>This lint detects missing documentation for public items. Some example code
that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn foo() {}
#}</code></pre></pre>
<p>When set to 'deny', this will produce:</p>
<pre><code class="language-text">error: missing documentation for crate
 --&gt; src/main.rs:1:1
  |
1 | / #![deny(missing_docs)]
2 | |
3 | | pub fn foo() {}
4 | |
5 | | fn main() {}
  | |____________^
  |

error: missing documentation for a function
 --&gt; src/main.rs:3:1
  |
3 | pub fn foo() {}
  | ^^^^^^^^^^^^

</code></pre>
<p>To fix the lint, add documentation to all items.</p>
<h2><a class="header" href="#single-use-lifetimes" id="single-use-lifetimes">single-use-lifetimes</a></h2>
<p>This lint detects lifetimes that are only used once. Some example code that
triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Foo&lt;'x&gt; {
    x: &amp;'x u32
}
#}</code></pre></pre>
<p>When set to 'deny', this will produce:</p>
<pre><code class="language-text">error: lifetime name `'x` only used once
 --&gt; src/main.rs:3:12
  |
3 | struct Foo&lt;'x&gt; {
  |            ^^
  |
</code></pre>
<h2><a class="header" href="#trivial-casts" id="trivial-casts">trivial-casts</a></h2>
<p>This lint detects trivial casts which could be removed. Some example code
that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x: &amp;u32 = &amp;42;
let _ = x as *const u32;
#}</code></pre></pre>
<p>When set to 'deny', this will produce:</p>
<pre><code class="language-text">error: trivial cast: `&amp;u32` as `*const u32`. Cast can be replaced by coercion, this might require type ascription or a temporary variable
 --&gt; src/main.rs:5:13
  |
5 |     let _ = x as *const u32;
  |             ^^^^^^^^^^^^^^^
  |
note: lint level defined here
 --&gt; src/main.rs:1:9
  |
1 | #![deny(trivial_casts)]
  |         ^^^^^^^^^^^^^
</code></pre>
<h2><a class="header" href="#trivial-numeric-casts" id="trivial-numeric-casts">trivial-numeric-casts</a></h2>
<p>This lint detects trivial casts of numeric types which could be removed. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 42i32 as i32;
#}</code></pre></pre>
<p>When set to 'deny', this will produce:</p>
<pre><code class="language-text">error: trivial numeric cast: `i32` as `i32`. Cast can be replaced by coercion, this might require type ascription or a temporary variable
 --&gt; src/main.rs:4:13
  |
4 |     let x = 42i32 as i32;
  |             ^^^^^^^^^^^^
  |
</code></pre>
<h2><a class="header" href="#unreachable-pub" id="unreachable-pub">unreachable-pub</a></h2>
<p>This lint triggers for <code>pub</code> items not reachable from the crate root. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod foo {
    pub mod bar {
        
    }
}
#}</code></pre></pre>
<p>When set to 'deny', this will produce:</p>
<pre><code class="language-text">error: unreachable `pub` item
 --&gt; src/main.rs:4:5
  |
4 |     pub mod bar {
  |     ---^^^^^^^^
  |     |
  |     help: consider restricting its visibility: `pub(crate)`
  |
</code></pre>
<h2><a class="header" href="#unsafe-code" id="unsafe-code">unsafe-code</a></h2>
<p>This lint catches usage of <code>unsafe</code> code. Some example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    unsafe {

    }
}
</code></pre></pre>
<p>When set to 'deny', this will produce:</p>
<pre><code class="language-text">error: usage of an `unsafe` block
 --&gt; src/main.rs:4:5
  |
4 | /     unsafe {
5 | |         
6 | |     }
  | |_____^
  |
</code></pre>
<h2><a class="header" href="#unstable-features" id="unstable-features">unstable-features</a></h2>
<p>This lint is deprecated and no longer used.</p>
<h2><a class="header" href="#unused-extern-crates" id="unused-extern-crates">unused-extern-crates</a></h2>
<p>This lint guards against <code>extern crate</code> items that are never used. Some
example code that triggers this lint:</p>
<pre><code class="language-rust ignore">extern crate semver;
</code></pre>
<p>When set to 'deny', this will produce:</p>
<pre><code class="language-text">error: unused extern crate
 --&gt; src/main.rs:3:1
  |
3 | extern crate semver;
  | ^^^^^^^^^^^^^^^^^^^^
  |
</code></pre>
<h2><a class="header" href="#unused-import-braces" id="unused-import-braces">unused-import-braces</a></h2>
<p>This lint catches unnecessary braces around an imported item. Some example
code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">use test::{A};

pub mod test {
    pub struct A;
}
# fn main() {}
</code></pre></pre>
<p>When set to 'deny', this will produce:</p>
<pre><code class="language-text">error: braces around A is unnecessary
 --&gt; src/main.rs:3:1
  |
3 | use test::{A};
  | ^^^^^^^^^^^^^^
  |
</code></pre>
<p>To fix it, <code>use test::A;</code></p>
<h2><a class="header" href="#unused-qualifications" id="unused-qualifications">unused-qualifications</a></h2>
<p>This lint detects unnecessarily qualified names. Some example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">mod foo {
    pub fn bar() {}
}

fn main() {
    use foo::bar;
    foo::bar();
}
</code></pre></pre>
<p>When set to 'deny', this will produce:</p>
<pre><code class="language-text">error: unnecessary qualification
 --&gt; src/main.rs:9:5
  |
9 |     foo::bar();
  |     ^^^^^^^^
  |
</code></pre>
<p>You can call <code>bar()</code> directly, without the <code>foo::</code>.</p>
<h2><a class="header" href="#unused-results" id="unused-results">unused-results</a></h2>
<p>This lint checks for the unused result of an expression in a statement. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust no_run">fn foo&lt;T&gt;() -&gt; T { panic!() }

fn main() {
    foo::&lt;usize&gt;();
}
</code></pre></pre>
<p>When set to 'deny', this will produce:</p>
<pre><code class="language-text">error: unused result
 --&gt; src/main.rs:6:5
  |
6 |     foo::&lt;usize&gt;();
  |     ^^^^^^^^^^^^^^^
  |
</code></pre>
<h2><a class="header" href="#variant-size-differences" id="variant-size-differences">variant-size-differences</a></h2>
<p>This lint detects enums with widely varying variant sizes. Some example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum En {
    V0(u8),
    VBig([u8; 1024]),
}
#}</code></pre></pre>
<p>When set to 'deny', this will produce:</p>
<pre><code class="language-text">error: enum variant is more than three times larger (1024 bytes) than the next largest
 --&gt; src/main.rs:5:5
  |
5 |     VBig([u8; 1024]),   //~ ERROR variant is more than three times larger
  |     ^^^^^^^^^^^^^^^^
  |
</code></pre>
<h1><a class="header" href="#warn-by-default-lints" id="warn-by-default-lints">Warn-by-default lints</a></h1>
<p>These lints are all set to the 'warn' level by default.</p>
<h2><a class="header" href="#const-err" id="const-err">const-err</a></h2>
<p>This lint detects an erroneous expression while doing constant evaluation. Some
example code that triggers this lint:</p>
<pre><code class="language-rust ignore">let b = 200u8 + 200u8;
</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: attempt to add with overflow
 --&gt; src/main.rs:2:9
  |
2 | let b = 200u8 + 200u8;
  |         ^^^^^^^^^^^^^
  |
</code></pre>
<h2><a class="header" href="#dead-code" id="dead-code">dead-code</a></h2>
<p>This lint detects unused, unexported items. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo() {}
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: function is never used: `foo`
 --&gt; src/lib.rs:2:1
  |
2 | fn foo() {}
  | ^^^^^^^^
  |
</code></pre>
<h2><a class="header" href="#deprecated" id="deprecated">deprecated</a></h2>
<p>This lint detects use of deprecated items. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[deprecated]
fn foo() {}

fn bar() {
    foo();
}
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: use of deprecated item 'foo'
 --&gt; src/lib.rs:7:5
  |
7 |     foo();
  |     ^^^
  |
</code></pre>
<h2><a class="header" href="#illegal-floating-point-literal-pattern" id="illegal-floating-point-literal-pattern">illegal-floating-point-literal-pattern</a></h2>
<p>This lint detects floating-point literals used in patterns. Some example code
that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 42.0;

match x {
    5.0 =&gt; {},
    _ =&gt; {},
}
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: floating-point literals cannot be used in patterns
 --&gt; src/main.rs:4:9
  |
4 |         5.0 =&gt; {},
  |         ^^^
  |
  = note: `#[warn(illegal_floating_point_literal_pattern)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #41620 &lt;https://github.com/rust-lang/rust/issues/41620&gt;
</code></pre>
<h2><a class="header" href="#improper-ctypes" id="improper-ctypes">improper-ctypes</a></h2>
<p>This lint detects proper use of libc types in foreign modules. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern &quot;C&quot; {
    static STATIC: String;
}
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: found struct without foreign-function-safe representation annotation in foreign module, consider adding a `#[repr(C)]` attribute to the type
 --&gt; src/main.rs:2:20
  |
2 |     static STATIC: String;
  |                    ^^^^^^
  |
</code></pre>
<h2><a class="header" href="#late-bound-lifetime-arguments" id="late-bound-lifetime-arguments">late-bound-lifetime-arguments</a></h2>
<p>This lint detects generic lifetime arguments in path segments with
late bound lifetime parameters. Some example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">struct S;

impl S {
    fn late&lt;'a, 'b&gt;(self, _: &amp;'a u8, _: &amp;'b u8) {}
}

fn main() {
    S.late::&lt;'static&gt;(&amp;0, &amp;0);
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present
 --&gt; src/main.rs:8:14
  |
4 |     fn late&lt;'a, 'b&gt;(self, _: &amp;'a u8, _: &amp;'b u8) {}
  |             -- the late bound lifetime parameter is introduced here
...
8 |     S.late::&lt;'static&gt;(&amp;0, &amp;0);
  |              ^^^^^^^
  |
  = note: `#[warn(late_bound_lifetime_arguments)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #42868 &lt;https://github.com/rust-lang/rust/issues/42868&gt;
</code></pre>
<h2><a class="header" href="#non-camel-case-types" id="non-camel-case-types">non-camel-case-types</a></h2>
<p>This lint detects types, variants, traits and type parameters that don't have
camel case names. Some example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct s;
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: type `s` should have a camel case name such as `S`
 --&gt; src/main.rs:1:1
  |
1 | struct s;
  | ^^^^^^^^^
  |
</code></pre>
<h2><a class="header" href="#non-shorthand-field-patterns" id="non-shorthand-field-patterns">non-shorthand-field-patterns</a></h2>
<p>This lint detects using <code>Struct { x: x }</code> instead of <code>Struct { x }</code> in a pattern. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}


fn main() {
    let p = Point {
        x: 5,
        y: 5,
    };

    match p {
        Point { x: x, y: y } =&gt; (),
    }
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: the `x:` in this pattern is redundant
  --&gt; src/main.rs:14:17
   |
14 |         Point { x: x, y: y } =&gt; (),
   |                 --^^
   |                 |
   |                 help: remove this
   |

warning: the `y:` in this pattern is redundant
  --&gt; src/main.rs:14:23
   |
14 |         Point { x: x, y: y } =&gt; (),
   |                       --^^
   |                       |
   |                       help: remove this

</code></pre>
<h2><a class="header" href="#non-snake-case" id="non-snake-case">non-snake-case</a></h2>
<p>This lint detects variables, methods, functions, lifetime parameters and
modules that don't have snake case names. Some example code that triggers
this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let X = 5;
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: variable `X` should have a snake case name such as `x`
 --&gt; src/main.rs:2:9
  |
2 |     let X = 5;
  |         ^
  |
</code></pre>
<h2><a class="header" href="#non-upper-case-globals" id="non-upper-case-globals">non-upper-case-globals</a></h2>
<p>This lint detects static constants that don't have uppercase identifiers.
Some example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
static x: i32 = 5;
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: static variable `x` should have an upper case name such as `X`
 --&gt; src/main.rs:1:1
  |
1 | static x: i32 = 5;
  | ^^^^^^^^^^^^^^^^^^
  |
</code></pre>
<h2><a class="header" href="#no-mangle-generic-items" id="no-mangle-generic-items">no-mangle-generic-items</a></h2>
<p>This lint detects generic items must be mangled. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[no_mangle]
fn foo&lt;T&gt;(t: T) {

}
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: functions generic over types must be mangled
 --&gt; src/main.rs:2:1
  |
1 |   #[no_mangle]
  |   ------------ help: remove this attribute
2 | / fn foo&lt;T&gt;(t: T) {
3 | |
4 | | }
  | |_^
  |
</code></pre>
<h2><a class="header" href="#path-statements" id="path-statements">path-statements</a></h2>
<p>This lint detects path statements with no effect. Some example code that
triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 42;

x;
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: path statement with no effect
 --&gt; src/main.rs:3:5
  |
3 |     x;
  |     ^^
  |
</code></pre>
<h2><a class="header" href="#patterns-in-fns-without-body" id="patterns-in-fns-without-body">patterns-in-fns-without-body</a></h2>
<p>This lint detects patterns in functions without body were that were
previously erroneously allowed. Some example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Trait {
    fn foo(mut arg: u8);
}
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: patterns aren't allowed in methods without bodies
 --&gt; src/main.rs:2:12
  |
2 |     fn foo(mut arg: u8);
  |            ^^^^^^^
  |
  = note: `#[warn(patterns_in_fns_without_body)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #35203 &lt;https://github.com/rust-lang/rust/issues/35203&gt;
</code></pre>
<p>To fix this, remove the pattern; it can be used in the implementation without
being used in the definition. That is:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Trait {
    fn foo(arg: u8);
}

impl Trait for i32 {
    fn foo(mut arg: u8) {

    }
}
#}</code></pre></pre>
<h2><a class="header" href="#plugin-as-library" id="plugin-as-library">plugin-as-library</a></h2>
<p>This lint detects when compiler plugins are used as ordinary library in
non-plugin crate. Some example code that triggers this lint:</p>
<pre><code class="language-rust ignore">#![feature(plugin)]
#![plugin(macro_crate_test)]

extern crate macro_crate_test;
</code></pre>
<h2><a class="header" href="#private-in-public" id="private-in-public">private-in-public</a></h2>
<p>This lint detects private items in public interfaces not caught by the old implementation. Some
example code that triggers this lint:</p>
<pre><code class="language-rust ignore">pub trait Trait {
    type A;
}

pub struct S;

mod foo {
    struct Z;

    impl ::Trait for ::S {
        type A = Z;
    }
}
# fn main() {}
</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error[E0446]: private type `foo::Z` in public interface
  --&gt; src/main.rs:11:9
   |
11 |         type A = Z;
   |         ^^^^^^^^^^^ can't leak private type
</code></pre>
<h2><a class="header" href="#private-no-mangle-fns" id="private-no-mangle-fns">private-no-mangle-fns</a></h2>
<p>This lint detects functions marked <code>#[no_mangle]</code> that are also private.
Given that private functions aren't exposed publicly, and <code>#[no_mangle]</code>
controls the public symbol, this combination is erroneous. Some example code
that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[no_mangle]
fn foo() {}
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: function is marked `#[no_mangle]`, but not exported
 --&gt; src/main.rs:2:1
  |
2 | fn foo() {}
  | -^^^^^^^^^^
  | |
  | help: try making it public: `pub`
  |
</code></pre>
<p>To fix this, either make it public or remove the <code>#[no_mangle]</code>.</p>
<h2><a class="header" href="#private-no-mangle-statics" id="private-no-mangle-statics">private-no-mangle-statics</a></h2>
<p>This lint detects any statics marked <code>#[no_mangle]</code> that are private.
Given that private statics aren't exposed publicly, and <code>#[no_mangle]</code>
controls the public symbol, this combination is erroneous. Some example code
that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[no_mangle]
static X: i32 = 4;
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: static is marked `#[no_mangle]`, but not exported
 --&gt; src/main.rs:2:1
  |
2 | static X: i32 = 4;
  | -^^^^^^^^^^^^^^^^^
  | |
  | help: try making it public: `pub`
  |
</code></pre>
<p>To fix this, either make it public or remove the <code>#[no_mangle]</code>.</p>
<h2><a class="header" href="#renamed-and-removed-lints" id="renamed-and-removed-lints">renamed-and-removed-lints</a></h2>
<p>This lint detects lints that have been renamed or removed. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![deny(raw_pointer_derive)]
#fn main() {
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: lint raw_pointer_derive has been removed: using derive with raw pointers is ok
 --&gt; src/main.rs:1:9
  |
1 | #![deny(raw_pointer_derive)]
  |         ^^^^^^^^^^^^^^^^^^
  |
</code></pre>
<p>To fix this, either remove the lint or use the new name.</p>
<h2><a class="header" href="#safe-packed-borrows" id="safe-packed-borrows">safe-packed-borrows</a></h2>
<p>This lint detects borrowing a field in the interior of a packed structure
with alignment other than 1. Some example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">#[repr(packed)]
pub struct Unaligned&lt;T&gt;(pub T);

pub struct Foo {
    start: u8,
    data: Unaligned&lt;u32&gt;,
}

fn main() {
    let x = Foo { start: 0, data: Unaligned(1) };
    let y = &amp;x.data.0;
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: borrow of packed field requires unsafe function or block (error E0133)
  --&gt; src/main.rs:11:13
   |
11 |     let y = &amp;x.data.0;
   |             ^^^^^^^^^
   |
   = note: `#[warn(safe_packed_borrows)]` on by default
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #46043 &lt;https://github.com/rust-lang/rust/issues/46043&gt;
</code></pre>
<h2><a class="header" href="#stable-features" id="stable-features">stable-features</a></h2>
<p>This lint detects a <code>#[feature]</code> attribute that's since been made stable. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(test_accepted_feature)]
#fn main() {
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: this feature has been stable since 1.0.0. Attribute no longer needed
 --&gt; src/main.rs:1:12
  |
1 | #![feature(test_accepted_feature)]
  |            ^^^^^^^^^^^^^^^^^^^^^
  |
</code></pre>
<p>To fix, simply remove the <code>#![feature]</code> attribute, as it's no longer needed.</p>
<h2><a class="header" href="#type-alias-bounds" id="type-alias-bounds">type-alias-bounds</a></h2>
<p>This lint detects bounds in type aliases. These are not currently enforced.
Some example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[allow(dead_code)]
type SendVec&lt;T: Send&gt; = Vec&lt;T&gt;;
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: bounds on generic parameters are not enforced in type aliases
 --&gt; src/lib.rs:2:17
  |
2 | type SendVec&lt;T: Send&gt; = Vec&lt;T&gt;;
  |                 ^^^^
  |
  = note: `#[warn(type_alias_bounds)]` on by default
  = help: the bound will not be checked when the type alias is used, and should be removed
</code></pre>
<h2><a class="header" href="#tyvar-behind-raw-pointer" id="tyvar-behind-raw-pointer">tyvar-behind-raw-pointer</a></h2>
<p>This lint detects raw pointer to an inference variable. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let data = std::ptr::null();
let _ = &amp;data as *const *const ();

if data.is_null() {}
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: type annotations needed
 --&gt; src/main.rs:4:13
  |
4 |     if data.is_null() {}
  |             ^^^^^^^
  |
  = note: `#[warn(tyvar_behind_raw_pointer)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!
  = note: for more information, see issue #46906 &lt;https://github.com/rust-lang/rust/issues/46906&gt;
</code></pre>
<h2><a class="header" href="#unconditional-recursion" id="unconditional-recursion">unconditional-recursion</a></h2>
<p>This lint detects functions that cannot return without calling themselves.
Some example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo() {
    foo();
}
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: function cannot return without recursing
 --&gt; src/main.rs:1:1
  |
1 | fn foo() {
  | ^^^^^^^^ cannot return without recursing
2 |     foo();
  |     ----- recursive call site
  |
</code></pre>
<h2><a class="header" href="#unions-with-drop-fields" id="unions-with-drop-fields">unions-with-drop-fields</a></h2>
<p>This lint detects use of unions that contain fields with possibly non-trivial drop code. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(untagged_unions)]

#fn main() {
union U {
    s: String,
}
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: union contains a field with possibly non-trivial drop code, drop code of union fields is ignored when dropping the union
 --&gt; src/main.rs:4:5
  |
4 |     s: String,
  |     ^^^^^^^^^
  |
</code></pre>
<h2><a class="header" href="#unknown-lints" id="unknown-lints">unknown-lints</a></h2>
<p>This lint detects unrecognized lint attribute. Some
example code that triggers this lint:</p>
<pre><code class="language-rust ignore">#[allow(not_a_real_lint)]
</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unknown lint: `not_a_real_lint`
 --&gt; src/main.rs:1:10
  |
1 | #![allow(not_a_real_lint)]
  |          ^^^^^^^^^^^^^^^
  |
</code></pre>
<h2><a class="header" href="#unreachable-code" id="unreachable-code">unreachable-code</a></h2>
<p>This lint detects unreachable code paths. Some example code that
triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
panic!(&quot;we never go past here!&quot;);

let x = 5;
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unreachable statement
 --&gt; src/main.rs:4:5
  |
4 |     let x = 5;
  |     ^^^^^^^^^^
  |
</code></pre>
<h2><a class="header" href="#unreachable-patterns" id="unreachable-patterns">unreachable-patterns</a></h2>
<p>This lint detects unreachable patterns. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
match x {
    y =&gt; (),
    5 =&gt; (),
}
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unreachable pattern
 --&gt; src/main.rs:5:5
  |
5 |     5 =&gt; (),
  |     ^
  |
</code></pre>
<p>The <code>y</code> pattern will always match, so the five is impossible to reach.
Remember, match arms match in order, you probably wanted to put the <code>5</code> case
above the <code>y</code> case.</p>
<h2><a class="header" href="#unstable-name-collision" id="unstable-name-collision">unstable-name-collision</a></h2>
<p>This lint detects that you've used a name that the standard library plans to
add in the future, which means that your code may fail to compile without
additional type annotations in the future. Either rename, or add those
annotations now.</p>
<h2><a class="header" href="#unused-allocation" id="unused-allocation">unused-allocation</a></h2>
<p>This lint detects unnecessary allocations that can be eliminated.</p>
<h2><a class="header" href="#unused-assignments" id="unused-assignments">unused-assignments</a></h2>
<p>This lint detects assignments that will never be read. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut x = 5;
x = 6;
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: value assigned to `x` is never read
 --&gt; src/main.rs:4:5
  |
4 |     x = 6;
  |     ^
  |
</code></pre>
<h2><a class="header" href="#unused-attributes" id="unused-attributes">unused-attributes</a></h2>
<p>This lint detects attributes that were not used by the compiler. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![macro_export]
#fn main() {
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unused attribute
 --&gt; src/main.rs:1:1
  |
1 | #![macro_export]
  | ^^^^^^^^^^^^^^^^
  |
</code></pre>
<h2><a class="header" href="#unused-comparisons" id="unused-comparisons">unused-comparisons</a></h2>
<p>This lint detects comparisons made useless by limits of the types involved. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(x: u8) {
    x &gt;= 0;
}
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: comparison is useless due to type limits
 --&gt; src/main.rs:6:5
  |
6 |     x &gt;= 0;
  |     ^^^^^^
  |
</code></pre>
<h2><a class="header" href="#unused-doc-comment" id="unused-doc-comment">unused-doc-comment</a></h2>
<p>This lint detects doc comments that aren't used by rustdoc. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// docs for x
let x = 12;
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: doc comment not used by rustdoc
 --&gt; src/main.rs:2:5
  |
2 |     /// docs for x
  |     ^^^^^^^^^^^^^^
  |
</code></pre>
<h2><a class="header" href="#unused-features" id="unused-features">unused-features</a></h2>
<p>This lint detects unused or unknown features found in crate-level <code>#[feature]</code> directives.
To fix this, simply remove the feature flag.</p>
<h2><a class="header" href="#unused-imports" id="unused-imports">unused-imports</a></h2>
<p>This lint detects imports that are never used. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unused import: `std::collections::HashMap`
 --&gt; src/main.rs:1:5
  |
1 | use std::collections::HashMap;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
</code></pre>
<h2><a class="header" href="#unused-macros" id="unused-macros">unused-macros</a></h2>
<p>This lint detects macros that were not used. Some example code that
triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">macro_rules! unused {
    () =&gt; {};
}

fn main() {
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unused macro definition
 --&gt; src/main.rs:1:1
  |
1 | / macro_rules! unused {
2 | |     () =&gt; {};
3 | | }
  | |_^
  |
</code></pre>
<h2><a class="header" href="#unused-must-use" id="unused-must-use">unused-must-use</a></h2>
<p>This lint detects unused result of a type flagged as <code>#[must_use]</code>. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">fn returns_result() -&gt; Result&lt;(), ()&gt; {
    Ok(())
}

fn main() {
    returns_result();
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unused `std::result::Result` that must be used
 --&gt; src/main.rs:6:5
  |
6 |     returns_result();
  |     ^^^^^^^^^^^^^^^^^
  |
</code></pre>
<h2><a class="header" href="#unused-mut" id="unused-mut">unused-mut</a></h2>
<p>This lint detects mut variables which don't need to be mutable. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut x = 5;
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: variable does not need to be mutable
 --&gt; src/main.rs:2:9
  |
2 |     let mut x = 5;
  |         ----^
  |         |
  |         help: remove this `mut`
  |
</code></pre>
<h2><a class="header" href="#unused-parens" id="unused-parens">unused-parens</a></h2>
<p>This lint detects <code>if</code>, <code>match</code>, <code>while</code> and <code>return</code> with parentheses; they
do not need them. Some example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
if(true) {}
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unnecessary parentheses around `if` condition
 --&gt; src/main.rs:2:7
  |
2 |     if(true) {}
  |       ^^^^^^ help: remove these parentheses
  |
</code></pre>
<h2><a class="header" href="#unused-unsafe" id="unused-unsafe">unused-unsafe</a></h2>
<p>This lint detects unnecessary use of an <code>unsafe</code> block. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
unsafe {}
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unnecessary `unsafe` block
 --&gt; src/main.rs:2:5
  |
2 |     unsafe {}
  |     ^^^^^^ unnecessary `unsafe` block
  |
</code></pre>
<h2><a class="header" href="#unused-variables" id="unused-variables">unused-variables</a></h2>
<p>This lint detects variables which are not used in any way. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unused variable: `x`
 --&gt; src/main.rs:2:9
  |
2 |     let x = 5;
  |         ^ help: consider using `_x` instead
  |
</code></pre>
<h2><a class="header" href="#warnings" id="warnings">warnings</a></h2>
<p>This lint is a bit special; by changing its level, you change every other warning
that would produce a warning to whatever value you'd like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![deny(warnings)]
#fn main() {
#}</code></pre></pre>
<p>As such, you won't ever trigger this lint in your code directly.</p>
<h2><a class="header" href="#while-true" id="while-true">while-true</a></h2>
<p>This lint detects <code>while true { }</code>. Some example code that triggers this
lint:</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
while true {

}
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: denote infinite loops with `loop { ... }`
 --&gt; src/main.rs:2:5
  |
2 |     while true {
  |     ^^^^^^^^^^ help: use `loop`
  |
</code></pre>
<h1><a class="header" href="#deny-by-default-lints" id="deny-by-default-lints">Deny-by-default lints</a></h1>
<p>These lints are all set to the 'deny' level by default.</p>
<h2><a class="header" href="#exceeding-bitshifts" id="exceeding-bitshifts">exceeding-bitshifts</a></h2>
<p>This lint detects that a shift exceeds the type's number of bits. Some
example code that triggers this lint:</p>
<pre><code class="language-rust ignore">1_i32 &lt;&lt; 32;
</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: bitshift exceeds the type's number of bits
 --&gt; src/main.rs:2:5
  |
2 |     1_i32 &lt;&lt; 32;
  |     ^^^^^^^^^^^
  |
</code></pre>
<h2><a class="header" href="#invalid-type-param-default" id="invalid-type-param-default">invalid-type-param-default</a></h2>
<p>This lint detects type parameter default erroneously allowed in invalid location. Some
example code that triggers this lint:</p>
<pre><code class="language-rust ignore">fn foo&lt;T=i32&gt;(t: T) {}
</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: defaults for type parameters are only allowed in `struct`, `enum`, `type`, or `trait` definitions.
 --&gt; src/main.rs:4:8
  |
4 | fn foo&lt;T=i32&gt;(t: T) {}
  |        ^
  |
  = note: `#[deny(invalid_type_param_default)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #36887 &lt;https://github.com/rust-lang/rust/issues/36887&gt;
</code></pre>
<h2><a class="header" href="#legacy-constructor-visibility" id="legacy-constructor-visibility">legacy-constructor-visibility</a></h2>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/1506-adt-kinds.md">RFC 1506</a> modified some
visibility rules, and changed the visibility of struct constructors. Some
example code that triggers this lint:</p>
<pre><code class="language-rust ignore">mod m {
    pub struct S(u8);
    
    fn f() {
        // this is trying to use S from the 'use' line, but because the `u8` is
        // not pub, it is private
        ::S;
    }
}

use m::S;
</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: private struct constructors are not usable through re-exports in outer modules
 --&gt; src/main.rs:5:9
  |
5 |         ::S;
  |         ^^^
  |
  = note: `#[deny(legacy_constructor_visibility)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #39207 &lt;https://github.com/rust-lang/rust/issues/39207&gt;
</code></pre>
<h2><a class="header" href="#legacy-directory-ownership" id="legacy-directory-ownership">legacy-directory-ownership</a></h2>
<p>The legacy_directory_ownership warning is issued when</p>
<ul>
<li>There is a non-inline module with a <code>#[path]</code> attribute (e.g. <code>#[path = &quot;foo.rs&quot;] mod bar;</code>),</li>
<li>The module's file (&quot;foo.rs&quot; in the above example) is not named &quot;mod.rs&quot;, and</li>
<li>The module's file contains a non-inline child module without a <code>#[path]</code> attribute.</li>
</ul>
<p>The warning can be fixed by renaming the parent module to &quot;mod.rs&quot; and moving
it into its own directory if appropriate.</p>
<h2><a class="header" href="#missing-fragment-specifier" id="missing-fragment-specifier">missing-fragment-specifier</a></h2>
<p>The missing_fragment_specifier warning is issued when an unused pattern in a
<code>macro_rules!</code> macro definition has a meta-variable (e.g. <code>$e</code>) that is not
followed by a fragment specifier (e.g. <code>:expr</code>).</p>
<p>This warning can always be fixed by removing the unused pattern in the
<code>macro_rules!</code> macro definition.</p>
<h2><a class="header" href="#mutable-transmutes" id="mutable-transmutes">mutable-transmutes</a></h2>
<p>This lint catches transmuting from <code>&amp;T</code> to <code>&amp;mut T</code> because it is undefined
behavior. Some example code that triggers this lint:</p>
<pre><code class="language-rust ignore">unsafe {
    let y = std::mem::transmute::&lt;&amp;i32, &amp;mut i32&gt;(&amp;5);
}
</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: mutating transmuted &amp;mut T from &amp;T may cause undefined behavior, consider instead using an UnsafeCell
 --&gt; src/main.rs:3:17
  |
3 |         let y = std::mem::transmute::&lt;&amp;i32, &amp;mut i32&gt;(&amp;5);
  |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
</code></pre>
<h2><a class="header" href="#no-mangle-const-items" id="no-mangle-const-items">no-mangle-const-items</a></h2>
<p>This lint detects any <code>const</code> items with the <code>#[no_mangle]</code> attribute.
Constants do not have their symbols exported, and therefore, this probably
means you meant to use a <code>static</code>, not a <code>const</code>. Some example code that
triggers this lint:</p>
<pre><code class="language-rust ignore">#[no_mangle]
const FOO: i32 = 5;
</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: const items should never be `#[no_mangle]`
 --&gt; src/main.rs:3:1
  |
3 | const FOO: i32 = 5;
  | -----^^^^^^^^^^^^^^
  | |
  | help: try a static value: `pub static`
  |
</code></pre>
<h2><a class="header" href="#overflowing-literals" id="overflowing-literals">overflowing-literals</a></h2>
<p>This lint detects literal out of range for its type. Some
example code that triggers this lint:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
# #![allow(unused_variables)]
#fn main() {
let x: u8 = 1000;
#}</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: literal out of range for u8
 --&gt; src/main.rs:2:17
  |
2 |     let x: u8 = 1000;
  |                 ^^^^
  |
</code></pre>
<h2><a class="header" href="#parenthesized-params-in-types-and-modules" id="parenthesized-params-in-types-and-modules">parenthesized-params-in-types-and-modules</a></h2>
<p>This lint detects incorrect parentheses. Some example code that triggers this
lint:</p>
<pre><code class="language-rust ignore">let x = 5 as usize();
</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: parenthesized parameters may only be used with a trait
 --&gt; src/main.rs:2:21
  |
2 |   let x = 5 as usize();
  |                     ^^
  |
  = note: `#[deny(parenthesized_params_in_types_and_modules)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #42238 &lt;https://github.com/rust-lang/rust/issues/42238&gt;
</code></pre>
<p>To fix it, remove the <code>()</code>s.</p>
<h2><a class="header" href="#pub-use-of-private-extern-crate" id="pub-use-of-private-extern-crate">pub-use-of-private-extern-crate</a></h2>
<p>This lint detects a specific situation of re-exporting a private <code>extern crate</code>;</p>
<h2><a class="header" href="#safe-extern-statics" id="safe-extern-statics">safe-extern-statics</a></h2>
<p>In older versions of Rust, there was a soundness issue where <code>extern static</code>s were allowed
to be accessed in safe code. This lint now catches and denies this kind of code.</p>
<h2><a class="header" href="#unknown-crate-types" id="unknown-crate-types">unknown-crate-types</a></h2>
<p>This lint detects an unknown crate type found in a <code>#[crate_type]</code> directive. Some
example code that triggers this lint:</p>
<pre><code class="language-rust ignore">#![crate_type=&quot;lol&quot;]
</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: invalid `crate_type` value
 --&gt; src/lib.rs:1:1
  |
1 | #![crate_type=&quot;lol&quot;]
  | ^^^^^^^^^^^^^^^^^^^^
  |
</code></pre>
<h1><a class="header" href="#codegen-options" id="codegen-options">Codegen options</a></h1>
<p>All of these options are passed to <code>rustc</code> via the <code>-C</code> flag, short for &quot;codegen.&quot; You can see
a version of this list for your exact compiler by running <code>rustc -C help</code>.</p>
<h2><a class="header" href="#ar" id="ar">ar</a></h2>
<p>This option is deprecated and does nothing.</p>
<h2><a class="header" href="#linker" id="linker">linker</a></h2>
<p>This flag lets you control which linker <code>rustc</code> invokes to link your code.</p>
<h2><a class="header" href="#link-argval" id="link-argval">link-arg=val</a></h2>
<p>This flag lets you append a single extra argument to the linker invocation.</p>
<p>&quot;Append&quot; is significant; you can pass this flag multiple times to add multiple arguments.</p>
<h2><a class="header" href="#link-args" id="link-args">link-args</a></h2>
<p>This flag lets you append multiple extra arguments to the linker invocation. The
options should be separated by spaces.</p>
<h2><a class="header" href="#linker-flavor" id="linker-flavor">linker-flavor</a></h2>
<p>This flag lets you control the linker flavor used by <code>rustc</code>. If a linker is given with the
<code>-C linker</code> flag described above then the linker flavor is inferred from the value provided. If no
linker is given then the linker flavor is used to determine the linker to use. Every <code>rustc</code> target
defaults to some linker flavor.</p>
<h2><a class="header" href="#link-dead-code" id="link-dead-code">link-dead-code</a></h2>
<p>Normally, the linker will remove dead code. This flag disables this behavior.</p>
<p>An example of when this flag might be useful is when trying to construct code coverage
metrics.</p>
<h2><a class="header" href="#lto" id="lto">lto</a></h2>
<p>This flag instructs LLVM to use <a href="https://llvm.org/docs/LinkTimeOptimization.html">link time
optimizations</a>.</p>
<p>It takes one of two values, <code>thin</code> and <code>fat</code>. 'thin' LTO <a href="http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html">is a new feature of
LLVM</a>,
'fat' referring to the classic version of LTO.</p>
<h2><a class="header" href="#target-cpu" id="target-cpu">target-cpu</a></h2>
<p>This instructs <code>rustc</code> to generate code specifically for a particular processor.</p>
<p>You can run <code>rustc --print target-cpus</code> to see the valid options to pass
here. Additionally, <code>native</code> can be passed to use the processor of the host
machine.</p>
<h2><a class="header" href="#target-feature" id="target-feature">target-feature</a></h2>
<p>Individual targets will support different features; this flag lets you control
enabling or disabling a feature.</p>
<p>To see the valid options and an example of use, run <code>rustc --print target-features</code>.</p>
<h2><a class="header" href="#passes" id="passes">passes</a></h2>
<p>This flag can be used to add extra LLVM passes to the compilation.</p>
<p>The list must be separated by spaces.</p>
<h2><a class="header" href="#llvm-args" id="llvm-args">llvm-args</a></h2>
<p>This flag can be used to pass a list of arguments directly to LLVM.</p>
<p>The list must be separated by spaces.</p>
<h2><a class="header" href="#save-temps" id="save-temps">save-temps</a></h2>
<p><code>rustc</code> will generate temporary files during compilation; normally it will
delete them after it's done with its work. This option will cause them to be
preserved instead of removed.</p>
<h2><a class="header" href="#rpath" id="rpath">rpath</a></h2>
<p>This option allows you to set the value of
<a href="https://en.wikipedia.org/wiki/Rpath"><code>rpath</code></a>.</p>
<h2><a class="header" href="#overflow-checks" id="overflow-checks">overflow-checks</a></h2>
<p>This flag allows you to control the behavior of integer overflow. This flag
can be passed many options:</p>
<ul>
<li>To turn overflow checks on: <code>y</code>, <code>yes</code>, or <code>on</code>.</li>
<li>To turn overflow checks off: <code>n</code>, <code>no</code>, or <code>off</code>.</li>
</ul>
<h2><a class="header" href="#no-prepopulate-passes" id="no-prepopulate-passes">no-prepopulate-passes</a></h2>
<p>The pass manager comes pre-populated with a list of passes; this flag
ensures that list is empty.</p>
<h2><a class="header" href="#no-vectorize-loops" id="no-vectorize-loops">no-vectorize-loops</a></h2>
<p>By default, <code>rustc</code> will attempt to <a href="https://llvm.org/docs/Vectorizers.html#the-loop-vectorizer">vectorize
loops</a>. This
flag will turn that behavior off.</p>
<h2><a class="header" href="#no-vectorize-slp" id="no-vectorize-slp">no-vectorize-slp</a></h2>
<p>By default, <code>rustc</code> will attempt to vectorize loops using <a href="https://llvm.org/docs/Vectorizers.html#the-slp-vectorizer">superword-level
parallelism</a>. This
flag will turn that behavior off.</p>
<h2><a class="header" href="#soft-float" id="soft-float">soft-float</a></h2>
<p>This option will make <code>rustc</code> generate code using &quot;soft floats.&quot; By default,
a lot of hardware supports floating point instructions, and so the code generated
will take advantage of this. &quot;soft floats&quot; emulate floating point instructions
in software.</p>
<h2><a class="header" href="#prefer-dynamic" id="prefer-dynamic">prefer-dynamic</a></h2>
<p>By default, <code>rustc</code> prefers to statically link dependencies. This option will
make it use dynamic linking instead.</p>
<h2><a class="header" href="#no-integrated-as" id="no-integrated-as">no-integrated-as</a></h2>
<p>LLVM comes with an internal assembler; this option will let you use an
external assembler instead.</p>
<h2><a class="header" href="#no-redzone" id="no-redzone">no-redzone</a></h2>
<p>This flag allows you to disable <a href="https://en.wikipedia.org/wiki/Red_zone_(computing)">the
red zone</a>. This flag can
be passed many options:</p>
<ul>
<li>To enable the red zone: <code>y</code>, <code>yes</code>, or <code>on</code>.</li>
<li>To disable it: <code>n</code>, <code>no</code>, or <code>off</code>.</li>
</ul>
<h2><a class="header" href="#relocation-model" id="relocation-model">relocation-model</a></h2>
<p>This option lets you choose which relocation model to use.</p>
<p>To find the valid options for this flag, run <code>rustc --print relocation-models</code>.</p>
<h2><a class="header" href="#code-modelval" id="code-modelval">code-model=val</a></h2>
<p>This option lets you choose which code model to use.</p>
<p>To find the valid options for this flag, run <code>rustc --print code-models</code>.</p>
<h2><a class="header" href="#metadata" id="metadata">metadata</a></h2>
<p>This option allows you to control the metadata used for symbol mangling.</p>
<h2><a class="header" href="#extra-filename" id="extra-filename">extra-filename</a></h2>
<p>This option allows you to put extra data in each output filename.</p>
<h2><a class="header" href="#codegen-units" id="codegen-units">codegen-units</a></h2>
<p>This flag lets you control how many threads are used when doing
code generation.</p>
<p>Increasing parallelism may speed up compile times, but may also
produce slower code.</p>
<h2><a class="header" href="#remark" id="remark">remark</a></h2>
<p>This flag lets you print remarks for these optimization passes.</p>
<p>The list of passes should be separated by spaces.</p>
<p><code>all</code> will remark on every pass.</p>
<h2><a class="header" href="#no-stack-check" id="no-stack-check">no-stack-check</a></h2>
<p>This option is deprecated and does nothing.</p>
<h2><a class="header" href="#debuginfo" id="debuginfo">debuginfo</a></h2>
<p>This flag lets you control debug information:</p>
<ul>
<li><code>0</code>: no debug info at all</li>
<li><code>1</code>: line tables only</li>
<li><code>2</code>: full debug info</li>
</ul>
<h2><a class="header" href="#opt-level" id="opt-level">opt-level</a></h2>
<p>This flag lets you control the optimization level.</p>
<ul>
<li><code>0</code>: no optimizations, also turn on <code>cfg(debug_assertions)</code>.</li>
<li><code>1</code>: basic optimizations</li>
<li><code>2</code>: some optimizations</li>
<li><code>3</code>: all optimizations</li>
<li><code>s</code>: optimize for binary size</li>
<li><code>z</code>: optimize for binary size, but also turn off loop vectorization.</li>
</ul>
<h2><a class="header" href="#debug-assertions" id="debug-assertions">debug-assertions</a></h2>
<p>This flag lets you turn <code>cfg(debug_assertions)</code> on or off.</p>
<h2><a class="header" href="#inline-threshold" id="inline-threshold">inline-threshold</a></h2>
<p>This option lets you set the threshold for inlining a function.</p>
<p>The default is 225.</p>
<h2><a class="header" href="#panic" id="panic">panic</a></h2>
<p>This option lets you control what happens when the code panics.</p>
<ul>
<li><code>abort</code>: terminate the process upon panic</li>
<li><code>unwind</code>: unwind the stack upon panic</li>
</ul>
<h2><a class="header" href="#incremental" id="incremental">incremental</a></h2>
<p>This flag allows you to enable incremental compilation.</p>
<h2><a class="header" href="#profile-generate" id="profile-generate">profile-generate</a></h2>
<p>This flag allows for creating instrumented binaries that will collect
profiling data for use with profile-guided optimization (PGO). The flag takes
an optional argument which is the path to a directory into which the
instrumented binary will emit the collected data. See the chapter on
<a href="codegen-options/../profile-guided-optimization.html">profile-guided optimization</a> for more information.</p>
<h2><a class="header" href="#profile-use" id="profile-use">profile-use</a></h2>
<p>This flag specifies the profiling data file to be used for profile-guided
optimization (PGO). The flag takes a mandatory argument which is the path
to a valid <code>.profdata</code> file. See the chapter on
<a href="codegen-options/../profile-guided-optimization.html">profile-guided optimization</a> for more information.</p>
<h1><a class="header" href="#targets" id="targets">Targets</a></h1>
<p><code>rustc</code> is a cross-compiler by default. This means that you can use any compiler to build for any
architecture. The list of <em>targets</em> are the possible architectures that you can build for.</p>
<p>To see all the options that you can set with a target, see the docs
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_target/spec/struct.Target.html">here</a>.</p>
<p>To compile to a particular target, use the <code>--target</code> flag:</p>
<pre><code class="language-bash">$ rustc src/main.rs --target=wasm32-unknown-unknown
</code></pre>
<h1><a class="header" href="#built-in-targets" id="built-in-targets">Built-in Targets</a></h1>
<p><code>rustc</code> ships with the ability to compile to many targets automatically, we
call these &quot;built-in&quot; targets, and they generally correspond to targets that
the team is supporting directly.</p>
<p>To see the list of built-in targets, you can run <code>rustc --print target-list</code>,
or look at <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_target/spec/index.html#modules">the API
docs</a>.
Each module there defines a builder for a particular target.</p>
<h1><a class="header" href="#custom-targets" id="custom-targets">Custom Targets</a></h1>
<p>If you'd like to build for a target that is not yet supported by <code>rustc</code>, you can use a
&quot;custom target specification&quot; to define a target. These target specification files
are JSON. To see the JSON for the host target, you can run:</p>
<pre><code class="language-bash">$ rustc +nightly -Z unstable-options --print target-spec-json
</code></pre>
<p>To see it for a different target, add the <code>--target</code> flag:</p>
<pre><code class="language-bash">$ rustc +nightly -Z unstable-options --target=wasm32-unknown-unknown --print target-spec-json
</code></pre>
<p>To use a custom target, see <a href="https://github.com/japaric/xargo"><code>xargo</code></a>.</p>
<h1><a class="header" href="#profile-guided-optimization" id="profile-guided-optimization">Profile Guided Optimization</a></h1>
<p><code>rustc</code> supports doing profile-guided optimization (PGO).
This chapter describes what PGO is, what it is good for, and how it can be used.</p>
<h2><a class="header" href="#what-is-profiled-guided-optimization" id="what-is-profiled-guided-optimization">What Is Profiled-Guided Optimization?</a></h2>
<p>The basic concept of PGO is to collect data about the typical execution of
a program (e.g. which branches it is likely to take) and then use this data
to inform optimizations such as inlining, machine-code layout,
register allocation, etc.</p>
<p>There are different ways of collecting data about a program's execution.
One is to run the program inside a profiler (such as <code>perf</code>) and another
is to create an instrumented binary, that is, a binary that has data
collection built into it, and run that.
The latter usually provides more accurate data and it is also what is
supported by <code>rustc</code>.</p>
<h2><a class="header" href="#usage" id="usage">Usage</a></h2>
<p>Generating a PGO-optimized program involves following a workflow with four steps:</p>
<ol>
<li>Compile the program with instrumentation enabled
(e.g. <code>rustc -Cprofile-generate=/tmp/pgo-data main.rs</code>)</li>
<li>Run the instrumented program (e.g. <code>./main</code>) which generates a
<code>default_&lt;id&gt;.profraw</code> file</li>
<li>Convert the <code>.profraw</code> file into a <code>.profdata</code> file using
LLVM's <code>llvm-profdata</code> tool</li>
<li>Compile the program again, this time making use of the profiling data
(for example <code>rustc -Cprofile-use=merged.profdata main.rs</code>)</li>
</ol>
<p>An instrumented program will create one or more <code>.profraw</code> files, one for each
instrumented binary. E.g. an instrumented executable that loads two instrumented
dynamic libraries at runtime will generate three <code>.profraw</code> files. Running an
instrumented binary multiple times, on the other hand, will re-use the
respective <code>.profraw</code> files, updating them in place.</p>
<p>These <code>.profraw</code> files have to be post-processed before they can be fed back
into the compiler. This is done by the <code>llvm-profdata</code> tool. This tool
is most easily installed via</p>
<pre><code class="language-bash">rustup component add llvm-tools-preview
</code></pre>
<p>Note that installing the <code>llvm-tools-preview</code> component won't add
<code>llvm-profdata</code> to the <code>PATH</code>. Rather, the tool can be found in:</p>
<pre><code class="language-bash">~/.rustup/toolchains/&lt;toolchain&gt;/lib/rustlib/&lt;target-triple&gt;/bin/
</code></pre>
<p>Alternatively, an <code>llvm-profdata</code> coming with a recent LLVM or Clang
version usually works too.</p>
<p>The <code>llvm-profdata</code> tool merges multiple <code>.profraw</code> files into a single
<code>.profdata</code> file that can then be fed back into the compiler via
<code>-Cprofile-use</code>:</p>
<pre><code class="language-bash"># STEP 1: Compile the binary with instrumentation
rustc -Cprofile-generate=/tmp/pgo-data -O ./main.rs

# STEP 2: Run the binary a few times, maybe with common sets of args.
#         Each run will create or update `.profraw` files in /tmp/pgo-data
./main mydata1.csv
./main mydata2.csv
./main mydata3.csv

# STEP 3: Merge and post-process all the `.profraw` files in /tmp/pgo-data
llvm-profdata merge -o ./merged.profdata /tmp/pgo-data

# STEP 4: Use the merged `.profdata` file during optimization. All `rustc`
#         flags have to be the same.
rustc -Cprofile-use=./merged.profdata -O ./main.rs
</code></pre>
<h3><a class="header" href="#a-complete-cargo-workflow" id="a-complete-cargo-workflow">A Complete Cargo Workflow</a></h3>
<p>Using this feature with Cargo works very similar to using it with <code>rustc</code>
directly. Again, we generate an instrumented binary, run it to produce data,
merge the data, and feed it back into the compiler. Some things of note:</p>
<ul>
<li>
<p>We use the <code>RUSTFLAGS</code> environment variable in order to pass the PGO compiler
flags to the compilation of all crates in the program.</p>
</li>
<li>
<p>We pass the <code>--target</code> flag to Cargo, which prevents the <code>RUSTFLAGS</code>
arguments to be passed to Cargo build scripts. We don't want the build
scripts to generate a bunch of <code>.profraw</code> files.</p>
</li>
<li>
<p>We pass <code>--release</code> to Cargo because that's where PGO makes the most sense.
In theory, PGO can also be done on debug builds but there is little reason
to do so.</p>
</li>
<li>
<p>It is recommended to use <em>absolute paths</em> for the argument of
<code>-Cprofile-generate</code> and <code>-Cprofile-use</code>. Cargo can invoke <code>rustc</code> with
varying working directories, meaning that <code>rustc</code> will not be able to find
the supplied <code>.profdata</code> file. With absolute paths this is not an issue.</p>
</li>
<li>
<p>It is good practice to make sure that there is no left-over profiling data
from previous compilation sessions. Just deleting the directory is a simple
way of doing so (see <code>STEP 0</code> below).</p>
</li>
</ul>
<p>This is what the entire workflow looks like:</p>
<pre><code class="language-bash"># STEP 0: Make sure there is no left-over profiling data from previous runs
rm -rf /tmp/pgo-data

# STEP 1: Build the instrumented binaries
RUSTFLAGS=&quot;-Cprofile-generate=/tmp/pgo-data&quot; \
    cargo build --release --target=x86_64-unknown-linux-gnu

# STEP 2: Run the instrumented binaries with some typical data
./target/x86_64-unknown-linux-gnu/release/myprogram mydata1.csv
./target/x86_64-unknown-linux-gnu/release/myprogram mydata2.csv
./target/x86_64-unknown-linux-gnu/release/myprogram mydata3.csv

# STEP 3: Merge the `.profraw` files into a `.profdata` file
llvm-profdata merge -o /tmp/pgo-data/merged.profdata /tmp/pgo-data

# STEP 4: Use the `.profdata` file for guiding optimizations
RUSTFLAGS=&quot;-Cprofile-use=/tmp/pgo-data/merged.profdata&quot; \
    cargo build --release --target=x86_64-unknown-linux-gnu
</code></pre>
<h3><a class="header" href="#troubleshooting" id="troubleshooting">Troubleshooting</a></h3>
<ul>
<li>
<p>It is recommended to pass <code>-Cllvm-args=-pgo-warn-missing-function</code> during the
<code>-Cprofile-use</code> phase. LLVM by default does not warn if it cannot find
profiling data for a given function. Enabling this warning will make it
easier to spot errors in your setup.</p>
</li>
<li>
<p>There is a <a href="https://github.com/rust-lang/cargo/issues/7416">known issue</a> in
Cargo prior to version 1.39 that will prevent PGO from working correctly. Be
sure to use Cargo 1.39 or newer when doing PGO.</p>
</li>
</ul>
<h2><a class="header" href="#further-reading" id="further-reading">Further Reading</a></h2>
<p><code>rustc</code>'s PGO support relies entirely on LLVM's implementation of the feature
and is equivalent to what Clang offers via the <code>-fprofile-generate</code> /
<code>-fprofile-use</code> flags. The <a href="https://clang.llvm.org/docs/UsersManual.html#profile-guided-optimization">Profile Guided Optimization</a> section
in Clang's documentation is therefore an interesting read for anyone who wants
to use PGO with Rust.</p>
<h1><a class="header" href="#linker-plugin-lto" id="linker-plugin-lto">Linker-plugin-LTO</a></h1>
<p>The <code>-C linker-plugin-lto</code> flag allows for deferring the LTO optimization
to the actual linking step, which in turn allows for performing
interprocedural optimizations across programming language boundaries if
all the object files being linked were created by LLVM based toolchains.
The prime example here would be linking Rust code together with
Clang-compiled C/C++ code.</p>
<h2><a class="header" href="#usage-1" id="usage-1">Usage</a></h2>
<p>There are two main cases how linker plugin based LTO can be used:</p>
<ul>
<li>compiling a Rust <code>staticlib</code> that is used as a C ABI dependency</li>
<li>compiling a Rust binary where <code>rustc</code> invokes the linker</li>
</ul>
<p>In both cases the Rust code has to be compiled with <code>-C linker-plugin-lto</code> and
the C/C++ code with <code>-flto</code> or <code>-flto=thin</code> so that object files are emitted
as LLVM bitcode.</p>
<h3><a class="header" href="#rust-staticlib-as-dependency-in-cc-program" id="rust-staticlib-as-dependency-in-cc-program">Rust <code>staticlib</code> as dependency in C/C++ program</a></h3>
<p>In this case the Rust compiler just has to make sure that the object files in
the <code>staticlib</code> are in the right format. For linking, a linker with the
LLVM plugin must be used (e.g. LLD).</p>
<p>Using <code>rustc</code> directly:</p>
<pre><code class="language-bash"># Compile the Rust staticlib
rustc --crate-type=staticlib -Clinker-plugin-lto -Copt-level=2 ./lib.rs
# Compile the C code with `-flto=thin`
clang -c -O2 -flto=thin -o main.o ./main.c
# Link everything, making sure that we use an appropriate linker
clang -flto=thin -fuse-ld=lld -L . -l&quot;name-of-your-rust-lib&quot; -o main -O2 ./cmain.o
</code></pre>
<p>Using <code>cargo</code>:</p>
<pre><code class="language-bash"># Compile the Rust staticlib
RUSTFLAGS=&quot;-Clinker-plugin-lto&quot; cargo build --release
# Compile the C code with `-flto=thin`
clang -c -O2 -flto=thin -o main.o ./main.c
# Link everything, making sure that we use an appropriate linker
clang -flto=thin -fuse-ld=lld -L . -l&quot;name-of-your-rust-lib&quot; -o main -O2 ./cmain.o
</code></pre>
<h3><a class="header" href="#cc-code-as-a-dependency-in-rust" id="cc-code-as-a-dependency-in-rust">C/C++ code as a dependency in Rust</a></h3>
<p>In this case the linker will be invoked by <code>rustc</code>. We again have to make sure
that an appropriate linker is used.</p>
<p>Using <code>rustc</code> directly:</p>
<pre><code class="language-bash"># Compile C code with `-flto`
clang ./clib.c -flto=thin -c -o ./clib.o -O2
# Create a static library from the C code
ar crus ./libxyz.a ./clib.o

# Invoke `rustc` with the additional arguments
rustc -Clinker-plugin-lto -L. -Copt-level=2 -Clinker=clang -Clink-arg=-fuse-ld=lld ./main.rs
</code></pre>
<p>Using <code>cargo</code> directly:</p>
<pre><code class="language-bash"># Compile C code with `-flto`
clang ./clib.c -flto=thin -c -o ./clib.o -O2
# Create a static library from the C code
ar crus ./libxyz.a ./clib.o

# Set the linking arguments via RUSTFLAGS
RUSTFLAGS=&quot;-Clinker-plugin-lto -Clinker=clang -Clink-arg=-fuse-ld=lld&quot; cargo build --release
</code></pre>
<h3><a class="header" href="#explicitly-specifying-the-linker-plugin-to-be-used-by-rustc" id="explicitly-specifying-the-linker-plugin-to-be-used-by-rustc">Explicitly specifying the linker plugin to be used by <code>rustc</code></a></h3>
<p>If one wants to use a linker other than LLD, the LLVM linker plugin has to be
specified explicitly. Otherwise the linker cannot read the object files. The
path to the plugin is passed as an argument to the <code>-Clinker-plugin-lto</code>
option:</p>
<pre><code class="language-bash">rustc -Clinker-plugin-lto=&quot;/path/to/LLVMgold.so&quot; -L. -Copt-level=2 ./main.rs
</code></pre>
<h2><a class="header" href="#toolchain-compatibility" id="toolchain-compatibility">Toolchain Compatibility</a></h2>
<p>In order for this kind of LTO to work, the LLVM linker plugin must be able to
handle the LLVM bitcode produced by both <code>rustc</code> and <code>clang</code>.</p>
<p>Best results are achieved by using a <code>rustc</code> and <code>clang</code> that are based on the
exact same version of LLVM. One can use <code>rustc -vV</code> in order to view the LLVM
used by a given <code>rustc</code> version. Note that the version number given
here is only an approximation as Rust sometimes uses unstable revisions of
LLVM. However, the approximation is usually reliable.</p>
<p>The following table shows known good combinations of toolchain versions.</p>
<table><thead><tr><th></th><th>Clang 7</th><th>Clang 8</th></tr></thead><tbody>
<tr><td>Rust 1.34</td><td>✗</td><td>✓</td></tr>
<tr><td>Rust 1.35</td><td>✗</td><td>✓</td></tr>
<tr><td>Rust 1.36</td><td>✗</td><td>✓</td></tr>
<tr><td>Rust 1.37</td><td>✗</td><td>✓</td></tr>
</tbody></table>
<p>Note that the compatibility policy for this feature might change in the future.</p>
<h1><a class="header" href="#contributing-to-rustc" id="contributing-to-rustc">Contributing to rustc</a></h1>
<p>We'd love to have your help improving <code>rustc</code>! To that end, we've written <a href="https://rust-lang.github.io/rustc-guide/">a
whole book</a> on its
internals, how it works, and how to get started working on it. To learn
more, you'll want to check that out.</p>
<p>If you would like to contribute to <em>this</em> book, you can find its source in the
rustc source at <a href="https://github.com/rust-lang/rust/tree/master/src/doc/rustc">src/doc/rustc</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
