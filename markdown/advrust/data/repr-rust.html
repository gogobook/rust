<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>repr(Rust)</title>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        
    </head>
    <body class="vscode-light">
        <h1 id="reprrust">repr(Rust)</h1>
<blockquote>
<p>原文跟踪<a href="https://github.com/rust-lang-nursery/nomicon/blob/master/src/repr-rust.md">repr-rust.md</a>   Commit: 7f019ec5c87da39fe0b9b5149e413d914528e945</p>
</blockquote>
<p>首先，所有类型都以指定的字节数为单位进行对齐。类型的对齐单位确定了哪些地址能有效地存储值。 一个<code>n</code>字节对齐的值只能存储在一个<code>n</code>的整数倍地址上。 因此，2字节对齐意味着你必须存储在偶数地址上，1字节对齐表示你可以存放在任何地址上。对齐单位最小为1字节，通常是2的整数次幂。</p>
<p>原生类型的对齐单位通常与它们的大小一致，但是这也取决于特定的平台。 例如，在x86上，<code>u64</code>和<code>f64</code>通常是4字节（32位）对齐的。</p>
<p>类型的大小必须始终是其对齐单位的整数倍。 这确保了该类型的数组可以始终通过偏移其大小的整数倍进行索引。 需要注意的是，对于<a href="https://rustlang-cn.org/office/rust/advrust/data/exotic-sizes.html#dynamically-sized-types-dsts">动态大小的类型</a>，其大小和对齐单位可能无法静态地确定。</p>
<p>Rust为您提供了以下几种复合类型进行数据布局（译者注：关于<code>和类型</code>与<code>积类型</code>，可参考维基百科词条<a href="https://en.wikipedia.org/wiki/Algebraic_data_type">代数数据类型</a>）：</p>
<ul>
<li>structs（命名的积类型）</li>
<li>tuples（匿名的积类型）</li>
<li>arrays（同类型的积类型）</li>
<li>enums （命名的和类型 - 带标签的<code>unions</code>）</li>
<li>unions（无标签的<code>unions</code>）</li>
</ul>
<p>如果一个enum类型的所有成员都没有关联数据，则称这个enum是<strong>field-less</strong>的。</p>
<p>默认情况下，复合结构体的对齐单位等于它所有成员字段的对齐单位的最大值。因此，Rust会在必要时插入填充字段，以确保所有字段都能够正确地对齐，并且整个类型的大小是其对齐单位的整数倍。例如：</p>
<pre><code class="language-rust"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span> {
    a: <span class="hljs-built_in">u8</span>,
    b: <span class="hljs-built_in">u32</span>,
    c: <span class="hljs-built_in">u16</span>,
}
</div></code></pre>
<p>将在目标机器上进行32位对齐，将这些原生类型进行以合适大小进行对齐。因此整个结构体的大小是32位的倍数。它可能会变成：</p>
<pre><code class="language-rust"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span> {
    a: <span class="hljs-built_in">u8</span>,
    _pad1: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">3</span>], <span class="hljs-comment">// to align `b`</span>
    b: <span class="hljs-built_in">u32</span>,
    c: <span class="hljs-built_in">u16</span>,
    _pad2: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">2</span>], <span class="hljs-comment">// to make overall size multiple of 4</span>
}
</div></code></pre>
<p>或者可能变成：</p>
<pre><code class="language-rust"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span> {
    b: <span class="hljs-built_in">u32</span>,
    c: <span class="hljs-built_in">u16</span>,
    a: <span class="hljs-built_in">u8</span>,
    _pad: <span class="hljs-built_in">u8</span>,
}
</div></code></pre>
<p><strong>毫无意外</strong>，所有数据都存储在结构中，正如您在C中所期望的那样。但是，除了数组（按顺序紧凑排列）之外，默认情况下，Rust没有指定数据结构的内存布局。给出以下两个结构体定义：</p>
<pre><code class="language-rust"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span> {
    a: <span class="hljs-built_in">i32</span>,
    b: <span class="hljs-built_in">u64</span>,
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span></span> {
    a: <span class="hljs-built_in">i32</span>,
    b: <span class="hljs-built_in">u64</span>,
}
</div></code></pre>
<p>Rust <strong>保证</strong> <code>A</code>的两个实例会以完全相同的方式布局它们的数据。但目前而言，Rust 不保证A的实例与B的实例具有相同的字段排序或填充字段。</p>
<p>就上述的A和B而言，这一点似乎很迂腐，但 Rust 的其他几个特性使得语言可以以复杂的方式进行内存布局。</p>
<p>例如，考虑这个多态结构体：</p>
<pre><code class="language-rust"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span>&lt;T, U&gt; {
    count: <span class="hljs-built_in">u16</span>,
    data1: T,
    data2: U,
}
</div></code></pre>
<p>再考虑单态化的<code>Foo&lt;u32, u16&gt;</code>和<code>Foo&lt;u16, u32&gt;</code>。如果Rust以指定的顺序排列字段，我们希望它会填充结构体中的值以满足其对齐要求。因此，如果Rust没有对字段进行重排的话，我们希望它产生以下布局：</p>
<pre><code class="language-rust"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span>&lt;<span class="hljs-built_in">u16</span>, <span class="hljs-built_in">u32</span>&gt; {
    count: <span class="hljs-built_in">u16</span>,
    data1: <span class="hljs-built_in">u16</span>,
    data2: <span class="hljs-built_in">u32</span>,
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span>&lt;<span class="hljs-built_in">u32</span>, <span class="hljs-built_in">u16</span>&gt; {
    count: <span class="hljs-built_in">u16</span>,
    _pad1: <span class="hljs-built_in">u16</span>,
    data1: <span class="hljs-built_in">u32</span>,
    data2: <span class="hljs-built_in">u16</span>,
    _pad2: <span class="hljs-built_in">u16</span>,
}
</div></code></pre>
<p>后一种情况显然很浪费空间。内存占用的优化需要不同的单态化实例具有不同成员字段排序。</p>
<p>枚举体使这一考虑变得更加复杂，如：</p>
<pre><code class="language-rust"><div><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Foo</span></span> {
    A(<span class="hljs-built_in">u32</span>),
    B(<span class="hljs-built_in">u64</span>),
    C(<span class="hljs-built_in">u8</span>),
}
</div></code></pre>
<p>可能被布局为：</p>
<pre><code class="language-rust"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FooRepr</span></span> {
    data: <span class="hljs-built_in">u64</span>, <span class="hljs-comment">// this is either a u64, u32, or u8 based on `tag`</span>
    tag: <span class="hljs-built_in">u8</span>,   <span class="hljs-comment">// 0 = A, 1 = B, 2 = C</span>
}
</div></code></pre>
<p>事实上，它大体就是这样进行布局的（以枚举成员的大小和位置为标签<code>tag</code> ）。</p>
<p>然而，在某些情况下，这种布局的内存使用率会比较低下。经典的情况是 Rust 的“空指针优化”：由单个外部单元变量（例如<code>None</code>）和（可能嵌套的）非可空指针变量（例如<code>Some(＆T)</code>）组成的枚举使得标签没有存在的必要。空指针可以被安全地解释为单一的<code>(None)</code>变量。最终结果是，例如，<code>size_of::&lt;Option&lt;＆T&gt;&gt;() == size_of::&lt;＆T&gt;()</code>。</p>
<p>Rust中有许多类型是（或包含）非可空指针，如<code>Box&lt;T&gt;</code>，<code>Vec&lt;T&gt;</code>，<code>String</code>，<code>＆T</code>和<code>＆mut T</code>。同样，可以想象得到，嵌套的枚举体将其标签汇集到单个判别式中，因为根据定义，它们的有效值的范围是有限的。对于枚举，原则上可以使用相当精细的位运算算法来存储嵌套类型中的无效值。因此，特别地，我们现在没有指定枚举的布局方式。</p>

    </body>
    </html>