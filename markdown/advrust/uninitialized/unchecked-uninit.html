<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>未经检查的未初始化内存</title>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        
    </head>
    <body class="vscode-light">
        <h1 id="%e6%9c%aa%e7%bb%8f%e6%a3%80%e6%9f%a5%e7%9a%84%e6%9c%aa%e5%88%9d%e5%a7%8b%e5%8c%96%e5%86%85%e5%ad%98">未经检查的未初始化内存</h1>
<blockquote>
<p>源：<a href="https://github.com/rust-lang-nursery/nomicon/blob/master/src/unchecked-uninit.md">unchecked-uninit.md</a>   Commit: 0e6c680ebd72f1860e46b2bd40e2a387ad8084ad</p>
</blockquote>
<p>一个特殊情况是数组。安全Rust不允许部分地初始化数组。初始化一个数组时，你可以通过<code>let x = [val; N]</code>为每一个位置赋予相同的值，或者是单独指定每一个成员的值<code>let x = [val1, val2, val3]</code>。不幸的是，这个要求太苛刻了。很多时候我们需要用增量或者动态的方式初始化数组。</p>
<p>非安全Rust给我们提供了一个很有力的工具以处理这一问题：<code>mem::uninitialized</code>。这个函数假装返回一个值，但其实它什么也没有做。我们用它来欺骗Rust我们已经初始化了一个变量了，从而可以做一些很神奇的事情，比如有条件还有增量地初始化。</p>
<p>不过，它也给我们打开了各种问题的大门。在Rust中，对于已初始化和未初始化的变量赋值，是有不同的含义的。如果Rust认为变量未初始化，它会将字节拷贝到未初始化的内存区域，别的就什么都不做了。可如果Rust判断变量已初始化，它会销毁原有的值！因为我们欺骗Rust值已经初始化，我们再也不能安全地赋值了。</p>
<p>系统分配器返回一个指向未初始化内存的指针，与它配合时同样会造成问题。</p>
<p>接下来，我们还必须使用<code>ptr</code>模块。特别是它提供的三个函数，允许我们将字节码写入一块内存而不会销毁原有的变量。这些函数为：<code>write</code>，<code>copy</code>和<code>copy_nonoverlapping</code>。</p>
<ul>
<li><code>ptr::write(ptr, val)</code>函数接受<code>val</code>然后将它的值移入<code>ptr</code>指向的地址</li>
<li><code>ptr::copy(src, dest, count)</code>函数从<code>src</code>处将<code>count</code>个T占用的字节拷贝到<code>dest</code>。（这个函数和<code>memmove</code>相同，不过要注意参数顺序是反的！）</li>
<li><code>ptr::copy_nonoverlapping(src, dest, count)</code>和<code>copy</code>的功能是一样的，不过它假设两段内存不会有重合部分，因此速度会略快一点。（这个函数和<code>memcpy</code>相同，不过要注意参数顺序是反的！）</li>
</ul>
<p>很显然，如果这些函数被滥用的话，很可能导致错误或者未定义行为。它们唯一的要求就是被读写的位置必须已经分配了内存。但是，向任意位置写入任意字节很可能造成不可预测的错误。</p>
<p>下面的代码集中展示了它们的用法：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">use</span> std::mem;
<span class="hljs-keyword">use</span> std::ptr;

<span class="hljs-comment">// 数组的大小是硬编码的但是可以很方便地修改</span>
<span class="hljs-comment">// 不过这表示我们不能用[a, b, c]这种方式初始化数组</span>
<span class="hljs-keyword">const</span> SIZE: <span class="hljs-built_in">usize</span> = <span class="hljs-number">10</span>;

<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x: [<span class="hljs-built_in">Box</span>&lt;<span class="hljs-built_in">u32</span>&gt;; SIZE];

<span class="hljs-keyword">unsafe</span> {
    <span class="hljs-comment">// 欺骗Rust说x已经被初始化</span>
    x = mem::uninitialized();
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..SIZE {
        <span class="hljs-comment">// 十分小心地覆盖每一个索引值而不读取它</span>
        <span class="hljs-comment">// 注意：异常安全性不需要考虑；Box不会panic</span>
        ptr::write(&amp;<span class="hljs-keyword">mut</span> x[i], <span class="hljs-built_in">Box</span>::new(i <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>));
    }
}

<span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, x);
</div></code></pre>
<p>需要注意，你不用担心<code>ptr::write</code>和实现了<code>Drop</code>的或者包含<code>Drop</code>子类型的类型之间无法和谐共处，因为Rust知道这时不会调用<code>drop</code>。类似的，你可以给一个只有局部初始化的结构体的成员赋值，只要那个成员不包含<code>Drop</code>子类型。</p>
<p>但是，在使用未初始化内存的时候你需要时刻小心，Rust可能会在值未完全初始化的时候就尝试销毁它们。如果一个变量有析构函数，那么变量作用域的每一个代码分支都应该在结束之前完成变量的初始化。否则<a href="https://doc.rust-lang.org/nomicon/unwinding.html">会导致崩溃</a>。</p>
<p>这就是未初始化内存的全部内容！其他地方基本上不会再涉及到未初始化内存了，所以如果你想跳过本章，请千万小心。</p>

    </body>
    </html>