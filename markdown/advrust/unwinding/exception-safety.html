<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>异常安全性</title>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        
    </head>
    <body class="vscode-light">
        <h1 id="%e5%bc%82%e5%b8%b8%e5%ae%89%e5%85%a8%e6%80%a7">异常安全性</h1>
<blockquote>
<p>源：<a href="https://github.com/rust-lang-nursery/nomicon/blob/master/src/exception-safety.md">exception-safety.md</a>   Commit: c4ef161ed0cf6438966d4a44ee53948b540789e8</p>
</blockquote>
<p>虽然前面说过我们应该慎用展开，但是还是有许多的地方会Panic。如果你对<code>None</code>调用<code>unwrap</code>、使用超出范围的索引值、或者用0做除数，你的程序就要panic。在debug模式下，所有的计算操作在溢出的时候也都会panic。除非你十分小心并且严格控制着每一条代码的行为，否则所有的东西都有展开的可能，你需要时刻准备迎接它。</p>
<p>在更广大的程序设计世界里，应对展开这件事通常被称之为“异常安全“。在Rust中，我们需要考虑两个层次的异常安全性：</p>
<ul>
<li>在非安全代码中，异常安全的下限是要保证不能违背内存安全性。我们称之为最小异常安全性。</li>
<li>在安全代码中，异常安全性要保证程序时刻在做正确的事情。我们称之为最大异常安全性。</li>
</ul>
<p>在许多情况下，非安全代码在处理展开的时候需要考虑到那些写得很糟糕的安全代码。一些只是暂时导致不稳定状态的程序需要小心，一旦触发了Panic会导致这种状态无法使用。这表示在不稳定状态依然存在的情况下，我们需要保证值运行不触发Panic的代码；或者在触发Panic的时候即使处理，清除这种状态。这也表明Panic看到的状态并不一定非得是连续的状态，我们只需要保证它是安全地状态就可以。</p>
<p>大多数非安全代码都比较容易实现异常安全。因为它控制着程序运行的每个细节，而且大部分代码不会Panic。但是非安全代码也经常要做诸如在未初始化数据的数组上反复运行外部代码这样的操作。这种代码就需要小心考虑异常安全性了。</p>
<h2 id="vecpushall">Vec::push_all</h2>
<p><code>Vec::push_all</code>使用一个<code>slice</code>扩充<code>Vec</code>，由于它没有具体化类型，所以能获得较高的效率。下面是一个简单的实现：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">impl</span>&lt;T: <span class="hljs-built_in">Clone</span>&gt; <span class="hljs-built_in">Vec</span>&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">push_all</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, to_push: &amp;[T]) {
        <span class="hljs-keyword">self</span>.reserve(to_push.len());
        <span class="hljs-keyword">unsafe</span> {
            <span class="hljs-comment">// 因为我们调用了reserve，所以不会出现溢出</span>
            <span class="hljs-keyword">self</span>.set_len(<span class="hljs-keyword">self</span>.len() + to_push.len());

            <span class="hljs-keyword">for</span> (i, x) <span class="hljs-keyword">in</span> to_push.iter().enumerate() {
                <span class="hljs-keyword">self</span>.ptr().offset(i <span class="hljs-keyword">as</span> <span class="hljs-built_in">isize</span>).write(x.clone());
            }
        }
    }
}
</div></code></pre>
<p>我们不去使用<code>push</code>，因为它会对Vec的容量和<code>len</code>做额外的检查，而有些情况下我们能够明确知道容量是充足的。这段代码的逻辑是完全正确的，但是却有一个问题：它不是异常安全的！<code>set_len</code>、<code>offset</code>和<code>write</code>都没问题，但是<code>clone</code>是一颗引发Panic的炸弹。</p>
<p><code>Clone</code>的实现是我们无法控制的，它很可能会panic。如果它真的panic了，这个方法会提前退出，但我们之前给Vec设置的更大的长度会一致保持下去。当Vec被访问或者销毁的时候，它会读取未初始化内存！</p>
<p>解决方法很简单。如果我们要保证我们clone的值都被销毁了，我们可以在每一次循环里设置<code>len</code>。如果我们只是想保证不会出现读取未初始化内存的情况，我们可以在循环之后设置<code>len</code>。</p>
<h2 id="binaryheapsiftup">BinaryHeap::sift_up</h2>
<p>对二叉堆做冒泡比扩充一个Vec要更复杂一点。伪代码是这样的：</p>
<pre><code><code><div>bubble_up(heap, index):
    while index != 0 &amp;&amp; heap[index] &lt; heap[parent(index)]:
        heap.swap(index, parent(index))
        index = parent(index)
</div></code></code></pre>
<p>将它翻译成Rust很容易，但是性能不会让人满意：<code>self</code>元素要一遍一遍做无意义的交换。我们更喜欢下面的版本：</p>
<pre><code><code><div>bubble_up(heap, index):
    let elem = heap[index]
    while index != 0 &amp;&amp; elem &lt; heap[parent(index)]:
        heap[index] = heap[parent(index)]
        index = parent(index)
    heap[index] = elem
</div></code></code></pre>
<p>这段代码保证各个元素被尽量少的复制(通常每个元素需要被复制两次)。但是这样它会引发异常安全问题！任何时刻都存在着一个值的两份拷贝。如果这个方法中出现panic，有一些东西可能会被二次释放。不幸的是，我们同样不能完全掌控这段代码，因为比较操作是用户定义的。</p>
<p>这个解决方案比Vec的要困难。一个选项是把用户定义代码和非安全代码拆分成两个阶段：</p>
<pre><code><code><div>bubble_up(heap, index):
    let end_index = index;
    while end_index != 0 &amp;&amp; heap[end_index] &lt; heap[parent(end_index)]:
        end_index = parent(end_index)

    let elem = heap[index]
    while index != end_index:
        heap[index] = heap[parent(index)]
        index = parent(index)
    heap[index] = elem
</div></code></code></pre>
<p>如果用户定义的代码爆炸了，也不会伤及无辜，因为我们还没有实际改变堆的状态。等我们开始在堆上搞事情的时候，我们只会使用我们信任的数据和函数，不用担心panic。</p>
<p>你可能对这个设计感到很不爽。这个属于作弊！而且我们必须对堆完整遍历两次！好吧，让我们直面困难，把不信任代码和不安全代码混合在一起。</p>
<p>如果Rust像Java一样有<code>try</code>和<code>finally</code>，我们可以这么做：</p>
<pre><code><code><div>bubble_up(heap, index):
    let elem = heap[index]
    try:
        while index != 0 &amp;&amp; elem &lt; heap[parent(index)]:
            heap[index] = heap[parent(index)]
            index = parent(index)
    finally:
        heap[index] = elem
</div></code></code></pre>
<p>基本思想很简单：如果比较操作panic了，我们就把取出的元素塞回到逻辑上未初始化的位置然后退出。访问这个堆的人可能会发现堆的状态是不连续的，但是至少这个方案不会引发二次释放！如果算法正常结束的话，这个设计就和我们最开始不做任何处理的方案一模一样了。</p>
<p>可惜，Rust并没有这些东西，所以我们只能自己早轮子了！我们把算法的状态储存在一个独立的结构体中，结构体的析构函数起到了”finally“的功能。不管有没有panic，析构函数都会被调用并且清除我们留下状态。</p>
<pre><code class="language-Rust"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Hole</span></span>&lt;<span class="hljs-symbol">'a</span>, T: <span class="hljs-symbol">'a</span>&gt; {
    data: &amp;<span class="hljs-symbol">'a</span> <span class="hljs-keyword">mut</span> [T],
    <span class="hljs-comment">// elt从始至终都会是Some</span>
    elt: <span class="hljs-built_in">Option</span>&lt;T&gt;,
    pos: <span class="hljs-built_in">usize</span>,
}

<span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">'a</span>, T&gt; Hole&lt;<span class="hljs-symbol">'a</span>, T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(data: &amp;<span class="hljs-symbol">'a</span> <span class="hljs-keyword">mut</span> [T], pos: <span class="hljs-built_in">usize</span>) -&gt; <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">unsafe</span> {
            <span class="hljs-keyword">let</span> elt = ptr::read(&amp;data[pos]);
            Hole {
                data: data,
                elt: <span class="hljs-literal">Some</span>(elt),
                pos: pos,
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">pos</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">usize</span> { <span class="hljs-keyword">self</span>.pos }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">removed</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;T { <span class="hljs-keyword">self</span>.elt.as_ref().unwrap() }

    <span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get</span></span>(&amp;<span class="hljs-keyword">self</span>, index: <span class="hljs-built_in">usize</span>) -&gt; &amp;T { &amp;<span class="hljs-keyword">self</span>.data[index] }

    <span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">move_to</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, index: <span class="hljs-built_in">usize</span>) {
        <span class="hljs-keyword">let</span> index_ptr: *<span class="hljs-keyword">const</span> _ = &amp;<span class="hljs-keyword">self</span>.data[index];
        <span class="hljs-keyword">let</span> hole_ptr = &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.data[<span class="hljs-keyword">self</span>.pos];
        ptr::copy_nonoverlapping(index_ptr, hole_ptr, <span class="hljs-number">1</span>);
        <span class="hljs-keyword">self</span>.pos = index;
    }
}

<span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">'a</span>, T&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> Hole&lt;<span class="hljs-symbol">'a</span>, T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-comment">// 再次填充hole</span>
        <span class="hljs-keyword">unsafe</span> {
            <span class="hljs-keyword">let</span> pos = <span class="hljs-keyword">self</span>.pos;
            ptr::write(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.data[pos], <span class="hljs-keyword">self</span>.elt.take().unwrap());
        }
    }
}

<span class="hljs-keyword">impl</span>&lt;T: <span class="hljs-built_in">Ord</span>&gt; BinaryHeap&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">sift_up</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, pos: <span class="hljs-built_in">usize</span>) {
        <span class="hljs-keyword">unsafe</span> {
            <span class="hljs-comment">// 取出pos处的值，然后创建一个hole</span>
            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hole = Hole::new(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.data, pos);

            <span class="hljs-keyword">while</span> hole.pos() != <span class="hljs-number">0</span> {
                <span class="hljs-keyword">let</span> parent = parent(hole.pos());
                <span class="hljs-keyword">if</span> hole.removed() &lt;= hole.get(parent) { <span class="hljs-keyword">break</span> }
                hole.move_to(parent);
            }
            <span class="hljs-comment">// 无论有没有panic，hold在此处都会无条件地被填充</span>
        }
    }
}
</div></code></pre>

    </body>
    </html>