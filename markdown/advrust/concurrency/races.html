<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>数据竞争与竞争条件</title>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        
    </head>
    <body class="vscode-light">
        <h1 id="%e6%95%b0%e6%8d%ae%e7%ab%9e%e4%ba%89%e4%b8%8e%e7%ab%9e%e4%ba%89%e6%9d%a1%e4%bb%b6">数据竞争与竞争条件</h1>
<blockquote>
<p>原文跟踪<a href="https://github.com/rust-lang-nursery/nomicon/blob/master/src/races.md">races.md</a>   Commit: bb75621e3a62d14302c8f09239aab42132530446</p>
</blockquote>
<p>Safe Rust保证不存在数据争用，其定义为：</p>
<ul>
<li>两个或多个线程同时访问内存位置</li>
<li>其中一个是写</li>
<li>其中一个是不同步的</li>
</ul>
<p>数据争用具有未定义的行为，因此无法在Safe Rust执行。 通过Rust的所有权系统阻止了<em>大部分</em>数据竞争：不可能为可变引用添加别名，因此无法执行
数据竞争。 内部可变性使这更复杂，这很大程度上是原因我们有<code>Send</code>和<code>Sync</code>特质（见下文）。</p>
<p><strong>但Rust并不能阻止一般的竞争条件</strong></p>
<p>这在根本上是不可能的，也可能是不可取的。 您的硬件是活的，你的操作系统是活的，你的电脑上的其他程序是活的，这一切都是充满活力的世界。 任何可以真正声称防止<em>所有</em>竞争条件的系统使用起来非常糟糕。</p>
<p>因此，对于安全Rust程序来说，使用死锁或使用不正确的同步做一些无意义的事情是完全“好”的。 显然这样的程序不是很好，但Rust到目前为止只能为你做这些。 但是，竞争条件本身不能违反Rust程序中的内存安全性。 只有与其他一些不安全的代码一起使用，竞争条件才会真正违反内存安全。 例如：</p>
<pre><code class="language-rust"><div><span class="hljs-keyword">use</span> std::thread;
<span class="hljs-keyword">use</span> std::sync::atomic::{AtomicUsize, Ordering};
<span class="hljs-keyword">use</span> std::sync::Arc;

<span class="hljs-keyword">let</span> data = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
<span class="hljs-comment">// Arc so that the memory the AtomicUsize is stored in still exists for</span>
<span class="hljs-comment">// the other thread to increment, even if we completely finish executing</span>
<span class="hljs-comment">// before it. Rust won't compile the program without it, because of the</span>
<span class="hljs-comment">// lifetime requirements of thread::spawn!</span>
<span class="hljs-keyword">let</span> idx = Arc::new(AtomicUsize::new(<span class="hljs-number">0</span>));
<span class="hljs-keyword">let</span> other_idx = idx.clone();

<span class="hljs-comment">// `move` captures other_idx by-value, moving it into this thread</span>
thread::spawn(<span class="hljs-keyword">move</span> || {
    <span class="hljs-comment">// It's ok to mutate idx because this value</span>
    <span class="hljs-comment">// is an atomic, so it can't cause a Data Race.</span>
    other_idx.fetch_add(<span class="hljs-number">10</span>, Ordering::SeqCst);
});

<span class="hljs-comment">// Index with the value loaded from the atomic. This is safe because we</span>
<span class="hljs-comment">// read the atomic memory only once, and then pass a copy of that value</span>
<span class="hljs-comment">// to the Vec's indexing implementation. This indexing will be correctly</span>
<span class="hljs-comment">// bounds checked, and there's no chance of the value getting changed</span>
<span class="hljs-comment">// in the middle. However our program may panic if the thread we spawned</span>
<span class="hljs-comment">// managed to increment before this ran. A race condition because correct</span>
<span class="hljs-comment">// program execution (panicking is rarely correct) depends on order of</span>
<span class="hljs-comment">// thread execution.</span>
<span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, data[idx.load(Ordering::SeqCst)]);
</div></code></pre>
<pre><code class="language-rust"><div><span class="hljs-keyword">use</span> std::thread;
<span class="hljs-keyword">use</span> std::sync::atomic::{AtomicUsize, Ordering};
<span class="hljs-keyword">use</span> std::sync::Arc;

<span class="hljs-keyword">let</span> data = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];

<span class="hljs-keyword">let</span> idx = Arc::new(AtomicUsize::new(<span class="hljs-number">0</span>));
<span class="hljs-keyword">let</span> other_idx = idx.clone();

<span class="hljs-comment">// `move` captures other_idx by-value, moving it into this thread</span>
thread::spawn(<span class="hljs-keyword">move</span> || {
    <span class="hljs-comment">// It's ok to mutate idx because this value</span>
    <span class="hljs-comment">// is an atomic, so it can't cause a Data Race.</span>
    other_idx.fetch_add(<span class="hljs-number">10</span>, Ordering::SeqCst);
});

<span class="hljs-keyword">if</span> idx.load(Ordering::SeqCst) &lt; data.len() {
    <span class="hljs-keyword">unsafe</span> {
        <span class="hljs-comment">// Incorrectly loading the idx after we did the bounds check.</span>
        <span class="hljs-comment">// It could have changed. This is a race condition, *and dangerous*</span>
        <span class="hljs-comment">// because we decided to do `get_unchecked`, which is `unsafe`.</span>
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, data.get_unchecked(idx.load(Ordering::SeqCst)));
    }
}
</div></code></pre>

    </body>
    </html>