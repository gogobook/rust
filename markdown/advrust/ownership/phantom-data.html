<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>PhantomData</title>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        
    </head>
    <body class="vscode-light">
        <h1 id="phantomdata">PhantomData</h1>
<blockquote>
<p>源：<a href="https://github.com/rust-lang-nursery/nomicon/blob/master/src/phantom-data.md">phantom-data.md</a>   Commit: a73391dd35c32061bec678257d4c3ddac268c51b</p>
</blockquote>
<p>在编写非安全代码时，我们常常遇见这种情况：类型或生命周期逻辑上与一个结构体关联起来了，但是却不属于结构体的任何一个成员。这种情况对于生命周期尤为常见。比如，<code>&amp;'a [T]</code>的<code>Iter</code>大概是这么定义的：</p>
<pre><code class="language-Rust"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Iter</span></span>&lt;<span class="hljs-symbol">'a</span>, T: <span class="hljs-symbol">'a</span>&gt; {
    ptr: *<span class="hljs-keyword">const</span> T,
    end: *<span class="hljs-keyword">const</span> T,
}
</div></code></pre>
<p>但是，因为<code>'a</code>没有在结构体内被使用，它是无界的。由于一些历史原因，无界生命周期和类型禁止出现在结构体定义中。所以我们必须想办法在结构体内用到这些类型，这也是正确的变性检查和drop检查的必要条件。</p>
<p>我们使用一个特殊的标志类型<code>PhantomData</code>做到这一点。<code>PhantomData</code>不消耗存储空间，它只是模拟了某种类型的数据，以方便静态分析。这么做比显式地告诉类型系统你需要的变性更不容易出错，而且还能提供drop检查需要的信息。</p>
<p><code>Iter</code>逻辑上包含一系列<code>&amp;'a T</code>，所以我们用<code>PhantomData</code>这样去模拟它：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">use</span> std::marker;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Iter</span></span>&lt;<span class="hljs-symbol">'a</span>, T: <span class="hljs-symbol">'a</span>&gt; {
    ptr: *<span class="hljs-keyword">const</span> T,
    end: *<span class="hljs-keyword">const</span> T,
    _marker: marker::PhantomData&lt;&amp;<span class="hljs-symbol">'a</span> T&gt;,
}
</div></code></pre>
<p>就是这样，生命周期变得有界了，你的迭代器对于<code>'a</code>和<code>T</code>也可变了。一切尽如人意。</p>
<p>另一个重要的例子是<code>Vec</code>，它差不多是这么定义的：</p>
<pre><code class="language-Rust"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vec</span></span>&lt;T&gt; {
    data: *<span class="hljs-keyword">const</span> T, <span class="hljs-comment">// *const是可变的！</span>
    len: <span class="hljs-built_in">usize</span>,
    cap: <span class="hljs-built_in">usize</span>,
}
</div></code></pre>
<p>和之前的例子不同，这个定义已经满足我们的各种要求了。<code>Vec</code>的每一个泛型参数都被至少一个成员使用过了。非常完美！</p>
<p>你高兴的太早了。</p>
<p>Drop检查器会判断<code>Vec&lt;T&gt;</code>并不拥有T类型的值，然后它认为无需担心Vec在析构函数里能不能安全地销毁T，再然后它会允许人们创建不安全的Vec析构函数。</p>
<p>为了让drop检查器知道我们确实拥有T类型的值，也就是需要在销毁Vec的时候同时销毁T，我们需要添加一个额外的PhantomData：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">use</span> std::marker:

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vec</span></span>&lt;T&gt; {
    data: *<span class="hljs-keyword">const</span> T, <span class="hljs-comment">// *const是可变的！</span>
    len: <span class="hljs-built_in">usize</span>,
    cap: <span class="hljs-built_in">usize</span>,
    _marker: marker::PhantomData&lt;T&gt;,
}
</div></code></pre>
<p>让裸指针拥有数据是一个很普遍的设计，以至于标准库为它自己创造了一个叫<code>Unique&lt;T&gt;</code>的组件，它可以：</p>
<ul>
<li>封装一个<code>*const T</code>处理变性</li>
<li>包含一个PhantomData<T></li>
<li>自动实现<code>Send</code>/<code>Sync</code>，模拟和包含T时一样的行为</li>
<li>将指针标记为<code>NonZero</code>以便空指针优化</li>
</ul>
<h2 id="phantomdata%e6%a8%a1%e5%bc%8f%e8%a1%a8"><code>PhantomData</code>模式表</h2>
<p>下表展示了各种牛X闪闪的<code>PhantomData</code>用法：</p>
<table>
<thead>
<tr>
<th>Phantom 类型</th>
<th><code>'a</code></th>
<th><code>T</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PhantomData&lt;T&gt;</code></td>
<td>-</td>
<td>协变（可触发drop检查）</td>
</tr>
<tr>
<td><code>PhantomData&lt;&amp;'a T&gt;</code></td>
<td>协变</td>
<td>协变</td>
</tr>
<tr>
<td><code>PhantomData&lt;&amp;'a mut T&gt;</code></td>
<td>协变</td>
<td>不变</td>
</tr>
<tr>
<td><code>PhantomData&lt;*const T&gt;</code></td>
<td>-</td>
<td>协变</td>
</tr>
<tr>
<td><code>PhantomData&lt;*mut T&gt;</code></td>
<td>-</td>
<td>不变</td>
</tr>
<tr>
<td><code>PhantomData&lt;fn(T)&gt;</code></td>
<td>-</td>
<td>逆变(*)</td>
</tr>
<tr>
<td><code>PhantomData&lt;fn() -&gt; T&gt;</code></td>
<td>-</td>
<td>协变</td>
</tr>
<tr>
<td><code>PhantomData&lt;fn(T) -&gt; T&gt;</code></td>
<td>-</td>
<td>不变</td>
</tr>
<tr>
<td><code>PhantomData&lt;Cell&lt;&amp;'a ()&gt;&gt;</code></td>
<td>不变</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>(*)如果发生变性的冲突，这个是不变的</p>

    </body>
    </html>