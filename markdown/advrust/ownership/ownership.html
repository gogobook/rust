<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>所有权与生命周期</title>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        
    </head>
    <body class="vscode-light">
        <h1 id="%e6%89%80%e6%9c%89%e6%9d%83%e4%b8%8e%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f">所有权与生命周期</h1>
<blockquote>
<p>原文跟踪<a href="https://github.com/rust-lang-nursery/nomicon/blob/master/src/ownership.md">ownership.md</a>   Commit: 0e6c680ebd72f1860e46b2bd40e2a387ad8084ad</p>
</blockquote>
<p>所有权是Rust的突破性特征。 它允许Rust完全内存安全且高效，同时避免垃圾回收。 在详细介绍所有权制度之前，我们将考虑这种设计的动机。</p>
<p>我们假设您接受垃圾收集（GC）并不总是最佳解决方案，并且希望在某些上下文中手动管理内存。 如果你不接受这个，你可能会对另一种语言对感兴趣？</p>
<p>无论您对GC的感受如何，显然对于使代码安全无疑是一个巨大的好处。 你永远不必担心过早的事情会消失（尽管你是否仍然想要指出那件事是另一个问题......）。 这是C和C ++程序需要处理的普遍问题。 考虑一下这个简单的错误，即我们所有使用非GC语言的人都曾在某个方面做过：</p>
<pre><code class="language-rust"><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">as_str</span></span>(data: &amp;<span class="hljs-built_in">u32</span>) -&gt; &amp;<span class="hljs-built_in">str</span> {
    <span class="hljs-comment">// compute the string</span>
    <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">format!</span>(<span class="hljs-string">"{}"</span>, data);

    <span class="hljs-comment">// OH NO! We returned a reference to something that</span>
    <span class="hljs-comment">// exists only in this function!</span>
    <span class="hljs-comment">// Dangling pointer! Use after free! Alas!</span>
    <span class="hljs-comment">// (this does not compile in Rust)</span>
    &amp;s
}
</div></code></pre>
<p>这正是Rust的所有权系统要解决的问题。 Rust知道<code>＆s</code>的生存范围，因此可以防止它逃逸。 然而，这是一个简单的案例，即使是C编译器也可以合理地捕获。 随着代码变得越来越大，指针通过各种函数被提供，事情变得越来越复杂。 最终，C编译器将崩溃，并且无法执行足够的转义分析来证明您的代码不健全。 因此，在假设它是正确的情况下，它将被迫接受您的程序。</p>
<p>这将永远不会发生在Rust。 程序员可以向编译器证明一切都是正确的。</p>
<p>当然，Rust关于所有权的故事要比仅仅验证引用不会超出其引用范围复杂。 那是因为确保指针始终有效要比这复杂得多。 例如，在此代码中，</p>
<pre><code class="language-rust"><div><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> data = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-comment">// get an internal reference</span>
<span class="hljs-keyword">let</span> x = &amp;data[<span class="hljs-number">0</span>];

<span class="hljs-comment">// OH NO! `push` causes the backing storage of `data` to be reallocated.</span>
<span class="hljs-comment">// Dangling pointer! Use after free! Alas!</span>
<span class="hljs-comment">// (this does not compile in Rust)</span>
data.push(<span class="hljs-number">4</span>);

<span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, x);
</div></code></pre>
<p>天真的范围分析不足以防止这个错误，因为数据确实存在，只要我们需要。 然而，当我们引用它时它被改变了。 这就是Rust要求任何引用来冻结引用对象及其所有者的原因。</p>

    </body>
    </html>