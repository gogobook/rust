# 无界限生命周期

> 原文跟踪[unbounded-lifetimes.md](https://github.com/rust-lang-nursery/nomicon/blob/master/src/unbounded-lifetimes.md) &emsp; Commit: 0e6c680ebd72f1860e46b2bd40e2a387ad8084ad

不安全的代码通常最终会凭空产生引用或生命周期。 这样的生命周期进入世界是无限的。 最常见的来源是解引用原始指针，该指针生成具有无限生命周期的引用。 这样的生命周期变得与上下文需求一样大。 这实际上比简单地变成`'static` 更强大，因为例如`'static＆'T`将无法进行类型检查，但是未绑定的生命周期将完全塑造成所需的`&'a &'a T`。 然而，对于大多数意图和目的，这种无限的生命周期可以被视为`'static`。

几乎没有引用是`'static`，所以这可能是错误的。 `transmuteand`, `transmute_copy`是另外两个风险。 人们应尽可能快地限制无限生命，尤其是跨越函数边界。

给定一个函数，任何不是从输入派生的输出生命周期都是无限的。 例如：

```rust
fn get_str<'a>() -> &'a str;
```

会产生无限的生命周期。 避免无限生命期的最简单方法是在函数边界使用生命周期省略。 如果省略输出生命周期，则必须受输入生命周期的限制。 当然它可能受到错误生命周期的限制，但这通常只会导致编译器错误，而不是简单地违反内存安全性。

在函数内，边界生命周期更容易出错。 绑定生命周期的最安全和最简单的方法是从具有绑定生存期的函数返回它。 但是，如果这是不可接受的，您可以将引用放在具有特定生命周期的位置。 遗憾的是，无法命名函数中涉及的所有生命周期。
