<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>高阶特质界限(HRTBs)</title>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        
    </head>
    <body class="vscode-light">
        <h1 id="%e9%ab%98%e9%98%b6%e7%89%b9%e8%b4%a8%e7%95%8c%e9%99%90hrtbs">高阶特质界限(HRTBs)</h1>
<blockquote>
<p>原文跟踪<a href="https://github.com/rust-lang-nursery/nomicon/blob/master/src/hrtb.md">hrtb.md</a>   Commit: 0e6c680ebd72f1860e46b2bd40e2a387ad8084ad</p>
</blockquote>
<p>Rust的<code>Fn</code>特征有点神奇。 例如，我们可以写以下代码：</p>
<pre><code class="language-rust"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Closure</span></span>&lt;F&gt; {
    data: (<span class="hljs-built_in">u8</span>, <span class="hljs-built_in">u16</span>),
    func: F,
}

<span class="hljs-keyword">impl</span>&lt;F&gt; Closure&lt;F&gt;
    <span class="hljs-keyword">where</span> F: <span class="hljs-built_in">Fn</span>(&amp;(<span class="hljs-built_in">u8</span>, <span class="hljs-built_in">u16</span>)) -&gt; &amp;<span class="hljs-built_in">u8</span>,
{
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">call</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-built_in">u8</span> {
        (<span class="hljs-keyword">self</span>.func)(&amp;<span class="hljs-keyword">self</span>.data)
    }
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">do_it</span></span>(data: &amp;(<span class="hljs-built_in">u8</span>, <span class="hljs-built_in">u16</span>)) -&gt; &amp;<span class="hljs-built_in">u8</span> { &amp;data.<span class="hljs-number">0</span> }

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> clo = Closure { data: (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), func: do_it };
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, clo.call());
}
</div></code></pre>
<p>如果我们尝试以与生命周期部分相同的方式天真地去除这些代码，我们会遇到一些麻烦：</p>
<pre><code class="language-rust"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Closure</span></span>&lt;F&gt; {
    data: (<span class="hljs-built_in">u8</span>, <span class="hljs-built_in">u16</span>),
    func: F,
}

<span class="hljs-keyword">impl</span>&lt;F&gt; Closure&lt;F&gt;
    <span class="hljs-comment">// where F: Fn(&amp;'??? (u8, u16)) -&gt; &amp;'??? u8,</span>
{
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">call</span></span>&lt;<span class="hljs-symbol">'a</span>&gt;(&amp;<span class="hljs-symbol">'a</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-symbol">'a</span> <span class="hljs-built_in">u8</span> {
        (<span class="hljs-keyword">self</span>.func)(&amp;<span class="hljs-keyword">self</span>.data)
    }
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">do_it</span></span>&lt;<span class="hljs-symbol">'b</span>&gt;(data: &amp;<span class="hljs-symbol">'b</span> (<span class="hljs-built_in">u8</span>, <span class="hljs-built_in">u16</span>)) -&gt; &amp;<span class="hljs-symbol">'b</span> <span class="hljs-built_in">u8</span> { &amp;<span class="hljs-symbol">'b</span> data.<span class="hljs-number">0</span> }

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-symbol">'x</span>: {
        <span class="hljs-keyword">let</span> clo = Closure { data: (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), func: do_it };
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, clo.call());
    }
}
</div></code></pre>
<p>我们究竟应该用F的特征界限来表达生命周期？ 我们需要在那里提供一些生命周期，但是在我们进入调用体之前，我们关心的生命周期无法命名！ 而且，这不是一些固定的生命周期; 调用适用于任何生命周期和<code>&amp;self</code>恰好在那一点上。</p>
<p>这项工作需要高等级特质界限（HRTBs）。 我们这种方式如下：</p>
<pre><code class="language-rust"><div><span class="hljs-keyword">where</span> <span class="hljs-keyword">for</span>&lt;<span class="hljs-symbol">'a</span>&gt; F: <span class="hljs-built_in">Fn</span>(&amp;<span class="hljs-symbol">'a</span> (<span class="hljs-built_in">u8</span>, <span class="hljs-built_in">u16</span>)) -&gt; &amp;<span class="hljs-symbol">'a</span> <span class="hljs-built_in">u8</span>,
</div></code></pre>
<p>(其中<code>Fn（a，b，c） - &gt; d</code>本身就是不稳定的真实<code>Fn</code>特征的糖）</p>
<p><code>for &lt;'a&gt;</code>可以读作<code>对于'a</code>的所有选择，并且基本上产生的<code>F</code>必须满足无限特征边界列表。在<code>Fn</code>特征之外的地方我们遇到<code>HRTB</code>并不多，甚至对于那些普通案例我们都有一个很好的魔法糖。</p>

    </body>
    </html>