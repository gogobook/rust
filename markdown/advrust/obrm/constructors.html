<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>构造函数</title>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        
    </head>
    <body class="vscode-light">
        <h1 id="%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0">构造函数</h1>
<blockquote>
<p>原文跟踪<a href="https://github.com/rust-lang-nursery/nomicon/blob/master/src/constructors.md">constructors.md</a>   Commit: 0e6c680ebd72f1860e46b2bd40e2a387ad8084ad</p>
</blockquote>
<p>只有一种方法可以创建用户定义类型的实例：命名它，并立即初始化其所有字段：</p>
<pre><code class="language-rust"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span> {
    a: <span class="hljs-built_in">u8</span>,
    b: <span class="hljs-built_in">u32</span>,
    c: <span class="hljs-built_in">bool</span>,
}

<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Bar</span></span> {
    X(<span class="hljs-built_in">u32</span>),
    Y(<span class="hljs-built_in">bool</span>),
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Unit</span></span>;

<span class="hljs-keyword">let</span> foo = Foo { a: <span class="hljs-number">0</span>, b: <span class="hljs-number">1</span>, c: <span class="hljs-literal">false</span> };
<span class="hljs-keyword">let</span> bar = Bar::X(<span class="hljs-number">0</span>);
<span class="hljs-keyword">let</span> empty = Unit;
</div></code></pre>
<p>你创建一个类型实例的每一种方式都只是调用一个完全是<code>vanilla</code>函数来做一些事情并最终触及<code>The One True Constructor</code>。</p>
<p>与C ++不同，Rust没有一大堆内置的构造函数。没有<code>Copy</code>，<code>Default</code>, <code>Assignment</code>, <code>Move</code>,或任何构造函数。造成这种情况的原因是多种多样的，但它很大程度上归结为Rust的明确的哲学。</p>
<p><code>Move</code>构造函数在Rust中没有意义，因为我们不允许类型&quot;关心&quot;它们在内存中的位置。每种类型都必须准备好将它盲目地存储到内存中的其他地方。这意味着纯粹在堆栈但仍然可移动的<code>intrusive linked</code>根本不会发生在 Rust（safely）中。</p>
<p>类似的赋值和复制构造函数也不存在，因为移动语义是Rust中唯一的语义。最多<code>x = y</code>只是将<code>y</code>的位移动到<code>x</code>变量中。 Rust确实提供了两种用于提供<code>C ++</code>面向<code>copy-oriented</code>的工具：<code>Copy</code>与<code>Clone</code>。<code>Clone</code>是我们在复制构造函数中的等价物，但它永远不会被隐式调用。您必须在要克隆的元素上显式调用<code>clone</code>。复制是<code>Clone</code>的一个特例，其实现只是&quot;复制位&quot;。复制类型在移动时会被隐式克隆，但由于<code>Copy</code>的定义，这意味着不将旧<code>copy</code>视为未初始化 。</p>
<p>虽然Rust提供了一个<code>Default</code>特质来指定默认构造函数的等价物，但使用这个特性却极为罕见。这是因为变量未被隐式初始化。默认基本上只对泛型编程有用。在具体的上下文中，类型将为任何类型的&quot;默认&quot;构造函数提供静态<code>new</code>方法。这与其他语言中的<code>new</code>无关，没有特殊含义。这只是一个命名惯例。</p>

    </body>
    </html>