<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>外部函数接口</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body class="vscode-light">
        <h1 id="%e5%a4%96%e9%83%a8%e5%87%bd%e6%95%b0%e6%8e%a5%e5%8f%a3">外部函数接口</h1>
<blockquote>
<p>源：<a href="https://github.com/rust-lang-nursery/nomicon/blob/master/src/ffi.md">ffi.md</a>   Commit: b3d532f55bea88bf34aae8d3b6af4c5d1ceaf31e</p>
</blockquote>
<h2 id="%e4%bb%8b%e7%bb%8d">介绍</h2>
<p>这个教程会使用<a href="https://github.com/google/snappy">snappy</a>压缩/解压缩库来介绍外部代码绑定的编写方法。Rust目前还不能直接调用C++的库，但是snappy有C的接口（文档在<code>snappy-c.h</code>中）。</p>
<h3 id="%e5%85%b3%e4%ba%8elibc%e7%9a%84%e8%af%b4%e6%98%8e">关于libc的说明</h3>
<p>接下来很多的例子会使用<a href="https://crates.io/crates/libc"><code>libc</code> crate</a>，它为我们提供了很多C类型的定义。如果你要亲自尝试一下这些例子的话，你需要把<code>libc</code>添加到你的<code>Cargo.toml</code>:</p>
<pre><code class="language-Toml"><div><span class="hljs-section">[dependencies]</span>
<span class="hljs-attr">libc</span> = <span class="hljs-string">"0.2.0"</span>
</div></code></pre>
<p>然后在你的crate的根文件插入一句<code>extern crate libc;</code></p>
<h3 id="%e8%b0%83%e7%94%a8%e5%a4%96%e9%83%a8%e5%87%bd%e6%95%b0">调用外部函数</h3>
<p>下面是一个调用外部函数的小例子，安装了snappy才能编译成功。</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> libc;
<span class="hljs-keyword">use</span> libc::size_t;

<span class="hljs-meta">#[link(name = <span class="hljs-meta-string">"snappy"</span>)]</span>
<span class="hljs-keyword">extern</span> {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">snappy_mx_compressed_length</span></span>(source_length: size_t) -&gt; size_t;
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x = <span class="hljs-keyword">unsafe</span> { snappy_max_compressed_length(<span class="hljs-number">100</span>) };
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"max compressed length of a 100 byte buffer: {}"</span>, x);
}
</div></code></pre>
<p><code>extern</code>代码块中是外部库的函数签名的列表，这个例子中使用的是平台相关的C的ABI。<code>#[link(...)]</code>属性用来构建一个链接snappy库的链接器，以便解析库中的符号(symbol)。</p>
<p>外部函数都被认为是不安全的，所以对它们的调用必须包装在<code>unsafe {}</code>中，也就是向编译器承诺块中的代码都是安全的。C的库经常暴露非线程安全的接口，而且几乎所有的接受指针参数的函数都是不合法的，因为指针可能是悬垂指针，而裸指针不符合Rust的内存安全模型。</p>
<p>在声明外部函数的参数类型时，Rust编译器不能检查声明的正确性，所以我们需要自己保证它是正确的，这也是运行期正确绑定的条件之一。</p>
<p><code>extern</code>块还可以继续扩展，包含所有的snappy API：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> libc;
<span class="hljs-keyword">use</span> libc::{c_int, size_t};

<span class="hljs-meta">#[link(name = <span class="hljs-meta-string">"snappy"</span>)]</span>
<span class="hljs-keyword">extern</span> {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">snappy_compress</span></span>(input: *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span>,
                       input_length: size_t,
                       compressed: *<span class="hljs-keyword">mut</span> <span class="hljs-built_in">u8</span>,
                       compressed_length: *<span class="hljs-keyword">mut</span> size_t) -&gt; c_int;
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">snappy_uncompress</span></span>(compressed: *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span>,
                         compressed_length: size_t,
                         uncompressed: *<span class="hljs-keyword">mut</span> <span class="hljs-built_in">u8</span>,
                         uncompressed_length: *<span class="hljs-keyword">mut</span> size_t) -&gt; c_int;
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">snappy_max_compressed_length</span></span>(source_length: size_t) -&gt; size_t;
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">snappy_uncompressed_length</span></span>(compressed: *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span>,
                                  compressed_length: size_t,
                                  result: *<span class="hljs-keyword">mut</span> size_t) -&gt; c_int;
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">snappy_validate_compressed_buffer</span></span>(compressed: *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span>,
                                         compressed_length: size_t) -&gt; c_int;
}
</div></code></pre>
<h2 id="%e5%88%9b%e5%bb%ba%e5%ae%89%e5%85%a8%e6%8e%a5%e5%8f%a3">创建安全接口</h2>
<p>原生的C API进行封装，以保证内存安全，还有使用vector等高级概念。库可以选择只暴露安全的、高级的接口，并隐藏非安全的内部细节。</p>
<p>我们使用<code>slice::raw</code>模块封装接受内存块的函数，这个模块会把Rust的vector转换为内存的指针。Rust的vector是一块连续的内存。它的长度是当前包含的元素的数量，容量是分配内存可存储的元素的总数。长度是小于等于容量的。</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">validate_compressed_buffer</span></span>(src: &amp;[<span class="hljs-built_in">u8</span>]) -&gt; <span class="hljs-built_in">bool</span> {
    <span class="hljs-keyword">unsafe</span> {
        snappy_validate_compressed_buffer(src.as_ptr(), src.len() <span class="hljs-keyword">as</span> size_t) == <span class="hljs-number">0</span>
    }
}
</div></code></pre>
<p>上方的<code>validate_compressed_buffer</code>包装器用到了<code>unsafe</code>代码块，但是函数签名里没有<code>unsafe</code>关键字，这说明它保证函数调用对所有的输入都是安全的。</p>
<p><code>snappy_compress</code>和<code>snappy_uncompress</code>函数更复杂一些，因为它们需要分配一块空间储存输出的结果。</p>
<p><code>snappy_max_compressed_length</code>函数可以用来分配一段最大容积内的vector，以保存输出的结果。这个vector可以传递给<code>snappy_compress</code>函数作为输出参数。还会传递一个输出参数获取压缩后的真实长度，以便设置返回值的长度。</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">compress</span></span>(src: &amp;[<span class="hljs-built_in">u8</span>]) -&gt; <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; {
    <span class="hljs-keyword">unsafe</span> {
        <span class="hljs-keyword">let</span> srclen = src.len() <span class="hljs-keyword">as</span> size_t;
        <span class="hljs-keyword">let</span> psrc = src.as_ptr();

        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> dstlen = snappy_max_compressed_length(srclen);
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> dst = <span class="hljs-built_in">Vec</span>::with_capacity(dstlen <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>);
        <span class="hljs-keyword">let</span> pdst = dst.as_mut_ptr();

        snappy_compress(psrc, srclen, pdst, &amp;<span class="hljs-keyword">mut</span> dstlen);
        dst.set_len(dstlen <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>);
        dst
    }
}
</div></code></pre>
<p>解压缩也是类似的，因为snappy的压缩格式中保存了未压缩时的大小，函数<code>snappy_uncompressed_length</code>可以获取需要的缓存区的尺寸。</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">uncompress</span></span>(src: &amp;[<span class="hljs-built_in">u8</span>]) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;&gt; {
    <span class="hljs-keyword">unsafe</span> {
        <span class="hljs-keyword">let</span> srclen = src.len() <span class="hljs-keyword">as</span> size_t;
        <span class="hljs-keyword">let</span> psrc = src.as_ptr();

        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> dstlen: size_t = <span class="hljs-number">0</span>;
        snappy_uncompressed_length(psrc, srclen, &amp;<span class="hljs-keyword">mut</span> dstlen);

        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> dst = <span class="hljs-built_in">Vec</span>::with_capacity(dstlen <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>);
        <span class="hljs-keyword">let</span> pdst = dst.as_mut_ptr();

        <span class="hljs-keyword">if</span> snappy_uncompress(psrc, srclen, pdst, &amp;<span class="hljs-keyword">mut</span> dstlen) == <span class="hljs-number">0</span> {
            dst.set_len(dstlen <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>);
            <span class="hljs-literal">Some</span>(dst)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-literal">None</span> <span class="hljs-comment">// SNAPPY_INVALID_INPUT</span>
        }
    }
}
</div></code></pre>
<p>接下来，我们添加一些测试用例来展示如何使用它们。</p>
<pre><code class="language-Rust"><div><span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">valid</span></span>() {
        <span class="hljs-keyword">let</span> d = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0xde</span>, <span class="hljs-number">0xad</span>, <span class="hljs-number">0xd0</span>, <span class="hljs-number">0x0d</span>];
        <span class="hljs-keyword">let</span> c: &amp;[<span class="hljs-built_in">u8</span>] = &amp;compress(&amp;d);
        <span class="hljs-built_in">assert!</span>(validate_compressed_buffer(c));
        <span class="hljs-built_in">assert!</span>(uncompress(c) == <span class="hljs-literal">Some</span>(d));
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">invalid</span></span>() {
        <span class="hljs-keyword">let</span> d = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];
        <span class="hljs-built_in">assert!</span>(!validate_compressed_buffer(&amp;d));
        <span class="hljs-built_in">assert!</span>(uncompress(&amp;d).is_none());
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">empty</span></span>() {
        <span class="hljs-keyword">let</span> d = <span class="hljs-built_in">vec!</span>[];
        <span class="hljs-built_in">assert!</span>(!validate_compressed_buffer(&amp;d));
        <span class="hljs-built_in">assert!</span>(uncompress(&amp;d).is_none());
        <span class="hljs-keyword">let</span> c = compress(&amp;d);
        <span class="hljs-built_in">assert!</span>(validate_compressed_buffer(&amp;c));
        <span class="hljs-built_in">assert!</span>(uncompress(&amp;c) == <span class="hljs-literal">Some</span>(d));
    }
}
</div></code></pre>
<h2 id="%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0">析构函数</h2>
<p>外部库经常把资源的所有权返还给调用代码。如果是这样，我们必须用Rust的析构函数保证所有的资源都被释放了（特别是在panic的情况下）。</p>
<p>更多关于析构函数的内容，请见<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">Drop trait</a>。</p>
<h2 id="c%e4%bb%a3%e7%a0%81%e5%88%b0rust%e5%87%bd%e6%95%b0%e7%9a%84%e5%9b%9e%e8%b0%83">C代码到Rust函数的回调</h2>
<p>一些外部库需要用到回调向调用者报告当前状态或者中间数据。我们是可以把Rust写的函数传递给外部库的。要求是回调函数必须标为<code>extern</code>并遵守正确的调用规范，以保证C代码可以调用它。</p>
<p>然后回调函数会通过注册调用传递给C的库，并在外部库中被触发。</p>
<p>下面是一个简单的例子。</p>
<p>Rust代码：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">extern</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">callback</span></span>(a: <span class="hljs-built_in">i32</span>) {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"I'm called from C with value {0}"</span>, a);
}

<span class="hljs-meta">#[link(name = <span class="hljs-meta-string">"extlib"</span>)]</span>
<span class="hljs-keyword">extern</span> {
   <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">register_callback</span></span>(cb: <span class="hljs-keyword">extern</span> <span class="hljs-function"><span class="hljs-keyword">fn</span></span>(<span class="hljs-built_in">i32</span>)) -&gt; <span class="hljs-built_in">i32</span>;
   <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">trigger_callback</span></span>();
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">unsafe</span> {
        register_callback(callback);
        trigger_callback(); <span class="hljs-comment">// 触发回调</span>
    }
}
</div></code></pre>
<p>C代码：</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*rust_callback)</span><span class="hljs-params">(<span class="hljs-keyword">int32_t</span>)</span></span>;
rust_callback cb;

<span class="hljs-keyword">int32_t</span> register_callback(rust_callback callback) {
    cb = callback;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trigger_callback</span><span class="hljs-params">()</span> </span>{
  cb(<span class="hljs-number">7</span>); <span class="hljs-comment">// Will call callback(7) in Rust.</span>
}
</div></code></pre>
<p>这个例子中，Rust的<code>main()</code>要调用C的<code>trigger_callback()</code>，而这个函数会反过来调用Rust中的<code>callback()</code>。</p>
<h3 id="%e5%b0%86rust%e5%af%b9%e8%b1%a1%e4%bd%9c%e4%b8%ba%e5%9b%9e%e8%b0%83">将Rust对象作为回调</h3>
<p>之前的例子演示了C代码如何调用全局函数。但是很多情况下回调也可能是一个Rust对象，比如说封装了某个C的结构体的Rust对象。</p>
<p>要实现这一点，我们可以传递一个指向这个对象的裸指针给C的库。C的库接下来可以将指针转换为Rust的对象。这样回调函数就可以非安全地访问相应的Rust对象了。</p>
<pre><code class="language-Rust"><div><span class="hljs-meta">#[repr(C)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RustObject</span></span> {
    a: <span class="hljs-built_in">i32</span>,
    <span class="hljs-comment">// 其他成员……</span>
}

<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">callback</span></span>(target: *<span class="hljs-keyword">mut</span> RustObject, a: <span class="hljs-built_in">i32</span>) {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"I'm called from C with value {0}"</span>, a);
    <span class="hljs-keyword">unsafe</span> {
        <span class="hljs-comment">// 用回调函数接收的值更新RustObject的值：</span>
        (*target).a = a;
    }
}

<span class="hljs-meta">#[link(name = <span class="hljs-meta-string">"extlib"</span>)]</span>
<span class="hljs-keyword">extern</span> {
   <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">register_callback</span></span>(target: *<span class="hljs-keyword">mut</span> RustObject,
                        cb: <span class="hljs-keyword">extern</span> <span class="hljs-function"><span class="hljs-keyword">fn</span></span>(*<span class="hljs-keyword">mut</span> RustObject, <span class="hljs-built_in">i32</span>)) -&gt; <span class="hljs-built_in">i32</span>;
   <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">trigger_callback</span></span>();
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-comment">// 创建回调用到的对象：</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> rust_object = <span class="hljs-built_in">Box</span>::new(RustObject { a: <span class="hljs-number">5</span> });

    <span class="hljs-keyword">unsafe</span> {
        register_callback(&amp;<span class="hljs-keyword">mut</span> *rust_object, callback);
        trigger_callback();
    }
}
</div></code></pre>
<p>C代码：</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*rust_callback)</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">int32_t</span>)</span></span>;
<span class="hljs-keyword">void</span>* cb_target;
rust_callback cb;

<span class="hljs-keyword">int32_t</span> register_callback(<span class="hljs-keyword">void</span>* callback_target, rust_callback callback) {
    cb_target = callback_target;
    cb = callback;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trigger_callback</span><span class="hljs-params">()</span> </span>{
  cb(cb_target, <span class="hljs-number">7</span>); <span class="hljs-comment">// 调用Rust的callback(&amp;rustObject, 7)</span>
}
</div></code></pre>
<h3 id="%e5%bc%82%e6%ad%a5%e5%9b%9e%e8%b0%83">异步回调</h3>
<p>上面给出的例子里，回调都是外部C库的直接的函数调用。当前线程的控制权从Rust转移到C再转移回Rust，不过最终回调都是在调用触发回调的函数的线程里执行的。</p>
<p>如果外部库启动了自己的线程，并在那个线程里调用回调函数，情况就变得复杂了。这时再访问回调中的Rust数据结构是非常不安全的，必须使用正常地同步机制。除了Mutex等传统的同步机制，还有另一个选项就是使用channel（在<code>std::sync::mpsc</code>中）将数据从触发回调的C线程传送给一个Rust线程。</p>
<p>如果一个异步回调使用了一个Rust地址空间里的对象，一定要注意，在这个对象销毁之后C的库不能再调用任何的回调。我们可以在对象的析构函数里注销回调，并且重新设计库确保毁掉注销后就不会被调用了。</p>
<h2 id="%e9%93%be%e6%8e%a5">链接</h2>
<p><code>extern</code>代码块上的<code>link</code>属性用于指导rustc如何链接到一个本地的库。现在<code>link</code>属性有两种可用的形式：</p>
<ul>
<li><code>#[link(name = &quot;foo&quot;)]</code></li>
<li><code>#[link(name = &quot;foo&quot;, kind = &quot;bar&quot;)]</code></li>
</ul>
<p>两种形式中，<code>foo</code>都是我们要链接的本地库的名字。而第二种形式中的<code>bar</code>是要链接的本地库的类型。目前有三种已知的本地库类型：</p>
<ul>
<li>动态 - <code>#[link(name = &quot;readline&quot;)]</code></li>
<li>静态 - <code>#[link(name = &quot;my_build_dependency&quot;, kind = &quot;static&quot;)]</code></li>
<li>框架 - <code>#[link(name = &quot;CoreFundation&quot;, kind = &quot;framework&quot;)]</code></li>
</ul>
<p>注意，框架只适用于MacOS平台。</p>
<p>不同的<code>kind</code>表明本地库以不同的方式参与链接。从链接器的角度看，Rust编译器产生两种输出结果：部分结果(rlib/staticlib)和最终结果(dylib/binary)。本地动态库和框架依赖可以被最终结果使用，而静态库则不会，因为静态库是直接集成在接下来的输出里的。</p>
<p>举几个这个模型用法的例子：</p>
<ul>
<li>
<p>本地构建依赖。有时候编写Rust代码需要一些C/C++作为补充，但是把C/C++代码以一个库的形式发布却不容易。这种情况下，代码应该包装在<code>libfoo.a</code>中，然后Rust的crate会声明一个依赖<code>#[link(name = &quot;foo&quot;, kind = &quot;static&quot;)]</code>。
不管crate最终以哪种形式输出，本地静态库都会被包含在输出中，这表明发布静态库并不必要。</p>
</li>
<li>
<p>普通动态库。通用的系统库（比如<code>readline</code>）在许多系统中都支持，而我们经常遇到找不到库的本地备份的的情况。如果这样的依赖被包含在Rust的crate中，部分结果（比如rlib）不会链接到这个库中。但是如果rlib被最终结果包含了，本地库也会被链接。</p>
</li>
</ul>
<p>在MacOS中，框架和动态库具有相同的语义。</p>
<h2 id="%e9%9d%9e%e5%ae%89%e5%85%a8%e4%bb%a3%e7%a0%81%e5%9d%97">非安全代码块</h2>
<p>有一些操作，比如解引用裸指针、或者调用被标为unsafe的函数，它们只能存在于非安全代码块中。非安全代码块隔离了非安全性，并向编译器承诺非安全性不会影响到块以外的代码。</p>
<p>非安全函数则不同，它们声明非安全性一定会影响到函数之外。一个非安全函数写法如下：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">kaboom</span></span>(ptr: *<span class="hljs-keyword">const</span> <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> { *ptr }
</div></code></pre>
<p>这个函数只能在<code>unsafe</code>代码块或者另外一个<code>unsafe</code>函数里被调用。</p>
<h2 id="%e8%ae%bf%e9%97%ae%e5%a4%96%e9%83%a8%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f">访问外部全局变量</h2>
<p>外部API经常暴露一些全局变量，用于记录全局状态等。为了访问这些变量，你需要在<code>extern</code>块中用<code>static</code>关键字声明它们：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> libc;

<span class="hljs-meta">#[link(name = <span class="hljs-meta-string">"readline"</span>)]</span>
<span class="hljs-keyword">extern</span> {
    <span class="hljs-keyword">static</span> rl_readline_version: libc::c_int;
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"You have readline version {} installed."</span>,
             <span class="hljs-keyword">unsafe</span> { rl_readline_version <span class="hljs-keyword">as</span> <span class="hljs-built_in">i32</span> });
}
</div></code></pre>
<p>有时也可能需要通过外部的接口修改全局状态。如果要这么做，静态变量还要添加<code>mut</code>，让我们可以修改它们。</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> libc;

<span class="hljs-keyword">use</span> std::ffi::CString;
<span class="hljs-keyword">use</span> std::ptr;

<span class="hljs-meta">#[link(name = <span class="hljs-meta-string">"readline"</span>)]</span>
<span class="hljs-keyword">extern</span> {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> rl_prompt: *<span class="hljs-keyword">const</span> libc::c_char;
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> prompt = CString::new(<span class="hljs-string">"[my-awesome-shell] $"</span>).unwrap();
    <span class="hljs-keyword">unsafe</span> {
        rl_prompt = prompt.as_ptr();

        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, rl_prompt);

        rl_prompt = ptr::null();
    }
}
</div></code></pre>
<p>注意，所有和<code>static mut</code>的操作都是非安全的，不管是读还是写。处理全局可变状态的时候一定要格外的小心。</p>
<h2 id="%e5%a4%96%e9%83%a8%e8%b0%83%e7%94%a8%e8%a7%84%e8%8c%83">外部调用规范</h2>
<p>大多数外部代码都暴露C的ABI，而Rust默认根据平台相关的C的调用规范调用外部函数。还有一些外部函数使用其他的规范，最典型的就是WindowsAPI。Rust也有方法告诉编译器使用哪种规范：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> libc;

<span class="hljs-meta">#[cfg(all(target_os = <span class="hljs-meta-string">"win32"</span>, target_arch = <span class="hljs-meta-string">"x86"</span>))]</span>
<span class="hljs-meta">#[link(name = <span class="hljs-meta-string">"kernel32"</span>)]</span>
<span class="hljs-meta">#[allow(non_snake_case)]</span>
<span class="hljs-keyword">extern</span> <span class="hljs-string">"stdcall"</span> {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">SetEnvironmentVariableA</span></span>(n: *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span>, v: *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span>) -&gt; libc::c_int;
}
</div></code></pre>
<p>这段代码作用于整个<code>extern</code>代码块。支持的ABI包括：</p>
<ul>
<li><code>stdcall</code></li>
<li><code>appcs</code></li>
<li><code>cdecl</code></li>
<li><code>fastcall</code></li>
<li><code>vectorcall</code> 这个目前被<code>abi_vectorcall</code>隐藏着，不允许修改。</li>
<li><code>Rust</code></li>
<li><code>rust-intrinsic</code></li>
<li><code>system</code></li>
<li><code>C</code></li>
<li><code>win64</code></li>
<li><code>sysv64</code></li>
</ul>
<p>列表中所有的abi都是自解释的，但是<code>system</code>可能会显得有些奇怪。它的意思是选择一个合适的与目标库通信的ABI。比如，在win32的x86架构上，它实际使用的是<code>stdcall</code>。而在x86_64上，Windows使用<code>C</code>调用规范，所以它实际使用的是<code>C</code>。这意味着在我们之前的例子中，我们可以使用<code>extern &quot;system&quot; { ... }</code>为所有的Windows系统定义块，而不仅仅是x86的平台。</p>
<h2 id="%e4%b8%8e%e5%a4%96%e9%83%a8%e4%bb%a3%e7%a0%81%e4%ba%92%e7%94%a8%e6%80%a7">与外部代码互用性</h2>
<p>只有给一个结构体指定了<code>#[repr(C)]</code>，Rust才保证结构体的布局与平台的C的表示方法相兼容。<code>#[repr(C, packed)]</code>可以让结构体成员之间无填充。<code>#[repr(C)]</code>也可以作用于枚举类型。</p>
<p>Rust的<code>Box&lt;T&gt;</code>用一个非空的指针指向它包含的对象。但是，这些指针不能手工创建，而是要由内部分配器去管理。引用可以安全地等同于非空指针。不过，违背借用检查和可变性规则就不能保证是安全的了，所以在需要使用指针的地方我们尽量使用裸指针，因为编译器不会对它做过多的限制。</p>
<p>Vector和String拥有相同的内存布局，而且<code>vec</code>和<code>str</code>模块里也有一些与C API相关的工具。但是，字符串不是以<code>\0</code>结尾的。如果你想要一个与C兼容的Null结尾的字符串，你应该使用<code>std::ffi</code>模块中的<code>CString</code>类型。</p>
<p>[crate.io的<code>libc</code> crate]<code>(https://crates.io/crates/libc)在</code>libc<code>模块中包含了C标准库的类型别名和函数定义，而Rust默认链接</code>libc<code>和</code>libm`。</p>
<h2 id="%e5%8f%af%e5%8f%98%e5%87%bd%e6%95%b0">可变函数</h2>
<p>在C中，函数可以是“可变的”，也就是说可以接收可变数量的参数。在Rust中可以在外部函数声明的参数类表中插入<code>...</code>实现这一点：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">extern</span> {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(x: <span class="hljs-built_in">i32</span>, ...);
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">unsafe</span> {
        foo(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>);
    }
}
</div></code></pre>
<p>普通的Rust函数不能是可变的：</p>
<pre><code class="language-Rust"><div><span class="hljs-comment">// 这段不能通过编译</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(x: <span class="hljs-built_in">i32</span>, ...) { }
</div></code></pre>
<h2 id="%e7%a9%ba%e6%8c%87%e9%92%88%e4%bc%98%e5%8c%96">空指针优化</h2>
<p>一些Rust类型被定义为永不为<code>null</code>，包括引用（<code>&amp;T</code>、<code>&amp;mut T</code>）、<code>Box&lt;T&gt;</code>、以及函数指针（<code>extern &quot;abi&quot; fn()</code>）。可是在使用C的接口时，指针是经常可能为<code>null</code>的。看起来似乎需要用到<code>transmute</code>或者非安全代码来处理各种混乱的类型转换。但是，Rust其实提供了另外的方法。</p>
<p>一些特殊情况中，<code>enum</code>很适合做空指针优化，只要它包含两个变量，其中一个不包含数据，而另外一个包含一个非空类型的成员。这样就不需要额外的空间做判断了：给那个包含非空成员的变量传递一个<code>null</code>，用它来表示另外那个空的变量。这种行为虽然被叫做“优化”，但是和其他的优化不同，它只适用于合适的类型。</p>
<p>最常见的受益于空指针优化的类型是<code>Option&lt;T&gt;</code>，其中<code>None</code>可以用<code>null</code>表示。所以<code>Option&lt;extern &quot;C&quot; fn(c_int) - &gt; c_int&gt;</code>就很适合表示一个使用C ABI的可为空的函数指针（对应于C的<code>int (*)(int)</code>）。</p>
<p>下面是一个刻意造出来的例子。假设一些C的库提供了注册回调的方法，然后在特定的条件下调用回调。回调接受一个函数指针和一个整数，然后用这个整数作为参数调用指针指向的函数。所以我们会向FFI边界的两侧都传递函数指针。</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> libc;
<span class="hljs-keyword">use</span> libc::c_int;

<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> {
    <span class="hljs-comment">// 注册回调。</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">register</span></span>(cb: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">fn</span></span>(<span class="hljs-built_in">Option</span>&lt;<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">fn</span></span>(c_int) -&gt; c_int&gt;, c_int) -&gt; c_int&gt;);
}

<span class="hljs-comment">// 这个函数其实没什么实际的用处。它从C代码接受一个函数指针和一个整数，</span>
<span class="hljs-comment">// 用整数做参数调用指针指向的函数，并返回函数的返回值。</span>
<span class="hljs-comment">// 如果没有指定函数，那默认就返回整数的平方。</span>
<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">apply</span></span>(process: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">fn</span></span>(c_int) -&gt; c_int&gt;, int: c_int) -&gt; c_int {
    <span class="hljs-keyword">match</span> process {
        <span class="hljs-literal">Some</span>(f) =&gt; f(int),
        <span class="hljs-literal">None</span>    =&gt; int * int
    }
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">unsafe</span> {
        register(<span class="hljs-literal">Some</span>(apply));
    }
}
</div></code></pre>
<p>C的代码是像这样的：</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(<span class="hljs-keyword">void</span> (*f)(<span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">int</span>), <span class="hljs-keyword">int</span>))</span> </span>{
    ...
}
</div></code></pre>
<p>看，并不需要<code>transmute</code>！</p>
<h2 id="c%e8%b0%83%e7%94%a8rust">C调用Rust</h2>
<p>你可能想要用某种方式编译Rust，让C可以直接调用它。这件事很简单，只需要做少数的处理：</p>
<pre><code class="language-Rust"><div><span class="hljs-meta">#[no_mangle]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">extern</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">hello_rust</span></span>() -&gt; *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u8</span> {
    <span class="hljs-string">"Hello, world!\0"</span>.as_ptr()
}
</div></code></pre>
<p><code>extern</code>让它对应的函数符合C的调用规范，在上面的<a href="https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions">外部调用规范</a>一节有详细讨论。<code>no_mangle</code>属性关闭Rust的name mangling，让它更方便被链接。</p>
<h2 id="ffi%e5%92%8cpanic">FFI和panic</h2>
<p>使用FFI的时候要格外注意<code>panic!</code>。跨越FFI边界的<code>panic!</code>属于未定义行为。如果你写的代码可能会panic，你应该使用<code>catch_unwind</code>在一个闭包里执行它：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">use</span> std::panic::catch_unwind;

<span class="hljs-meta">#[no_mangle]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">extern</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">oh_no</span></span>() -&gt; <span class="hljs-built_in">i32</span> {
    <span class="hljs-keyword">let</span> result = catch_unwind(|| {
        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"Oops!"</span>);
    });
    <span class="hljs-keyword">match</span> result {
        <span class="hljs-literal">Ok</span>(_) =&gt; <span class="hljs-number">0</span>,
        <span class="hljs-literal">Err</span>(_) =&gt; <span class="hljs-number">1</span>,
    }
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {}
</div></code></pre>
<p>请注意，<code>catch_unwind</code>只能捕获可展开的panic，不能捕获abort。更多的信息请参考<code>catch_unwind</code>的文档。</p>
<h2 id="%e8%a1%a8%e7%a4%ba%e4%b8%8d%e9%80%8f%e6%98%8e%e7%bb%93%e6%9e%84%e4%bd%93">表示不透明结构体</h2>
<p>有时候，C的库要提供一个指针指向某个东西，但又不想让你知道那个东西的内部细节。最简单的方式是使用<code>void *</code>：</p>
<pre><code class="language-C"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span>;
</div></code></pre>
<p>在Rust中我们可以用<code>c_void</code>类型表示它：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> libc;

<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(arg: *<span class="hljs-keyword">mut</span> libc::c_void);
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bar</span></span>(arg: *<span class="hljs-keyword">mut</span> libc::c_void);
}
</div></code></pre>
<p>这是一个完全合法的方法。不过，我们其实还可以做得更好。要解决这个问题，一些C库可能会创建一个结构体，可结构体的细节和内存布局是私有的。这样提高了类型的安全性。这种结构体被称为”不透明“的。下面是一个C的例子：</p>
<pre><code class="language-C"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span>;</span> <span class="hljs-comment">/* Foo是一个接口，但它的内容不属于公共接口 */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Bar</span>;</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(struct Foo *arg)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(struct Bar *arg)</span></span>;
</div></code></pre>
<p>在Rust中，我们可以使用枚举来创建我们自己的不透明类型：</p>
<pre><code class="language-Rust"><div><span class="hljs-meta">#[repr(C)]</span> <span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span> { _private: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">0</span>] }
<span class="hljs-meta">#[repr(C)]</span> <span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Bar</span></span> { _private: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">0</span>] }

<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(arg: *<span class="hljs-keyword">mut</span> Foo);
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bar</span></span>(arg: *<span class="hljs-keyword">mut</span> Bar);
}
# <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {}
</div></code></pre>
<p>给结构体一个私有成员而不给它构造函数，这样我们就创建了一个不透明的类型，而且我们不能在模块之外实例化它。（没有成员的结构体可以在任何地方实例化）因为我们希望在FFI中使用这个类型，我们必须加上<code>#[repr(C)]</code>。还为了避免在FFI中使用<code>()</code>的时候出现警告，我们用了一个空数组。空数组和空类型的行为一致，同时它还是FFI兼容的。</p>
<p>但因为<code>Foo</code>和<code>Bar</code>是不同的类型，我们需要保证两者之间的类型安全性，所以我们不能把<code>Foo</code>的指针传递给<code>bar()</code>。</p>
<p>注意，用空枚举作为FFI类型是一个很不好的设计。编译器将空枚举视为不可达的空类型，所以使用<code>&amp;Empty</code>类型的值是很危险的，这可能导致很多程序中的问题（触发未定义行为）。</p>

    </body>
    </html>