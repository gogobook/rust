<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>处理零尺寸类型</title>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        
    </head>
    <body class="vscode-light">
        <h1 id="%e5%a4%84%e7%90%86%e9%9b%b6%e5%b0%ba%e5%af%b8%e7%b1%bb%e5%9e%8b">处理零尺寸类型</h1>
<blockquote>
<p>源:<a href="https://github.com/rust-lang-nursery/nomicon/blob/master/src/vec-zsts.md">vec-zsts.md</a>   Commit: e9335c82a2a73ad68f0516ff241c973dfa31ee16</p>
</blockquote>
<p>是时候和零尺寸类型开战了。安全Rust并不需要关心这个，但是Vec大量的依赖裸指针和内存分配，这些都需要零尺寸类型。我们要小心两件事情：</p>
<ul>
<li>当给分配器API传递分配尺寸为0时，会导致未定义行为</li>
<li>对零尺寸类型的裸指针做offset是一个no-op，这会破坏我们的C-style指针迭代器。</li>
</ul>
<p>幸好我们把指针迭代器和内存分配逻辑抽象出来放在RawValIter和RawVec中了。真是太方便了。</p>
<h2 id="%e4%b8%ba%e9%9b%b6%e5%b0%ba%e5%af%b8%e7%b1%bb%e5%9e%8b%e5%88%86%e9%85%8d%e7%a9%ba%e9%97%b4">为零尺寸类型分配空间</h2>
<p>如果分配器API不支持分配大小为0的空间，那么我们究竟储存了些什么呢？当然是<code>Unique::empty()</code>了！基本上所有关于ZST的操作都是no-op，因为ZST只有一个值，不需要储存或加载任何的状态。这也同样适用于<code>ptr::read</code>和<code>ptr::write</code>：它们根本不会看那个指针一眼。所以我们并不需要修改指针。</p>
<p>注意，我们之前的分配代码依赖于OOM会先于数值溢出出现的假设，对于零尺寸类型不再有效了。我们必须显式地保证cap的值在ZST的情况下不会溢出。</p>
<p>基于现在的架构，我们需要写3处保护代码，RawVec的三个方法每个都有一处。</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">impl</span>&lt;T&gt; RawVec&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>() -&gt; <span class="hljs-keyword">Self</span> {
        <span class="hljs-comment">// !0就是usize::MAX。这段分支代码在编译期就可以计算出结果。</span>
        <span class="hljs-keyword">let</span> cap = <span class="hljs-keyword">if</span> mem::size_of::&lt;T&gt;() == <span class="hljs-number">0</span> { !<span class="hljs-number">0</span> } <span class="hljs-keyword">else</span> { <span class="hljs-number">0</span> };

        <span class="hljs-comment">// Unique::empty()有着“未分配”和“零尺寸分配”的双重含义</span>
        RawVec { ptr: Unique::empty(), cap: cap }
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">grow</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-keyword">unsafe</span> {
            <span class="hljs-keyword">let</span> elem_size = mem::size_of::&lt;T&gt;();

            <span class="hljs-comment">// 因为当elem_size为0时我们设置了cap为usize::MAX，</span>
            <span class="hljs-comment">// 这一步成立意味着Vec的容量溢出了</span>
            <span class="hljs-built_in">assert!</span>(elem_size != <span class="hljs-number">0</span>, <span class="hljs-string">"capacity overflow"</span>);

            <span class="hljs-keyword">let</span> align = mem::align_of::&lt;T&gt;();

            <span class="hljs-keyword">let</span> (new_cap, ptr) = <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.cap == <span class="hljs-number">0</span> {
                <span class="hljs-keyword">let</span> ptr = heap::allocate(elem_size, align);
                (<span class="hljs-number">1</span>, ptr)
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">let</span> new_cap = <span class="hljs-number">2</span> * <span class="hljs-keyword">self</span>.cap;
                <span class="hljs-keyword">let</span> ptr = heap::reallocate(<span class="hljs-keyword">self</span>.ptr.as_ptr() <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> _,
                                            <span class="hljs-keyword">self</span>.cap * elem_size,
                                            new_cap * elem_size,
                                            align);
                (new_cap, ptr)
            };

            <span class="hljs-comment">// 如果分配或再分配失败，我们会得到null</span>
            <span class="hljs-keyword">if</span> ptr.is_null() { oom() }

            <span class="hljs-keyword">self</span>.ptr = Unique::new(ptr <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> _);
            <span class="hljs-keyword">self</span>.cap = new_cap;
        }
    }
}

<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> RawVec&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-keyword">let</span> elem_size = mem::size_of::&lt;T&gt;();

        <span class="hljs-comment">// 不要释放零尺寸空间，因为它根本就没有分配过</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.cap != <span class="hljs-number">0</span> &amp;&amp; elem_size != <span class="hljs-number">0</span> {
            <span class="hljs-keyword">let</span> align = mem::align_of::&lt;T&gt;();

            <span class="hljs-keyword">let</span> num_bytes = elem_size * <span class="hljs-keyword">self</span>.cap;
            <span class="hljs-keyword">unsafe</span> {
                heap::deallocate(<span class="hljs-keyword">self</span>.ptr.as_ptr() <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> _, num_bytes, align);
            }
        }
    }
}
</div></code></pre>
<p>就是这样。我们现在已经支持push和pop零尺寸类型了。但是迭代器（slice未提供的）还不能工作。</p>
<h2 id="%e8%bf%ad%e4%bb%a3%e9%9b%b6%e5%b0%ba%e5%af%b8%e7%b1%bb%e5%9e%8b">迭代零尺寸类型</h2>
<p>offset 0是一个no-op。这意味着我们的<code>start</code>和<code>end</code>总是会被初始化为相同的值，我们的迭代器也无法产生任何的东西。当前的解决方案是把指针转换为整数，增加他们的值，然后再转换回来：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">impl</span>&lt;T&gt; RawValIter&lt;T&gt; {
    <span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(slice: &amp;[T]) -&gt; <span class="hljs-keyword">Self</span> {
        RawValIter {
            start: slice.as_ptr(),
            end: <span class="hljs-keyword">if</span> mem::size_of::&lt;T&gt;() == <span class="hljs-number">0</span> {
                ((slice.as_ptr() <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>) + slice.len()) <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> _
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> slice.len() == <span class="hljs-number">0</span> {
                slice.as_ptr()
            } <span class="hljs-keyword">else</span> {
                slice.as_ptr().offset(slice.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">isize</span>)
            }
        }
    }
}
</div></code></pre>
<p>现在我们有了一个新的bug。我们成功地让迭代器从完全不运行，变成了永远不停地运行。我们需要在迭代器的实现中玩同样的把戏。同时，<code>size_hint</code>在ZST的情况下会出现除数为0的问题。因为我们假设这两个指针都指向某个字节，我们在除数为0的情况下直接将除数变为1。</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Iterator</span> <span class="hljs-keyword">for</span> RawValIter&lt;T&gt; {
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Item</span></span> = T;
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;T&gt; {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.start == <span class="hljs-keyword">self</span>.end {
            <span class="hljs-literal">None</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">unsafe</span> {
                <span class="hljs-keyword">let</span> result = ptr::read(<span class="hljs-keyword">self</span>.start);
                <span class="hljs-keyword">self</span>.start = <span class="hljs-keyword">if</span> mem::size_of::&lt;T&gt;() == <span class="hljs-number">0</span> {
                    (<span class="hljs-keyword">self</span>.start <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span> + <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> _
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">self</span>.start.offset(<span class="hljs-number">1</span>)
                };
                <span class="hljs-literal">Some</span>(result)
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">size_hint</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; (<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">usize</span>&gt;) {
        <span class="hljs-keyword">let</span> elem_size = mem::size_of::&lt;T&gt;();
        <span class="hljs-keyword">let</span> len = (<span class="hljs-keyword">self</span>.end <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span> - <span class="hljs-keyword">self</span>.start <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>)
                  / <span class="hljs-keyword">if</span> elem_size == <span class="hljs-number">0</span> { <span class="hljs-number">1</span> } <span class="hljs-keyword">else</span> { elem_size };
        (len, <span class="hljs-literal">Some</span>(len))
    }
}

<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">DoubleEndedIterator</span> <span class="hljs-keyword">for</span> RawValIter&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next_back</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;T&gt; {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.start == <span class="hljs-keyword">self</span>.end {
            <span class="hljs-literal">None</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">unsafe</span> {
                <span class="hljs-keyword">self</span>.end = <span class="hljs-keyword">if</span> mem::size_of::&lt;T&gt;() == <span class="hljs-number">0</span> {
                    (<span class="hljs-keyword">self</span>.end <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span> - <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> _
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">self</span>.end.offset(-<span class="hljs-number">1</span>)
                };
                <span class="hljs-literal">Some</span>(ptr::read(<span class="hljs-keyword">self</span>.end))
            }
        }
    }
}
</div></code></pre>
<p>很好，迭代器也可以工作了。</p>

    </body>
    </html>