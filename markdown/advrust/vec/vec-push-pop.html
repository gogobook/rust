<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Push与Pop</title>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        
    </head>
    <body class="vscode-light">
        <h1 id="push%e4%b8%8epop">Push与Pop</h1>
<blockquote>
<p>源-<a href="https://github.com/rust-lang-nursery/nomicon/blob/master/src/vec-push-pop.md">vec-push-pop.md</a>   Commit: 0e6c680ebd72f1860e46b2bd40e2a387ad8084ad</p>
</blockquote>
<p>很好。我们可以初始化，我们也可以分配内存。现在我们开始实现一些真正的功能！我们就从<code>push</code>开始吧。它要做的事情就是检查空间是否已满，满了就扩容，然后写数据到下一个索引位置，最后增加长度。</p>
<p>写数据时，我们一定要小心，不要计算我们要写入的内存位置的值。最坏的情况，那块内存是一块未初始化的内存。最好的情况是那里存着我们已经pop出去的值。不管哪种情况，我们都不能直接索引这块内存然后解引用它，因为这样其实是把内存中的值当做了一个合法的T的实例。更糟糕的是，<code>foo[idx] = x</code>会调用<code>foo[idx]</code>处旧有值的<code>drop</code>方法！</p>
<p>正确的方法是使用<code>ptr::write</code>，它直接用值的二进制覆盖目标地址，不会计算任何的值。</p>
<p>对于<code>push</code>，如果原有的长度（调用push之前的长度）为0，那么我们就要写到第0个索引位置。所以我们应该用原有的长度做offset。</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">push</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, elem: T) {
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.len == <span class="hljs-keyword">self</span>.cap { <span class="hljs-keyword">self</span>.grow(); }

    <span class="hljs-keyword">unsafe</span> {
        ptr::write(<span class="hljs-keyword">self</span>.ptr.offset(<span class="hljs-keyword">self</span>.len <span class="hljs-keyword">as</span> <span class="hljs-built_in">isize</span>), elem);
    }

    <span class="hljs-comment">// 这一句不会失败，而会首先OOM</span>
    <span class="hljs-keyword">self</span>.len += <span class="hljs-number">1</span>;
}
</div></code></pre>
<p>小菜一碟！那么<code>pop</code>是什么样的呢？尽管现在我们要访问的索引位置已经初始化了，Rust不允许我们用解引用的方式将值移出，因为那样的话整个内存都会回到未初始化状态！这时我们需要用<code>ptr:read</code>，它从目标位置拷贝出二进制值，然后解析成类型T的值。这时原有位置处的内存逻辑上是未初始化的，可实际上那里还是存在这一个正常的T的实例。</p>
<p>对于<code>pop</code>，如果原有长度是1，我们要读的是第0个索引位置。所以我们应该是按新的长度做offset。</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">pop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;T&gt; {
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.len == <span class="hljs-number">0</span> {
        <span class="hljs-literal">None</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">self</span>.len -= <span class="hljs-number">1</span>;
        <span class="hljs-keyword">unsafe</span> {
            <span class="hljs-literal">Some</span>(ptr::read(<span class="hljs-keyword">self</span>.ptr.offset(<span class="hljs-keyword">self</span>.len <span class="hljs-keyword">as</span> <span class="hljs-built_in">isize</span>)))
        }
    }
}
</div></code></pre>

    </body>
    </html>