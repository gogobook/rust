<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Drain</title>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        
    </head>
    <body class="vscode-light">
        <h1 id="drain">Drain</h1>
<blockquote>
<p>源-<a href="https://github.com/rust-lang-nursery/nomicon/blob/master/src/vec-drain.md">vec-drain.md</a>   Commit: e45316fbe872ed879c0d0be4cd90492b6c3afa2d</p>
</blockquote>
<p>我们接着看看Drain。Drain和IntoIter基本相同，只不过它并不获取Vec的值，而是借用Vec并且不改变它的分配空间。现在我们只是先最“基本”的全范围(full-range)的版本。</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">use</span> std::marker::PhantomData;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Drain</span></span>&lt;<span class="hljs-symbol">'a</span>, T: <span class="hljs-symbol">'a</span>&gt; {
    <span class="hljs-comment">// 这里需要限制生命周期。我们使用&amp;'a mut Vec&lt;T&gt;，因为这就是语义上我们包含的东西。</span>
    <span class="hljs-comment">// 我们只调用pop()和remove(0)</span>
    vec: PhantomData&lt;&amp;<span class="hljs-symbol">'a</span> <span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;T&gt;&gt;,
    start: *<span class="hljs-keyword">const</span> T,
    end: *<span class="hljs-keyword">const</span> T,
}

<span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">'a</span>, T&gt; <span class="hljs-built_in">Iterator</span> <span class="hljs-keyword">for</span> Drain&lt;<span class="hljs-symbol">'a</span>, T&gt; {
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Item</span></span> = T;
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;T&gt; {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.start == <span class="hljs-keyword">self</span>.end {
            <span class="hljs-literal">None</span>
</div></code></pre>
<p>——等一下，这个看着有点眼熟。我们需要做进一步的压缩。IntoIter和Drain有着完全一样的结构，我们把它提取出来。</p>
<pre><code class="language-Rust"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RawValIter</span></span>&lt;T&gt; {
    start: *<span class="hljs-keyword">const</span> T,
    end: *<span class="hljs-keyword">const</span> T,
}

<span class="hljs-keyword">impl</span>&lt;T&gt; RawValIter&lt;T&gt; {
    <span class="hljs-comment">// 构建它是非安全的，因为它没有关联的生命周期。</span>
    <span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(slice: &amp;[T]) -&gt; <span class="hljs-keyword">Self</span> {
        RawValIter {
            start: slice.as_ptr(),
            end: <span class="hljs-keyword">if</span> slice.len() == <span class="hljs-number">0</span> {
                <span class="hljs-comment">// 如果len == 0，说明没有真的分配内存。这时需要避免offset，</span>
                <span class="hljs-comment">// 因为那会给LLVM的GEP提供错误的信息</span>
                slice.as_ptr()
            } <span class="hljs-keyword">else</span> {
                slice.as_ptr().offset(slice.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">isize</span>)
            }
        }
    }
}

<span class="hljs-comment">// Iterator和DoubleEndedIterator的实现与IntoIter完全一样。</span>
</div></code></pre>
<p>IntoIter变成了这样：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IntoIter</span></span>&lt;T&gt; {
    _buf: RawVec&lt;T&gt;, <span class="hljs-comment">// 我们并不关心这个，只是需要它们保持分配空间不被销毁</span>
    iter: RawValIter&lt;T&gt;,
}

<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Iterator</span> <span class="hljs-keyword">for</span> IntoIter&lt;T&gt; {
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Item</span></span> = T;
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;T&gt; { <span class="hljs-keyword">self</span>.iter.next() }
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">size_hint</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; (<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">usize</span>&gt;) { <span class="hljs-keyword">self</span>.iter.size_hint() }
}

<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">DoubleEndedIterator</span> <span class="hljs-keyword">for</span> IntoIter&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next_back</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;T&gt; { <span class="hljs-keyword">self</span>.iter.next_back() }
}

<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> IntoIter&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.iter {}
    }
}

<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Vec</span>&lt;T&gt; {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">into_iter</span></span>(<span class="hljs-keyword">self</span>) -&gt; IntoIter&lt;T&gt; {
        <span class="hljs-keyword">unsafe</span> {
            <span class="hljs-keyword">let</span> iter = RawValIter::new(&amp;<span class="hljs-keyword">self</span>);

            <span class="hljs-keyword">let</span> buf = ptr::read(&amp;<span class="hljs-keyword">self</span>.buf);
            mem::forget(<span class="hljs-keyword">self</span>);

            IntoIter {
                iter: iter,
                _buf: buf,
            }
        }
    }
}
</div></code></pre>
<p>注意，我在设计中留下了一些小后门，以便更简单地将Drain升级为可访问任意子范围的版本。特别是，我们可以在drop中让RawValIter遍历它自己。但是这种设计不适用于更复杂的Drain。我们还使用一个slice简化Drain的初始化。</p>
<p>好了，现在Drain变得很简单：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">use</span> std::marker::PhantomData;

<span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Drain</span></span>&lt;<span class="hljs-symbol">'a</span>, T: <span class="hljs-symbol">'a</span>&gt; {
    vec: PhantomData&lt;&amp;<span class="hljs-symbol">'a</span> <span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;T&gt;&gt;,
    iter: RawValIter&lt;T&gt;,
}

<span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">'a</span>, T&gt; <span class="hljs-built_in">Iterator</span> <span class="hljs-keyword">for</span> Drain&lt;<span class="hljs-symbol">'a</span>, T&gt; {
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Item</span></span> = T;
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;T&gt; { <span class="hljs-keyword">self</span>.iter.next() }
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">size_hint</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; (<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">usize</span>&gt;) { <span class="hljs-keyword">self</span>.iter.size_hint() }
}

<span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">'a</span>, T&gt; <span class="hljs-built_in">DoubleEndedIterator</span> <span class="hljs-keyword">for</span> Drain&lt;<span class="hljs-symbol">'a</span>, T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next_back</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;T&gt; { <span class="hljs-keyword">self</span>.iter.next_back() }
}

<span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">'a</span>, T&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> Drain&lt;<span class="hljs-symbol">'a</span>, T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.iter {}
    }
}

<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Vec</span>&lt;T&gt; {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drain</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; Drain&lt;T&gt; {
        <span class="hljs-keyword">unsafe</span> {
            <span class="hljs-keyword">let</span> iter = RawValIter::new(&amp;<span class="hljs-keyword">self</span>);

            <span class="hljs-comment">// 这一步是为了mem::forget的安全。如果Drain被forget，我们会泄露整个Vec的内容</span>
            <span class="hljs-comment">// 同时，既然我们无论如何都会做这一步，为什么不现在做呢？</span>
            <span class="hljs-keyword">self</span>.len = <span class="hljs-number">0</span>;

            Drain {
                iter: iter,
                vec: PhantomData,
            }
        }
    }
}
</div></code></pre>
<p>关于更多的<code>mem::forget</code>的问题，请见<a href="https://rustlang-cn.org/office/rust/advrust/obrm/leaking.html">关于泄露的章节</a>。</p>

    </body>
    </html>