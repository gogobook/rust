<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>最终代码</title>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        
    </head>
    <body class="vscode-light">
        <h1 id="%e6%9c%80%e7%bb%88%e4%bb%a3%e7%a0%81">最终代码</h1>
<blockquote>
<p>源：<a href="https://github.com/rust-lang-nursery/nomicon/blob/master/src/vec-final.md">vec-final.md</a>   Commit: f3fb7c9a8f73998aaaab8177562f0c58ff082e37</p>
</blockquote>
<pre><code class="language-rust"><div><span class="hljs-meta">#![feature(ptr_internals)]</span>
<span class="hljs-meta">#![feature(allocator_api)]</span>
<span class="hljs-meta">#![feature(alloc_layout_extra)]</span>

<span class="hljs-keyword">use</span> std::ptr::{Unique, NonNull, <span class="hljs-keyword">self</span>};
<span class="hljs-keyword">use</span> std::mem;
<span class="hljs-keyword">use</span> std::ops::{Deref, DerefMut};
<span class="hljs-keyword">use</span> std::marker::PhantomData;
<span class="hljs-keyword">use</span> std::alloc::{Alloc, GlobalAlloc, Layout, Global, handle_alloc_error};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RawVec</span></span>&lt;T&gt; {
    ptr: Unique&lt;T&gt;,
    cap: <span class="hljs-built_in">usize</span>,
}

<span class="hljs-keyword">impl</span>&lt;T&gt; RawVec&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>() -&gt; <span class="hljs-keyword">Self</span> {
        <span class="hljs-comment">// !0 is usize::MAX. This branch should be stripped at compile time.</span>
        <span class="hljs-keyword">let</span> cap = <span class="hljs-keyword">if</span> mem::size_of::&lt;T&gt;() == <span class="hljs-number">0</span> { !<span class="hljs-number">0</span> } <span class="hljs-keyword">else</span> { <span class="hljs-number">0</span> };

        <span class="hljs-comment">// Unique::empty() doubles as "unallocated" and "zero-sized allocation"</span>
        RawVec { ptr: Unique::empty(), cap: cap }
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">grow</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-keyword">unsafe</span> {
            <span class="hljs-keyword">let</span> elem_size = mem::size_of::&lt;T&gt;();

            <span class="hljs-comment">// since we set the capacity to usize::MAX when elem_size is</span>
            <span class="hljs-comment">// 0, getting to here necessarily means the Vec is overfull.</span>
            <span class="hljs-built_in">assert!</span>(elem_size != <span class="hljs-number">0</span>, <span class="hljs-string">"capacity overflow"</span>);

            <span class="hljs-keyword">let</span> (new_cap, ptr) = <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.cap == <span class="hljs-number">0</span> {
                <span class="hljs-keyword">let</span> ptr = Global.alloc(Layout::array::&lt;T&gt;(<span class="hljs-number">1</span>).unwrap());
                (<span class="hljs-number">1</span>, ptr)
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">let</span> new_cap = <span class="hljs-number">2</span> * <span class="hljs-keyword">self</span>.cap;
                <span class="hljs-keyword">let</span> c: NonNull&lt;T&gt; = <span class="hljs-keyword">self</span>.ptr.into();
                <span class="hljs-keyword">let</span> ptr = Global.realloc(c.cast(),
                                         Layout::array::&lt;T&gt;(<span class="hljs-keyword">self</span>.cap).unwrap(),
                                         Layout::array::&lt;T&gt;(new_cap).unwrap().size());
                (new_cap, ptr)
            };

            <span class="hljs-comment">// If allocate or reallocate fail, oom</span>
            <span class="hljs-keyword">if</span> ptr.is_err() {
                handle_alloc_error(Layout::from_size_align_unchecked(
                    new_cap * elem_size,
                    mem::align_of::&lt;T&gt;(),
                ))
            }
            <span class="hljs-keyword">let</span> ptr = ptr.unwrap();

            <span class="hljs-keyword">self</span>.ptr = Unique::new_unchecked(ptr.as_ptr() <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> _);
            <span class="hljs-keyword">self</span>.cap = new_cap;
        }
    }
}

<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> RawVec&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-keyword">let</span> elem_size = mem::size_of::&lt;T&gt;();
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.cap != <span class="hljs-number">0</span> &amp;&amp; elem_size != <span class="hljs-number">0</span> {
            <span class="hljs-keyword">unsafe</span> {
                <span class="hljs-keyword">let</span> c: NonNull&lt;T&gt; = <span class="hljs-keyword">self</span>.ptr.into();
                Global.dealloc(c.cast(),
                               Layout::array::&lt;T&gt;(<span class="hljs-keyword">self</span>.cap).unwrap());
            }
        }
    }
}

<span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vec</span></span>&lt;T&gt; {
    buf: RawVec&lt;T&gt;,
    len: <span class="hljs-built_in">usize</span>,
}

<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Vec</span>&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">ptr</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; *<span class="hljs-keyword">mut</span> T { <span class="hljs-keyword">self</span>.buf.ptr.as_ptr() }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">cap</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">usize</span> { <span class="hljs-keyword">self</span>.buf.cap }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>() -&gt; <span class="hljs-keyword">Self</span> {
        <span class="hljs-built_in">Vec</span> { buf: RawVec::new(), len: <span class="hljs-number">0</span> }
    }
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">push</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, elem: T) {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.len == <span class="hljs-keyword">self</span>.cap() { <span class="hljs-keyword">self</span>.buf.grow(); }

        <span class="hljs-keyword">unsafe</span> {
            ptr::write(<span class="hljs-keyword">self</span>.ptr().offset(<span class="hljs-keyword">self</span>.len <span class="hljs-keyword">as</span> <span class="hljs-built_in">isize</span>), elem);
        }

        <span class="hljs-comment">// Can't fail, we'll OOM first.</span>
        <span class="hljs-keyword">self</span>.len += <span class="hljs-number">1</span>;
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">pop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;T&gt; {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.len == <span class="hljs-number">0</span> {
            <span class="hljs-literal">None</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">self</span>.len -= <span class="hljs-number">1</span>;
            <span class="hljs-keyword">unsafe</span> {
                <span class="hljs-literal">Some</span>(ptr::read(<span class="hljs-keyword">self</span>.ptr().offset(<span class="hljs-keyword">self</span>.len <span class="hljs-keyword">as</span> <span class="hljs-built_in">isize</span>)))
            }
        }
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">insert</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, index: <span class="hljs-built_in">usize</span>, elem: T) {
        <span class="hljs-built_in">assert!</span>(index &lt;= <span class="hljs-keyword">self</span>.len, <span class="hljs-string">"index out of bounds"</span>);
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.cap() == <span class="hljs-keyword">self</span>.len { <span class="hljs-keyword">self</span>.buf.grow(); }

        <span class="hljs-keyword">unsafe</span> {
            <span class="hljs-keyword">if</span> index &lt; <span class="hljs-keyword">self</span>.len {
                ptr::copy(<span class="hljs-keyword">self</span>.ptr().offset(index <span class="hljs-keyword">as</span> <span class="hljs-built_in">isize</span>),
                          <span class="hljs-keyword">self</span>.ptr().offset(index <span class="hljs-keyword">as</span> <span class="hljs-built_in">isize</span> + <span class="hljs-number">1</span>),
                          <span class="hljs-keyword">self</span>.len - index);
            }
            ptr::write(<span class="hljs-keyword">self</span>.ptr().offset(index <span class="hljs-keyword">as</span> <span class="hljs-built_in">isize</span>), elem);
            <span class="hljs-keyword">self</span>.len += <span class="hljs-number">1</span>;
        }
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">remove</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, index: <span class="hljs-built_in">usize</span>) -&gt; T {
        <span class="hljs-built_in">assert!</span>(index &lt; <span class="hljs-keyword">self</span>.len, <span class="hljs-string">"index out of bounds"</span>);
        <span class="hljs-keyword">unsafe</span> {
            <span class="hljs-keyword">self</span>.len -= <span class="hljs-number">1</span>;
            <span class="hljs-keyword">let</span> result = ptr::read(<span class="hljs-keyword">self</span>.ptr().offset(index <span class="hljs-keyword">as</span> <span class="hljs-built_in">isize</span>));
            ptr::copy(<span class="hljs-keyword">self</span>.ptr().offset(index <span class="hljs-keyword">as</span> <span class="hljs-built_in">isize</span> + <span class="hljs-number">1</span>),
                      <span class="hljs-keyword">self</span>.ptr().offset(index <span class="hljs-keyword">as</span> <span class="hljs-built_in">isize</span>),
                      <span class="hljs-keyword">self</span>.len - index);
            result
        }
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">into_iter</span></span>(<span class="hljs-keyword">self</span>) -&gt; IntoIter&lt;T&gt; {
        <span class="hljs-keyword">unsafe</span> {
            <span class="hljs-keyword">let</span> iter = RawValIter::new(&amp;<span class="hljs-keyword">self</span>);
            <span class="hljs-keyword">let</span> buf = ptr::read(&amp;<span class="hljs-keyword">self</span>.buf);
            mem::forget(<span class="hljs-keyword">self</span>);

            IntoIter {
                iter: iter,
                _buf: buf,
            }
        }
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drain</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; Drain&lt;T&gt; {
        <span class="hljs-keyword">unsafe</span> {
            <span class="hljs-keyword">let</span> iter = RawValIter::new(&amp;<span class="hljs-keyword">self</span>);

            <span class="hljs-comment">// this is a mem::forget safety thing. If Drain is forgotten, we just</span>
            <span class="hljs-comment">// leak the whole Vec's contents. Also we need to do this *eventually*</span>
            <span class="hljs-comment">// anyway, so why not do it now?</span>
            <span class="hljs-keyword">self</span>.len = <span class="hljs-number">0</span>;

            Drain {
                iter: iter,
                vec: PhantomData,
            }
        }
    }
}

<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-built_in">Vec</span>&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(_) = <span class="hljs-keyword">self</span>.pop() {}
        <span class="hljs-comment">// allocation is handled by RawVec</span>
    }
}

<span class="hljs-keyword">impl</span>&lt;T&gt; Deref <span class="hljs-keyword">for</span> <span class="hljs-built_in">Vec</span>&lt;T&gt; {
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Target</span></span> = [T];
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;[T] {
        <span class="hljs-keyword">unsafe</span> {
            ::std::slice::from_raw_parts(<span class="hljs-keyword">self</span>.ptr(), <span class="hljs-keyword">self</span>.len)
        }
    }
}

<span class="hljs-keyword">impl</span>&lt;T&gt; DerefMut <span class="hljs-keyword">for</span> <span class="hljs-built_in">Vec</span>&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref_mut</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-keyword">mut</span> [T] {
        <span class="hljs-keyword">unsafe</span> {
            ::std::slice::from_raw_parts_mut(<span class="hljs-keyword">self</span>.ptr(), <span class="hljs-keyword">self</span>.len)
        }
    }
}





<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RawValIter</span></span>&lt;T&gt; {
    start: *<span class="hljs-keyword">const</span> T,
    end: *<span class="hljs-keyword">const</span> T,
}

<span class="hljs-keyword">impl</span>&lt;T&gt; RawValIter&lt;T&gt; {
    <span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(slice: &amp;[T]) -&gt; <span class="hljs-keyword">Self</span> {
        RawValIter {
            start: slice.as_ptr(),
            end: <span class="hljs-keyword">if</span> mem::size_of::&lt;T&gt;() == <span class="hljs-number">0</span> {
                ((slice.as_ptr() <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>) + slice.len()) <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> _
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> slice.len() == <span class="hljs-number">0</span> {
                slice.as_ptr()
            } <span class="hljs-keyword">else</span> {
                slice.as_ptr().offset(slice.len() <span class="hljs-keyword">as</span> <span class="hljs-built_in">isize</span>)
            }
        }
    }
}

<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Iterator</span> <span class="hljs-keyword">for</span> RawValIter&lt;T&gt; {
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Item</span></span> = T;
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;T&gt; {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.start == <span class="hljs-keyword">self</span>.end {
            <span class="hljs-literal">None</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">unsafe</span> {
                <span class="hljs-keyword">let</span> result = ptr::read(<span class="hljs-keyword">self</span>.start);
                <span class="hljs-keyword">self</span>.start = <span class="hljs-keyword">if</span> mem::size_of::&lt;T&gt;() == <span class="hljs-number">0</span> {
                    (<span class="hljs-keyword">self</span>.start <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span> + <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> _
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">self</span>.start.offset(<span class="hljs-number">1</span>)
                };
                <span class="hljs-literal">Some</span>(result)
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">size_hint</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; (<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">usize</span>&gt;) {
        <span class="hljs-keyword">let</span> elem_size = mem::size_of::&lt;T&gt;();
        <span class="hljs-keyword">let</span> len = (<span class="hljs-keyword">self</span>.end <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span> - <span class="hljs-keyword">self</span>.start <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>)
                  / <span class="hljs-keyword">if</span> elem_size == <span class="hljs-number">0</span> { <span class="hljs-number">1</span> } <span class="hljs-keyword">else</span> { elem_size };
        (len, <span class="hljs-literal">Some</span>(len))
    }
}

<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">DoubleEndedIterator</span> <span class="hljs-keyword">for</span> RawValIter&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next_back</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;T&gt; {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.start == <span class="hljs-keyword">self</span>.end {
            <span class="hljs-literal">None</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">unsafe</span> {
                <span class="hljs-keyword">self</span>.end = <span class="hljs-keyword">if</span> mem::size_of::&lt;T&gt;() == <span class="hljs-number">0</span> {
                    (<span class="hljs-keyword">self</span>.end <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span> - <span class="hljs-number">1</span>) <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> _
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">self</span>.end.offset(-<span class="hljs-number">1</span>)
                };
                <span class="hljs-literal">Some</span>(ptr::read(<span class="hljs-keyword">self</span>.end))
            }
        }
    }
}




<span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IntoIter</span></span>&lt;T&gt; {
    _buf: RawVec&lt;T&gt;, <span class="hljs-comment">// we don't actually care about this. Just need it to live.</span>
    iter: RawValIter&lt;T&gt;,
}

<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Iterator</span> <span class="hljs-keyword">for</span> IntoIter&lt;T&gt; {
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Item</span></span> = T;
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;T&gt; { <span class="hljs-keyword">self</span>.iter.next() }
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">size_hint</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; (<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">usize</span>&gt;) { <span class="hljs-keyword">self</span>.iter.size_hint() }
}

<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">DoubleEndedIterator</span> <span class="hljs-keyword">for</span> IntoIter&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next_back</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;T&gt; { <span class="hljs-keyword">self</span>.iter.next_back() }
}

<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> IntoIter&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> *<span class="hljs-keyword">self</span> {}
    }
}




<span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Drain</span></span>&lt;<span class="hljs-symbol">'a</span>, T: <span class="hljs-symbol">'a</span>&gt; {
    vec: PhantomData&lt;&amp;<span class="hljs-symbol">'a</span> <span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;T&gt;&gt;,
    iter: RawValIter&lt;T&gt;,
}

<span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">'a</span>, T&gt; <span class="hljs-built_in">Iterator</span> <span class="hljs-keyword">for</span> Drain&lt;<span class="hljs-symbol">'a</span>, T&gt; {
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Item</span></span> = T;
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;T&gt; { <span class="hljs-keyword">self</span>.iter.next() }
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">size_hint</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; (<span class="hljs-built_in">usize</span>, <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">usize</span>&gt;) { <span class="hljs-keyword">self</span>.iter.size_hint() }
}

<span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">'a</span>, T&gt; <span class="hljs-built_in">DoubleEndedIterator</span> <span class="hljs-keyword">for</span> Drain&lt;<span class="hljs-symbol">'a</span>, T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next_back</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;T&gt; { <span class="hljs-keyword">self</span>.iter.next_back() }
}

<span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">'a</span>, T&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> Drain&lt;<span class="hljs-symbol">'a</span>, T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-comment">// pre-drain the iter</span>
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.iter {}
    }
}

# <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
#     tests::create_push_pop();
#     tests::iter_test();
#     tests::test_drain();
#     tests::test_zst();
#     <span class="hljs-built_in">println!</span>(<span class="hljs-string">"All tests finished OK"</span>);
# }

# <span class="hljs-keyword">mod</span> tests {
#     <span class="hljs-keyword">use</span> super::*;
#     <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">create_push_pop</span></span>() {
#         <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v = <span class="hljs-built_in">Vec</span>::new();
#         v.push(<span class="hljs-number">1</span>);
#         <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">1</span>, v.len());
#         <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">1</span>, v[<span class="hljs-number">0</span>]);
#         <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> v.iter_mut() {
#             *i += <span class="hljs-number">1</span>;
#         }
#         v.insert(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);
#         <span class="hljs-keyword">let</span> x = v.pop();
#         <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-literal">Some</span>(<span class="hljs-number">2</span>), x);
#         <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">1</span>, v.len());
#         v.push(<span class="hljs-number">10</span>);
#         <span class="hljs-keyword">let</span> x = v.remove(<span class="hljs-number">0</span>);
#         <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, x);
#         <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">1</span>, v.len());
#     }
#
#     <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">iter_test</span></span>() {
#         <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v = <span class="hljs-built_in">Vec</span>::new();
#         <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> {
#             v.push(<span class="hljs-built_in">Box</span>::new(i))
#         }
#         <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> iter = v.into_iter();
#         <span class="hljs-keyword">let</span> first = iter.next().unwrap();
#         <span class="hljs-keyword">let</span> last = iter.next_back().unwrap();
#         <span class="hljs-built_in">drop</span>(iter);
#         <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">0</span>, *first);
#         <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">9</span>, *last);
#     }
#
#     <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_drain</span></span>() {
#         <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v = <span class="hljs-built_in">Vec</span>::new();
#         <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> {
#             v.push(<span class="hljs-built_in">Box</span>::new(i))
#         }
#         {
#             <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> drain = v.drain();
#             <span class="hljs-keyword">let</span> first = drain.next().unwrap();
#             <span class="hljs-keyword">let</span> last = drain.next_back().unwrap();
#             <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">0</span>, *first);
#             <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">9</span>, *last);
#         }
#         <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">0</span>, v.len());
#         v.push(<span class="hljs-built_in">Box</span>::new(<span class="hljs-number">1</span>));
#         <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">1</span>, *v.pop().unwrap());
#     }
#
#     <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_zst</span></span>() {
#         <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v = <span class="hljs-built_in">Vec</span>::new();
#         <span class="hljs-keyword">for</span> _i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> {
#             v.push(())
#         }
#
#         <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> count = <span class="hljs-number">0</span>;
#
#         <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> v.into_iter() {
#             count += <span class="hljs-number">1</span>
#         }
#
#         <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">10</span>, count);
#     }
# }
</div></code></pre>

    </body>
    </html>