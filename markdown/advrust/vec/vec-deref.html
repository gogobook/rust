<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Deref</title>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        
    </head>
    <body class="vscode-light">
        <h1 id="deref">Deref</h1>
<blockquote>
<p>源-<a href="https://github.com/rust-lang-nursery/nomicon/blob/master/src/vec-deref.md">vec-deref.md</a>   Commit: e9335c82a2a73ad68f0516ff241c973dfa31ee16</p>
</blockquote>
<p>不错！我们实现了一个成熟的小的栈。我们可以push、可以pop、也可以自动清理。但是还是有一堆的功能是我们需要的。特别是，我们已经有了一个很好的数组，但是还没有slice相关的功能。这非常容易解决：我们可以实现<code>Deref&lt;Target=[T]&gt;</code>。这样我们的Vec就神奇地变成了slice。</p>
<p>我们只需要使用<code>slice::from_raw_parts</code>。它能够为我们正确处理空slice。等到后面我们完成了零尺寸类型的支持，它们依然可以完美配合。</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">use</span> std::ops::Deref;

<span class="hljs-keyword">impl</span>&lt;T&gt; Deref <span class="hljs-keyword">for</span> <span class="hljs-built_in">Vec</span>&lt;T&gt; {
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Target</span></span> = [T];
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;[T] {
        <span class="hljs-keyword">unsafe</span> {
            ::std::slice::from_raw_parts(<span class="hljs-keyword">self</span>.ptr.as_ptr(), <span class="hljs-keyword">self</span>.len)
        }
    }
}
</div></code></pre>
<p>我们把DefMut也实现了吧：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">use</span> std::ops::DerefMut;

<span class="hljs-keyword">impl</span>&lt;T&gt; DerefMut <span class="hljs-keyword">for</span> <span class="hljs-built_in">Vec</span>&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref_mut</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-keyword">mut</span> [T] {
        <span class="hljs-keyword">unsafe</span> {
            ::std::slice::from_raw_parts_mut(<span class="hljs-keyword">self</span>.ptr.as_ptr(), <span class="hljs-keyword">self</span>.len)
        }
    }
}
</div></code></pre>
<p>现在我们有了<code>len</code>、<code>first</code>、<code>last</code>、索引、分片、排序、<code>iter</code>、<code>iter_mut</code>，以及其他所有的slice提供的功能。完美！</p>

    </body>
    </html>