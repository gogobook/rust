<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>RawVec</title>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        
    </head>
    <body class="vscode-light">
        <h1 id="rawvec">RawVec</h1>
<blockquote>
<p>源-<a href="https://github.com/rust-lang-nursery/nomicon/blob/master/src/vec-raw.md">vec-raw.md</a>   Commit: e9335c82a2a73ad68f0516ff241c973dfa31ee16</p>
</blockquote>
<p>我们遇到了一个很有意思的情况：我们把初始化缓存和释放内存的逻辑在Vec和IntoIter里面一模一样地写了两次。现在我们已经实现了功能，而且发现了逻辑的重复，是时候对代码做一些压缩了。</p>
<p>我们要抽象出<code>(ptr, cap)</code>，并赋予它们分配、扩容和释放的逻辑：</p>
<pre><code class="language-Rust"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RawVec</span></span>&lt;T&gt; {
    ptr: Unique&lt;T&gt;,
    cap: <span class="hljs-built_in">usize</span>,
}

<span class="hljs-keyword">impl</span>&lt;T&gt; RawVec&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>() -&gt; <span class="hljs-keyword">Self</span> {
        <span class="hljs-built_in">assert!</span>(mem::size_of::&lt;T&gt;() != <span class="hljs-number">0</span>, <span class="hljs-string">"TODO:实现零尺寸类型的支持"</span>);
        RawVec { ptr: Unique::empty(), cap: <span class="hljs-number">0</span> }
    }

    <span class="hljs-comment">// 与Vec一样</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">grow</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-keyword">unsafe</span> {
            <span class="hljs-keyword">let</span> align = mem::align_of::&lt;T&gt;();
            <span class="hljs-keyword">let</span> elem_size = mem::size_of::&lt;T&gt;();

            <span class="hljs-keyword">let</span> (new_cap, ptr) = <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.cap == <span class="hljs-number">0</span> {
                <span class="hljs-keyword">let</span> ptr = heap::allocate(elem_size, align);
                (<span class="hljs-number">1</span>, ptr)
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">let</span> new_cap = <span class="hljs-number">2</span> * <span class="hljs-keyword">self</span>.cap;
                <span class="hljs-keyword">let</span> ptr = heap::reallocate(<span class="hljs-keyword">self</span>.ptr.as_ptr() <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> _,
                                            <span class="hljs-keyword">self</span>.cap * elem_size,
                                            new_cap * elem_size,
                                            align);
                (new_cap, ptr)
            };

            <span class="hljs-comment">// 如果分配或再分配失败，我们会得到null</span>
            <span class="hljs-keyword">if</span> ptr.is_null() { oom() }

            <span class="hljs-keyword">self</span>.ptr = Unique::new(ptr <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> _);
            <span class="hljs-keyword">self</span>.cap = new_cap;
        }
    }
}


<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> RawVec&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.cap != <span class="hljs-number">0</span> {
            <span class="hljs-keyword">let</span> align = mem::align_of::&lt;T&gt;();
            <span class="hljs-keyword">let</span> elem_size = mem::size_of::&lt;T&gt;();
            <span class="hljs-keyword">let</span> num_bytes = elem_size * <span class="hljs-keyword">self</span>.cap;
            <span class="hljs-keyword">unsafe</span> {
                heap::deallocate(<span class="hljs-keyword">self</span>.ptr.as_mut() <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> _, num_bytes, align);
            }
        }
    }
}
</div></code></pre>
<p>然后像下面这样改写Vec：</p>
<pre><code class="language-Rust"><div><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vec</span></span>&lt;T&gt; {
    buf: RawVec&lt;T&gt;,
    len: <span class="hljs-built_in">usize</span>,
}

<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Vec</span>&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">ptr</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; *<span class="hljs-keyword">mut</span> T { <span class="hljs-keyword">self</span>.buf.ptr.as_ptr() }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">cap</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">usize</span> { <span class="hljs-keyword">self</span>.buf.cap }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>() -&gt; <span class="hljs-keyword">Self</span> {
        <span class="hljs-built_in">Vec</span> { buf: RawVec::new(), len: <span class="hljs-number">0</span> }
    }

    <span class="hljs-comment">// push/pop/insert/remove基本没变，只改变了:</span>
    <span class="hljs-comment">// self.ptr -&gt; self.ptr()</span>
    <span class="hljs-comment">// self.cap -&gt; self.cap()</span>
    <span class="hljs-comment">// self.grow -&gt; self.buf.grow()</span>
}

<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-built_in">Vec</span>&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(_) = <span class="hljs-keyword">self</span>.pop() {}
        <span class="hljs-comment">// 释放空间由RawVec负责</span>
    }
}
</div></code></pre>
<p>最后我们可以简化IntoIter：</p>
<pre><code class="language-Rust"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IntoIter</span></span>&lt;T&gt; {
    _buf: RawVec&lt;T&gt;, <span class="hljs-comment">// 我们并不关心这个，只是需要它们保持分配空间不被销毁</span>
    start: *<span class="hljs-keyword">const</span> T,
    end: *<span class="hljs-keyword">const</span> T,
}

<span class="hljs-comment">// next和next_back保持不变，因为它们并没有用到buf</span>

<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> IntoIter&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-comment">// 只需要保证所有的元素都被读到了</span>
        <span class="hljs-comment">// 缓存会在随后自己清理自己</span>
        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> *<span class="hljs-keyword">self</span> {}
    }
}

<span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Vec</span>&lt;T&gt; {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">into_iter</span></span>(<span class="hljs-keyword">self</span>) -&gt; IntoIter&lt;T&gt; {
        <span class="hljs-keyword">unsafe</span> {
            <span class="hljs-comment">// 需要使用ptr::read非安全地把buf移出，因为它不是Copy，</span>
            <span class="hljs-comment">// 而且Vec实现了Drop（所以我们不能销毁它）</span>
            <span class="hljs-keyword">let</span> buf = ptr::read(&amp;<span class="hljs-keyword">self</span>.buf);
            <span class="hljs-keyword">let</span> len = <span class="hljs-keyword">self</span>.len;
            mem::forget(<span class="hljs-keyword">self</span>);

            IntoIter {
                start: *buf.ptr,
                end: buf.ptr.offset(len <span class="hljs-keyword">as</span> <span class="hljs-built_in">isize</span>),
                _buf: buf,
            }
        }
    }
}
</div></code></pre>
<p>现在看起来好多了。</p>

    </body>
    </html>